{
    "Generals": [
        {
            "id": 1,
            "name": "Tell me",
            "question": "Tell me something about yourself?",
            "answer": "Hi, Iâ€™m Varun Simha. I have overall 5 years of experience as a Full-Stack Developer, currently working with Verizon in Bangalore location. I am expertise in frontend technologies like React.js, Redux, JavaScript, HTML, CSS and backend Technologies like Node.js, Express JS, RESTful API, Microservices, MySQL and also worked on CI-CD tools like Git, GitHub, Jenkins and AWS for the code deployment. So far, I worked on three different domains like eCommerce, Insurance and HealthCare Projects. And currently waiting for the chance to work in new company thanks"
        },
        {
            "id": 2,
            "name": "Current Project",
            "question": "Explain about your Current Project",
            "answer": "My current project is NMG (Neiman Marcus Group) â˜‘ï¸ which is an American eCommerce Project. The main purpose of this project is â˜‘ï¸To provide a seamless online shopping experience for NMG customers.â˜‘ï¸To manage product listings, pricing, inventory, and offers efficiently.â˜‘ï¸ To handle secure user authentication, cart management, checkout, and payments.â˜‘ï¸ To support high traffic, fast search results, and smooth order processing and alsoâ˜‘ï¸ To integrate with warehouses, delivery partners, and internal ERP systems.â˜‘ï¸ In this Project, we have different modules likeâ˜‘ï¸ User Management Module=>under this we have - Login, registration, profile, address book.â˜‘ï¸ Product Catalog Module=>under this we have - Category pages, product details, filters, search.â˜‘ï¸ Inventory Management Module=> under this we have - Stock updates, availability, SKU management.â˜‘ï¸ Cart & Wishlist Module=> under this we have - Add/remove items, update quantities, save for later.â˜‘ï¸Checkout & Payments Module=> Address selection, payment gateway, order summary.â˜‘ï¸ Order Management Module=> Order creation, tracking, returns/refunds.â˜‘ï¸ Offers & Promotions Module=> Coupons, discount rules, seasonal campaigns.â˜‘ï¸ Admin Portal Module=> Product upload, pricing updates, inventory dashboard. *** I used - Backend Skills like (Node JS + Express JS + Microservices + MySQL)-âœŒï¸ Developed RESTful APIs for products, cart, auth, orders.âœŒï¸ Followed Microservices architecture for scalability.âœŒï¸ Used Express JS for routing, middleware, validations.âœŒï¸ Implemented JWT authentication & session handling.âœŒï¸ Used MySQL for user data, inventory, orders, transactions.âœŒï¸ Implemented async operations, caching, pagination.âœŒï¸ *** I used Frontend Skills like (React JS + Redux + HTML + CSS + JavaScript)âœŒï¸ Built responsive UI using React JS.âœŒï¸ Managed state using Redux Toolkit. Implemented product listing, cart UI, checkout flows.âœ‹ Reused React components for faster development.ðŸ‘Œ Used Axios to call backend REST APIs.ðŸ«± Applied CSS/Styled Components for branding/UI design."
        },
        {
            "id": 3,
            "name": "Roles and Responsibilities",
            "question": "Explain about your Roles and Responsibilities on this NMG Project",
            "answer": "My Roles is a React JS and Node JS Full Stack Developer And My Responsibilities are: â˜ï¸ Gathering and Analysing the Requirements from the UX Designers, Architect and sometimes from the Clients also.  After that depends on the requirements as given in the JIRA ticketing tool, â˜ï¸ Developing RESTful APIs using Node JS & Express JS for products, cart, orders, users. âœŒï¸ Building Microservices for authentication, catalog, orders, inventory. ðŸ¤Ÿ Writing optimized SQL queries and designing SQL tables for eCommerce flows. âœ‹ Implementing JWT authentication, middleware, validation, error handling. ðŸ‘Œ Integrating backend APIs with React frontend using Axios/Fetch.ðŸ«± Developing responsive UI screens for product listing, cart, checkout, profile.ðŸ«² Managing application state using Redux / Redux Toolkit.ðŸ«³ Optimizing API performance using pagination, caching, indexing.ðŸ«´ Handling end-to-end features: requirement â†’ UI â†’ API â†’ DB â†’ testing.ðŸ‘ Collaborating with QA, UI/UX, and backend teams for smooth releases.ðŸ™Œ Fixing production bugs and improving application performance."
        },
        {
            "id": 4,
            "name": "Daily Activities",
            "question": "Explain about your Day-to-Day Daily Activities on this NMG Project",
            "answer": "My Day-to-Day Daily Activities are:â˜ï¸ Attending daily stand-ups for sharing work progress & blockers, for example what I did today and what are my plannings to do tomorrow and also need to discuss about Is there any blocker or pending task.â˜ï¸Checking the emails and JIRA ticketing tool for User Stories.âœŒï¸ Working on assigned UI or API tasks for new features.ðŸ¤Ÿ Writing and testing REST APIs and integrating with frontend.âœ‹ Developing React components and updating Redux states.ðŸ‘Œ Fixing bugs from QA and production tickets.ðŸ«± Writing SQL queries for validations and backend logic.ðŸ«² Doing code reviews and pushing code to Git.ðŸ«³ Testing APIs using Postman and validating UI flows.ðŸ«´ Collaborating with backend, QA, and UI/UX teamsðŸ‘ Participating in deployment activities for QA/UAT/Prod."
        },
        {
            "id": 5,
            "name": "Backend Challenges",
            "question": "Explain Technically faced challenges on your NMG eCommerce Project as a Node JS, Express JS, RESTful API, Microservices, SQL Developer",
            "answer": "Yes, I faced some issues while developing Backend Applications. Here main challenges are:â˜ï¸ Challenge 1 â€” Slow product-listing API (high latency)â€¢Main issue: product listing API was slow under load (page loads > 3s).â€¢Why it happened: Unoptimized SQL (full-table scans) + N+1 queries for product images and variants.â€¢How found:Profiling with slow-query logs, EXPLAIN plans, and backend tracing (high DB time).â€¢Fix: Added proper indexes, rewrote queries with joins/CTEs, batch-fetched related data, introduced pagination.â€¢Benefits: Response times dropped significantly, lower DB CPU, better user experience and conversion.âœŒï¸Challenge 2 â€” Inventory race conditions (overselling)â€¢Main issue: Two concurrent checkouts sold the same last SKU.â€¢Why it happened: Lack of transactional control across services and no atomic stock decrement.â€¢How found: Customer complaints + audit logs showed duplicate successful orders for same SKU.â€¢Fix: Implemented DB-level transactions with SELECT ...FOR UPDATE / optimistic locking and moved stock decrement into a single atomic operation; added idempotency keys for order creation.â€¢Benefits: Eliminated overselling, reduced refunds, improved trust and fewer manual fixes.ðŸ¤Ÿ Challenge 3 â€” Inconsistent cache (stale product/pricing data)â€¢Main issue: Users saw old prices after admin updates.â€¢Why it happened: Redis cache TTLs + missing cache invalidation after updates across microservices.â€¢How found: Reproducible steps: update price in Admin â†’ frontend still showed old price; logs showed cache hit.â€¢Fix: Implemented cache invalidation events via message broker (Kafka/Rabbit) and short TTL for critical keys.â€¢Benefits: Data consistency across services, correct pricing during checkout, fewer pricing disputes."
        },
        {
            "id": 6,
            "name": "Frontend Challenges",
            "question": "Explain Technically faced challenges on your NMG eCommerce Project as a React JS, Redux, CSS, JavaScript, HTML, CSS Developer",
            "answer": "Yes, I faced some Challenges while developing frontend Application:â˜ï¸Challenge 1 â€” Slow initial page load / large bundleâ€¢Main issue here is: First-load time high, slow Time-to-Interactive.â€¢Why that issue came means: Large JS bundle (many libs + unused code) and no code-splitting.â€¢How I found issue means: Lighthouse scores, network waterfall showed huge main.js and long parse time. So â€¢I could Fixed this issue â€” steps:1.Audit bundle with webpack source-map-explorer.2.Remove unused libs, replace heavy libs with lighter alternatives.3.Implement route-based code-splitting (React.lazy + Suspense).4.Use dynamic imports for large components (product carousel, admin panels).5.Enable production optimizations: tree-shaking, minification, gzip/Brotli.â€¢Benefits: Faster first paint, improved SEO, higher conversion and Lighthouse scores.âœŒï¸Challenge 2â€”UI state inconsistency (cart & product sync issues)â€¢Main issue: Cart count/UI didnâ€™t reflect backend changes or multiple tabs.â€¢Why: Local component state + stale Redux state + no real-time sync.â€¢How found: Repro on two tabs and after API responses; logs showed stale state updates.â€¢Fix â€” steps:1.Centralize canonical state in Redux (single source of truth).2.Use optimistic updates with rollback on failure.3.Add websocket or polling to sync cart across tabs/sessions.4.Use action idempotency and sequence numbers to avoid out-of-order updates.â€¢Benefits: Consistent UI, fewer checkout errors, better cross-tab UX.ðŸ¤Ÿ Challenge 3â€”Slow rendering / janky UI on product grid (performance)â€¢Main issue: Scrolling grid janks; repaint delays on hover/filters.â€¢Why: Re-rendering many DOM nodes; expensive computations in render.â€¢How found: React Profiler showed frequent re-renders and long commit times.â€¢Fix â€” steps:1.Memoize pure components with React.memo.2.Use useMemo / useCallback for derived data and handlers.3.Virtualize long lists (react-window / react-virtualized).4.Move heavy calculations outside render (precompute or web worker).â€¢Benefits: Smooth scrolling, lower CPU, improved perceived performance."
        },
        {
            "id": 7,
            "name": "Ratings",
            "question": "How much rate can you give for React JS, Redux, CSS, JavaScript?",
            "answer": "I will give 4 rating for out of 5 to each technology Means for React JS is â€“ 4,Redux is â€“ 4,JavaScript is â€“ 4,HTML is â€“ 4,CSS is â€“ 4 for out of 5.=========> for Node JS is â€“ 4, Express JS is â€“ 4. RESTful API is â€“ 4,Microservices is â€“ 4, MySQL is â€“ 4 for out of 5"
        }
    ],
    "HTML": [
        {
            "id": 1,
            "name": "What is HTML",
            "question": "**What is HTML?**",
            "answer": "HTML is the standard markup language for creating web pages.\nIt defines the structure and content of a page using elements and tags.",
            "useCases": [
                "Structure product pages, headings, paragraphs, and lists.",
                "Create forms for checkout, login, and search in eCommerce."
            ],
            "realTimeUseCases": [
                "NMG product page uses semantic tags like <article>, <section>, and <header> for SEO and accessibility.",
                "Forms for checkout use <form>, proper labels and input types to reduce cart abandonment."
            ]
        },
        {
            "id": 2,
            "name": "Semantic HTML",
            "question": "**What is semantic HTML and why is it important?**",
            "answer": "Semantic HTML uses meaningful tags to describe content purpose, not just presentation.\nIt improves accessibility, SEO, and maintainability.",
            "useCases": [
                "Use <nav> for navigation, <main> for main content, <footer> for page footer.",
                "Screen readers and search engines rely on semantics for better results."
            ],
            "realTimeUseCases": [
                "NMG category pages use <main> and <aside> so filters and content are parsed correctly by crawlers.",
                "Semantic markup reduced manual SEO fixes and improved organic product discovery."
            ]
        },
        {
            "id": 3,
            "name": "DOCTYPE",
            "question": "**What does <!DOCTYPE html> do?**",
            "answer": "The doctype tells browsers to render the page in standards (HTML5) mode.\nIt prevents quirks-mode rendering differences across browsers.",
            "useCases": [
                "Ensure consistent CSS and layout behavior across browsers.",
                "Required as the first line of modern HTML documents."
            ],
            "realTimeUseCases": [
                "All NMG pages include the HTML5 doctype to avoid cross-browser layout bugs in product grids.",
                "Using the correct doctype reduced UI regressions during browser updates."
            ]
        },
        {
            "id": 4,
            "name": "Block vs Inline",
            "question": "**Difference between block-level and inline elements?**",
            "answer": "Block elements start on a new line and take full available width; inline elements flow within a line.\nUse blocks for layout and inlines for small content pieces.",
            "useCases": [
                "Use <div>, <section>, <header> for layout (block).",
                "Use <span>, <a>, <strong> for text-level semantics (inline)."
            ],
            "realTimeUseCases": [
                "NMG product cards use block containers for image and meta, inline elements for price and tag labels.",
                "Correct usage simplified responsive CSS and reduced layout overrides."
            ]
        },
        {
            "id": 5,
            "name": "Accessible Forms",
            "question": "**How do you make HTML forms accessible?**",
            "answer": "Use proper labels, fieldset/legend, ARIA only when necessary, and semantic input types.\nProvide clear error messages and keyboard-friendly controls.",
            "useCases": [
                "Associate <label> with inputs using for/id attributes.",
                "Use required, pattern, and type attributes for native validation."
            ],
            "realTimeUseCases": [
                "NMG checkout forms use explicit labels and aria-live regions for validation errors to aid screen readers.",
                "Accessible forms lowered support tickets and improved conversion for users with assistive tech."
            ]
        },
        {
            "id": 6,
            "name": "HTML5 Elements",
            "question": "**What are some important HTML5 elements you use frequently?**",
            "answer": "Key HTML5 elements include <section>, <article>, <nav>, <header>, <footer>, <figure>, and <main>.\nThey provide meaningful structure and improve document flow and semantics.",
            "useCases": [
                "Structure content blocks, group media with captions, and declare primary content area.",
                "Improve SEO and accessibility via explicit landmarks."
            ],
            "realTimeUseCases": [
                "NMG product detail pages use <figure> with <figcaption> for product images and captions.",
                "Search engines and internal crawlers leverage these tags to extract product summaries."
            ]
        },
        {
            "id": 7,
            "name": "Responsive Images",
            "question": "**How does responsive image loading work (srcset and sizes)?**",
            "answer": "Use srcset and sizes to let the browser pick the best image for device resolution and viewport.\nThis reduces bandwidth and improves load times on mobile.",
            "useCases": [
                "Provide multiple image widths in srcset and describe expected layout in sizes.",
                "Combine with lazy-loading to defer offscreen images."
            ],
            "realTimeUseCases": [
                "NMG serves smaller thumbnails for mobile and larger images for desktop using srcset, improving Core Web Vitals.",
                "Reduced mobile data usage led to faster time-to-interactive on category pages."
            ]
        },
        {
            "id": 8,
            "name": "Meta Tags",
            "question": "**What is the role of meta tags in HTML?**",
            "answer": "Meta tags provide metadata like charset, viewport, description, and robots directives.\nThey affect SEO, mobile rendering, and how pages are indexed or cached.",
            "useCases": [
                "Set <meta name=\"viewport\"> for responsive scaling.",
                "Use description and og: tags to improve social sharing and SEO."
            ],
            "realTimeUseCases": [
                "NMG product pages include structured meta and Open Graph tags to improve link previews and search listings.",
                "Proper caching meta and CSP headers reduced click-to-content latency and improved security."
            ]
        },
        {
            "id": 9,
            "name": "Canvas vs SVG",
            "question": "**When should you use <canvas> vs SVG?**",
            "answer": "Use <canvas> for pixel-based, high-performance drawing and animations; use SVG for vector graphics and DOM-accessible shapes.\nChoose based on interactivity, scalability, and accessibility needs.",
            "useCases": [
                "Canvas: complex animations or image processing.",
                "SVG: icons, diagrams, and interactive charts that need accessibility."
            ],
            "realTimeUseCases": [
                "NMG uses SVG for scalable icons and simple charts; canvas for image compositing in product customizers.",
                "Using SVG improved clarity on high-DPI displays and simplified styling via CSS."
            ]
        },
        {
            "id": 10,
            "name": "HTML Optimization",
            "question": "**How do you optimize HTML for performance and SEO?**",
            "answer": "Minimize DOM size, use semantic markup, defer non-critical scripts, and compress assets.\nServe meaningful content early to improve perceived load and SEO signals.",
            "useCases": [
                "Inline critical CSS, defer JS, and preload key resources.",
                "Keep HTML lean and avoid excessive nested elements."
            ],
            "realTimeUseCases": [
                "NMG reduced DOM nodes on category pages and saw measurable improvements in LCP and SEO crawl budget usage.",
                "Preloading fonts and hero images improved first meaningful paint on product pages."
            ]
        },
        {
            "id": 11,
            "name": "ARIA Attributes",
            "question": "**What are ARIA attributes and when should you use them?**",
            "answer": "ARIA provides additional accessibility semantics for complex widgets that native HTML can't express.\nPrefer native HTML; use ARIA only when semantics cannot be achieved otherwise.",
            "useCases": [
                "Use role, aria-label, aria-expanded for custom components.",
                "Avoid redundant ARIA on elements that already convey semantics."
            ],
            "realTimeUseCases": [
                "NMG uses ARIA roles on custom widgets like autocomplete and complex filters while keeping native inputs where possible.",
                "Proper ARIA usage reduced screen-reader navigation friction during checkout."
            ]
        },
        {
            "id": 12,
            "name": "CORS & CSP",
            "question": "**How do you handle cross-origin and Content Security Policy (CSP) in HTML?**",
            "answer": "CSP is a header (or meta) that restricts allowed sources for scripts, styles, and other resources to mitigate XSS.\nUse proper CORS headers for API requests and a strict CSP with trusted domains.",
            "useCases": [
                "Set CSP directives for default-src, script-src, style-src, and img-src.",
                "Use crossorigin attributes and Access-Control-Allow-Origin on APIs."
            ],
            "realTimeUseCases": [
                "NMG enforced a strict CSP and configured CORS for CDN and API domains, reducing XSS risk and securing third-party integrations.",
                "CSP reporting helped catch accidental inline scripts and tighten security policy over time."
            ]
        },
        {
            "id": 1,
            "name": "What is HTML and why to use it?",
            "question": "What is HTML and why to use it? How It runs in the browser or what will happen when you run the HTML file or page in the Browser?",
            "answer": "HTML (HyperText Markup Language) is a standard markup language used to create web pages. It provides the structure and content of web pages using tags and elements. When you run an HTML file in a browser, the browser parses the HTML code and renders it as a visual web page. The browser interprets the HTML tags, applies default styling, and displays the content to the user. HTML works together with CSS for styling and JavaScript for interactivity.",
            "useCases": [
                "Creating web page structure",
                "Displaying content",
                "Building web applications",
                "Creating forms"
            ],
            "realTimeUseCases": [
                "Building websites",
                "Creating web interfaces",
                "Email templates",
                "Document markup"
            ]
        },
        {
            "id": 2,
            "name": "What is <!DOCTYPE HTML>?",
            "question": "What is <!DOCTYPE HTML> ? why to use it? Or keep it in the HTML page? What will happen If you not keep <!DOCTYPE HTML> in the HTML Page?",
            "answer": "<!DOCTYPE HTML> is a declaration that specifies the version of HTML being used. It tells the browser to render the page in standards mode. Without <!DOCTYPE>, the browser may enter 'quirks mode', which can cause inconsistent rendering and unexpected behavior. The <!DOCTYPE> should always be the first line in an HTML document. It is required in HTML5 and helps ensure consistent cross-browser compatibility.",
            "useCases": [
                "Standards compliance",
                "Browser compatibility",
                "Ensuring proper rendering",
                "HTML5 validation"
            ],
            "realTimeUseCases": [
                "Creating valid HTML documents",
                "Ensuring cross-browser support",
                "Web standards compliance",
                "HTML validation"
            ]
        },
        {
            "id": 3,
            "name": "What are Block Level Tags and Inline Elements?",
            "question": "What are the Block Level Tags and Inline Elements? What are the main differences between them?",
            "answer": "Block-level tags (like <div>, <p>, <h1>, <section>) take up the full available width and start on a new line. They create a line break before and after. Inline elements (like <span>, <a>, <strong>, <em>) only take up as much width as needed and flow within text. Block elements respect all margins and padding, while inline elements only respect left and right margins. Block elements can contain other block and inline elements, but inline elements cannot contain block elements.",
            "useCases": [
                "Page layout",
                "Content organization",
                "Styling structure",
                "Semantic markup"
            ],
            "realTimeUseCases": [
                "Creating page sections",
                "Typography management",
                "Layout control",
                "Content wrapping"
            ]
        },
        {
            "id": 4,
            "name": "What is <div> and <span>?",
            "question": "What is <div> and <span> why to use them?",
            "answer": "<div> is a block-level container element used to group and organize content. <span> is an inline container used to wrap small portions of text or inline content. Both are generic elements with no semantic meaning but are useful for applying CSS styles and JavaScript manipulation. <div> is used for larger sections and layout, while <span> is used for small inline text selections. They are the most commonly used container elements in HTML.",
            "useCases": [
                "Creating layouts",
                "Grouping content",
                "Applying styles",
                "JavaScript manipulation"
            ],
            "realTimeUseCases": [
                "Page structure",
                "CSS styling",
                "Responsive design",
                "DOM manipulation"
            ]
        },
        {
            "id": 5,
            "name": "What are Semantic Elements in HTML?",
            "question": "What are the Semantic Elements in the HTML? Why to use it? What are the benefits of it?",
            "answer": "Semantic elements clearly describe their meaning to both the browser and developer (e.g., <header>, <nav>, <main>, <article>, <section>, <aside>, <footer>). They provide meaning and structure to web content. Benefits include: improved SEO, better accessibility for screen readers, cleaner and more maintainable code, and improved browser compatibility. Semantic HTML helps search engines understand page structure and helps assistive technologies provide better user experience.",
            "useCases": [
                "SEO optimization",
                "Accessibility",
                "Code clarity",
                "Document structure"
            ],
            "realTimeUseCases": [
                "Building accessible websites",
                "Improving search rankings",
                "Assistive technology support",
                "Content organization"
            ]
        },
        {
            "id": 6,
            "name": "What are Web Workers in HTML?",
            "question": "What are the Web Workers in the HTML Page? What are the Types of Web Storages in the HTML?",
            "answer": "Web Workers are JavaScript programs that run in the background, separate from the main thread. They allow heavy computations to run without blocking the UI. Web Storages are mechanisms to store data on the client-side: LocalStorage (persistent), SessionStorage (temporary per session), and Cookies (small persistent data). Web Storage provides larger storage capacity than cookies and is more efficient for client-side data storage.",
            "useCases": [
                "Background computation",
                "Data persistence",
                "Client-side caching",
                "Session management"
            ],
            "realTimeUseCases": [
                "Image processing",
                "Data analytics",
                "User preferences",
                "Form data caching"
            ]
        },
        {
            "id": 7,
            "name": "What is LocalStorage?",
            "question": "What is LocalStorage? Why to use it? When to use it? What is the Importance of it?",
            "answer": "LocalStorage is a client-side storage mechanism that stores data persistently with no expiration date. Data remains even after the browser is closed. It is limited to about 5-10MB per domain. Use it for: user preferences, app settings, authentication tokens, and data that should persist between sessions. Importance: reduces server load, improves performance, enables offline functionality, and enhances user experience by remembering user preferences.",
            "useCases": [
                "User preferences",
                "App settings",
                "Caching data",
                "Authentication tokens"
            ],
            "realTimeUseCases": [
                "Remember login state",
                "Store user theme preference",
                "Save form data",
                "Offline app support"
            ]
        },
        {
            "id": 8,
            "name": "What is SessionStorage?",
            "question": "What is SessionStorage? Why to use it? When to use it? What is the Importance of it?",
            "answer": "SessionStorage is similar to LocalStorage but stores data only for the duration of the page session. Data is cleared when the tab or browser is closed. It is useful for temporary data that should not persist. Use it for: temporary user data, form progress, session-specific settings, and navigation state. Importance: provides temporary storage without polluting persistent storage, improves performance by reducing database queries, and enhances security by not persisting sensitive data.",
            "useCases": [
                "Temporary data",
                "Session state",
                "Form progress",
                "Navigation history"
            ],
            "realTimeUseCases": [
                "Multi-step form data",
                "Session tokens",
                "Temporary UI state",
                "Page navigation stack"
            ]
        },
        {
            "id": 9,
            "name": "Differences between LocalStorage, SessionStorage, and Cookies",
            "question": "What are the main differences between LocalStorage and Session Storages? Cookies vs Cahes?",
            "answer": "LocalStorage persists indefinitely until explicitly cleared, while SessionStorage clears when the tab closes. LocalStorage and SessionStorage have ~5-10MB capacity, while cookies have ~4KB. Cookies are sent with every HTTP request (overhead), while Web Storage is not. LocalStorage/SessionStorage are synchronous and faster, cookies can be HttpOnly for security. Caching is a broader concept including browser cache, CDN cache, and application cache. Choose LocalStorage for persistent user data, SessionStorage for temporary data, and Cookies for small data that needs to be sent to the server.",
            "useCases": [
                "Data persistence",
                "Performance optimization",
                "Security",
                "Client-server communication"
            ],
            "realTimeUseCases": [
                "Authentication",
                "User preferences",
                "Session management",
                "Performance optimization"
            ]
        },
        {
            "id": 10,
            "name": "What are HTML5 Features?",
            "question": "What are the HTML5 Features explain all?",
            "answer": "HTML5 major features include: Semantic elements (<header>, <nav>, <article>, etc.), Canvas (drawing graphics), SVG (scalable vector graphics), Audio and Video tags (media playback), Geolocation API (location services), Web Storage (LocalStorage, SessionStorage), Web Workers (background processing), History API (navigation control), Drag and Drop API, Offline capabilities, Responsive design support, improved form validation, and better accessibility. HTML5 modernized web development enabling rich, interactive applications without plugins.",
            "useCases": [
                "Modern web development",
                "Rich media",
                "Offline applications",
                "Enhanced user experience"
            ],
            "realTimeUseCases": [
                "Video streaming",
                "Interactive graphics",
                "Mobile-first design",
                "Progressive web apps"
            ]
        },
        {
            "id": 11,
            "name": "What is Geolocation?",
            "question": "What is GeoLocation and why to use it? When to use it? For what purpose we do have to use it?",
            "answer": "Geolocation API allows web applications to obtain the user's geographical position with their permission. It uses GPS, cell tower triangulation, or IP address. Why use it: enables location-based services, personalized content, and context-aware features. When to use it: mapping applications, location-based recommendations, local business discovery, weather apps, and ride-sharing services. Always request permission and use HTTPS. Important for privacy - users must explicitly grant permission.",
            "useCases": [
                "Mapping services",
                "Location-based recommendations",
                "Local search",
                "Proximity alerts"
            ],
            "realTimeUseCases": [
                "Google Maps integration",
                "Weather apps",
                "Restaurant finders",
                "Ride-sharing apps"
            ]
        }
    ],
    "CSS": [
        {
            "id": 1,
            "name": "What is CSS",
            "question": "**What is CSS?**",
            "answer": "CSS is Cascading Style Sheets, used to style and layout web pages.\nIt separates presentation from HTML structure, enabling consistent design across multiple pages.",
            "useCases": [
                "Apply colors, fonts, spacing, and layout to HTML elements.",
                "Create responsive designs that adapt to different screen sizes."
            ],
            "realTimeUseCases": [
                "NMG product pages use CSS for responsive grid layouts that adapt from mobile to desktop views.",
                "Global CSS framework ensures consistent branding across all eCommerce pages."
            ]
        },
        {
            "id": 2,
            "name": "Selectors & Specificity",
            "question": "**What is CSS specificity and how does cascading work?**",
            "answer": "Specificity determines which CSS rule applies when multiple rules target the same element.\nCascading means the last rule wins if specificity is equal; inline > IDs > classes/attributes > elements.",
            "useCases": [
                "Manage conflicts between global styles and component overrides.",
                "Use classes and avoid !important to keep styles predictable."
            ],
            "realTimeUseCases": [
                "NMG component library uses low-specificity selectors so product teams can safely override styles without !important.",
                "Proper cascade hierarchy reduced CSS bugs and simplified maintenance."
            ]
        },
        {
            "id": 3,
            "name": "Box Model",
            "question": "**Explain the CSS box model.**",
            "answer": "The box model consists of content, padding, border, and margin.\nUnderstanding it is essential for layout; box-sizing controls whether width/height includes padding/border.",
            "useCases": [
                "Predict element sizes and spacing in layouts.",
                "Use box-sizing: border-box for easier calculations."
            ],
            "realTimeUseCases": [
                "NMG sets box-sizing: border-box globally so product cards render at exact widths without overflow.",
                "Consistent box model reduced layout shifts and improved UI predictability."
            ]
        },
        {
            "id": 4,
            "name": "Flexbox",
            "question": "**What is Flexbox and when should you use it?**",
            "answer": "Flexbox is a layout model for arranging items in a row or column with automatic spacing and alignment.\nUse it for component-level layouts, navigation bars, and card grids.",
            "useCases": [
                "Distribute space evenly among items using justify-content and align-items.",
                "Create flexible, responsive layouts without floats or positioning."
            ],
            "realTimeUseCases": [
                "NMG navigation bar uses flexbox to align items and distribute space dynamically.",
                "Checkout form uses flex columns for stacking inputs responsively on mobile."
            ]
        },
        {
            "id": 5,
            "name": "CSS Grid",
            "question": "**What is CSS Grid and how does it differ from Flexbox?**",
            "answer": "CSS Grid is a 2D layout system for complex, multi-row/column layouts.\nFlexbox is 1D; Grid is better for page-level layouts with explicit rows and columns.",
            "useCases": [
                "Create dashboard-like layouts with consistent columns and rows.",
                "Combine Grid for overall structure and Flexbox for component internals."
            ],
            "realTimeUseCases": [
                "NMG product listing uses CSS Grid for responsive 3â€“4 column layouts that adapt to viewport width.",
                "Admin dashboard uses grid to organize product tables, charts, and sidebar panels."
            ]
        },
        {
            "id": 6,
            "name": "Positioning",
            "question": "**Explain CSS positioning (static, relative, absolute, fixed, sticky).**",
            "answer": "CSS positioning controls how elements flow and overlap.\nStatic (default), Relative (offset in place), Absolute (removed from flow, positioned relative to parent), Fixed (pinned to viewport), Sticky (toggles between relative and fixed).",
            "useCases": [
                "Create floating elements, overlays, and sticky headers.",
                "Use absolute positioning sparingly; flexbox/grid are often better."
            ],
            "realTimeUseCases": [
                "NMG sticky header stays visible when scrolling product lists.",
                "Modal dialogs use fixed positioning to center overlay above page content."
            ]
        },
        {
            "id": 7,
            "name": "Responsive Design",
            "question": "**How do you build responsive CSS designs?**",
            "answer": "Use media queries to apply different styles at breakpoints, mobile-first approach, and relative units (rem, %, vw).\nTest on real devices and use flexbox/grid for natural responsiveness.",
            "useCases": [
                "Define breakpoints (mobile, tablet, desktop) and adjust layout for each.",
                "Use flexible images and avoid fixed widths."
            ],
            "realTimeUseCases": [
                "NMG uses mobile-first CSS and media queries to transform single-column mobile layout to multi-column desktop.",
                "Responsive hero images adapt from small mobile versions to full-width desktop images."
            ]
        },
        {
            "id": 8,
            "name": "Pseudo-Classes & Pseudo-Elements",
            "question": "**What are CSS pseudo-classes and pseudo-elements?**",
            "answer": "Pseudo-classes (:hover, :focus, :nth-child) target elements based on state or position.\nPseudo-elements (::before, ::after, ::first-line) create/style virtual elements.",
            "useCases": [
                "Add hover effects to buttons and links.",
                "Use ::before/::after for decorative elements without extra HTML."
            ],
            "realTimeUseCases": [
                "NMG product buttons use :hover and :focus for interactive feedback.",
                "Testimonial quotes use ::before content for decorative quote marks."
            ]
        },
        {
            "id": 9,
            "name": "CSS Variables",
            "question": "**How do you use CSS custom properties (variables)?**",
            "answer": "CSS variables (--name: value) allow reusable values for colors, spacing, and fonts.\nUse them in var(--name) and update them globally or per-scope.",
            "useCases": [
                "Define a color palette and reuse across components.",
                "Change theme colors dynamically via JavaScript without recompiling CSS."
            ],
            "realTimeUseCases": [
                "NMG defines --primary-color, --text-color, and reuses them across all components.",
                "Dark mode support swaps CSS variables via JS without CSS duplication."
            ]
        },
        {
            "id": 10,
            "name": "Transitions & Animations",
            "question": "**What is the difference between CSS transitions and animations?**",
            "answer": "Transitions smoothly change properties over time in response to events (hover, click).\nAnimations use keyframes to define complex, multi-step sequences that play independently.",
            "useCases": [
                "Use transitions for simple property changes (hover effects, color shifts).",
                "Use animations for loading spinners, entrance effects, and complex sequences."
            ],
            "realTimeUseCases": [
                "NMG product image on hover uses a smooth transition for opacity/scale effects.",
                "Loading spinner uses @keyframes animation to rotate indefinitely."
            ]
        },
        {
            "id": 11,
            "name": "Performance & Optimization",
            "question": "**How do you optimize CSS for performance?**",
            "answer": "Minimize CSS, remove unused styles (PurgeCSS), avoid expensive selectors, use will-change sparingly, and defer non-critical CSS.\nCritical CSS should inline; non-critical should load async.",
            "useCases": [
                "Audit CSS with DevTools and remove dead code.",
                "Avoid expensive selectors like * or deeply nested rules."
            ],
            "realTimeUseCases": [
                "NMG uses PurgeCSS to strip unused Tailwind classes, reducing CSS bundle from 500KB to 50KB.",
                "Inlined critical CSS for hero section improves above-the-fold rendering."
            ]
        },
        {
            "id": 12,
            "name": "Preprocessing & Architecture",
            "question": "**What are CSS preprocessors (Sass/Less) and why use them?**",
            "answer": "Preprocessors like Sass add variables, nesting, mixins, and functions to CSS.\nThey compile to standard CSS and improve maintainability, especially for large projects.",
            "useCases": [
                "Use nesting to reduce code repetition and improve readability.",
                "Create reusable mixins for common patterns (buttons, forms)."
            ],
            "realTimeUseCases": [
                "NMG uses Sass mixins for breakpoints and color utilities shared across the design system.",
                "Nested rules reduce selector duplication and simplify button/input styling."
            ]
        }
    ],
    "JavaScript": [
        {
            "id": 1,
            "name": "What is JavaScript?",
            "question": "What is JavaScript?",
            "answer": "JavaScript is a high-level, interpreted programming language that runs in browsers and on servers (Node.js). It is used to add interactivity, manipulate the DOM, handle events, and build full-stack applications. It supports dynamic typing, first-class functions, and prototype-based inheritance.",
            "useCases": [
                "Client-side interactivity",
                "Server-side APIs"
            ],
            "realTimeUseCases": [
                "Form validation",
                "Dynamic product filters"
            ]
        },
        {
            "id": 2,
            "name": "Features of JavaScript",
            "question": "What are the features of JavaScript?",
            "answer": "Key features: dynamic typing, prototype-based OOP, first-class functions, closures, event-driven, asynchronous programming (Promises, async/await), runs in browser and server environments, and has a rich ecosystem of libraries and frameworks.",
            "useCases": [
                "Rapid prototyping",
                "Event-driven UIs"
            ],
            "realTimeUseCases": [
                "Real-time search suggestions",
                "Asynchronous API calls"
            ]
        },
        {
            "id": 3,
            "name": "Data Types in JavaScript",
            "question": "What are Data Types in JavaScript?",
            "answer": "Primitive types: string, number, bigint, boolean, undefined, null, symbol. Non-primitive: object (including arrays, functions, dates). JavaScript is dynamically typed so variables can hold any type.",
            "useCases": [
                "Type handling",
                "Data validation"
            ],
            "realTimeUseCases": [
                "Parsing API responses",
                "Form input handling"
            ]
        },
        {
            "id": 4,
            "name": "Primitive vs Non-Primitive",
            "question": "What is the difference between Primitive and Non-Primitive data types?",
            "answer": "Primitives are immutable values stored by value (e.g., numbers, strings). Non-primitives (objects/arrays/functions) are stored and assigned by reference; they are mutable and can hold properties.",
            "useCases": [
                "Memory model",
                "Equality checks"
            ],
            "realTimeUseCases": [
                "Copying objects carefully to avoid shared mutation"
            ]
        },
        {
            "id": 5,
            "name": "ECMAScript",
            "question": "What is ECMAScript?",
            "answer": "ECMAScript (ES) is the standard specification that defines the JavaScript language. ECMAScript versions (ES5, ES6/ES2015, ES2020, etc.) define language features implemented by engines (V8, SpiderMonkey).",
            "useCases": [
                "Language standardization",
                "Feature planning"
            ],
            "realTimeUseCases": [
                "Using ES modules and modern syntax compiled by Babel"
            ]
        },
        {
            "id": 6,
            "name": "JS vs ECMAScript",
            "question": "What is the difference between JavaScript and ECMAScript?",
            "answer": "ECMAScript is the language specification; JavaScript is the implementation (a dialect) in browsers and runtimes. In practice JS implements ECMAScript plus host APIs (DOM, BOM).",
            "useCases": [
                "Standards vs runtime"
            ],
            "realTimeUseCases": [
                "Transpiling ES features to support older browsers"
            ]
        },
        {
            "id": 7,
            "name": "var let const",
            "question": "What is var, let, const?",
            "answer": "`var` declares function-scoped or globally-scoped variables (hoisted). `let` declares block-scoped variables. `const` creates block-scoped read-only bindings (the reference is constant, objects can still be mutated). Prefer `let`/`const` in modern code.",
            "useCases": [
                "Variable declarations",
                "Scoping rules"
            ],
            "realTimeUseCases": [
                "Use const for config objects, let for loop counters"
            ]
        },
        {
            "id": 8,
            "name": "var vs let vs const",
            "question": "What are the differences between var vs let vs const?",
            "answer": "`var` is function-scoped and hoisted; allows re-declaration. `let` is block-scoped, not re-declarable in same scope, not initialized until declaration (TDZ). `const` is like let but cannot be reassigned; objects are still mutable.",
            "useCases": [
                "Choosing declarations",
                "Avoiding bugs"
            ],
            "realTimeUseCases": [
                "Replacing var with let/const to prevent accidental globals"
            ]
        },
        {
            "id": 9,
            "name": "Hoisting",
            "question": "What is Hoisting?",
            "answer": "Hoisting is JavaScript behavior where declarations (var, function) are moved to top of their scope at runtime. `var` declarations are hoisted and initialized with undefined; `let`/`const` are hoisted but uninitialized (TDZ). Function declarations are hoisted with their definitions.",
            "useCases": [
                "Understanding runtime behavior"
            ],
            "realTimeUseCases": [
                "Avoid relying on hoisting; declare variables before use"
            ]
        },
        {
            "id": 10,
            "name": "Temporal Dead Zone",
            "question": "What is Temporal Dead Zone?",
            "answer": "TDZ is the time between entering a scope and the variable's actual declaration when `let`/`const` exist but cannot be accessed; accessing them throws ReferenceError. Prevents use-before-declare for block-scoped variables.",
            "useCases": [
                "Avoiding undefined behaviors"
            ],
            "realTimeUseCases": [
                "Using let/const safely in loops and blocks"
            ]
        },
        {
            "id": 11,
            "name": "Scope",
            "question": "What is Scope?",
            "answer": "Scope is the region of code where a binding (variable) is visible. JavaScript has global scope, function scope, and block scope (for let/const). Scope controls variable lifetime and access.",
            "useCases": [
                "Encapsulation",
                "Memory management"
            ],
            "realTimeUseCases": [
                "Keeping variable usage limited inside modules/components"
            ]
        },
        {
            "id": 12,
            "name": "Types of Scope",
            "question": "Types of Scope in JavaScript?",
            "answer": "Global scope (top-level), function scope (declared with function or var), block scope (let/const within { }). Module scope (ES modules have their own top-level scope).",
            "useCases": [
                "Designing modules",
                "Avoiding globals"
            ],
            "realTimeUseCases": [
                "Using module scope for component-level utilities"
            ]
        },
        {
            "id": 13,
            "name": "Lexical Scope",
            "question": "What is Lexical Scope?",
            "answer": "Lexical scope (static scope) means the accessibility of variables is determined by the physical placement of code. Inner functions can access variables from outer lexical scopes. Closures use lexical scoping.",
            "useCases": [
                "Closures",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Factory functions that capture configuration values"
            ]
        },
        {
            "id": 14,
            "name": "Scope Chaining",
            "question": "What is Scope Chaining?",
            "answer": "Scope chaining is the process JS uses to resolve variable references: it first looks in the current scope, then outer scopes, up to global. This chain creates the lookup path for identifiers.",
            "useCases": [
                "Variable resolution",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Understanding why a variable is shadowed by inner scope"
            ]
        },
        {
            "id": 15,
            "name": "Normal Function",
            "question": "What is a normal function?",
            "answer": "A normal (function declaration or expression) is defined with the `function` keyword and has its own `this` context (dynamic at call time for non-arrow functions) and is hoisted (declaration form). Example: function add(a,b){return a+b}.",
            "useCases": [
                "Reusable logic",
                "Methods on objects"
            ],
            "realTimeUseCases": [
                "API utility functions in services"
            ]
        },
        {
            "id": 16,
            "name": "Arrow Function",
            "question": "What is an arrow function?",
            "answer": "Arrow functions use `=>` syntax and have lexical `this` (they inherit `this` from surrounding scope), cannot be used as constructors, and do not have their own `arguments` object. Example: const add=(a,b)=>a+b.",
            "useCases": [
                "Short callbacks",
                "Lexical this"
            ],
            "realTimeUseCases": [
                "Array map/filter callbacks and small render helpers"
            ]
        },
        {
            "id": 17,
            "name": "Normal vs Arrow",
            "question": "Differences between normal function vs arrow function?",
            "answer": "Key differences: arrow functions have lexical `this`, no `arguments`, cannot be used with `new`, and are not hoisted like function declarations. Choose arrow for concise callbacks, normal functions for methods needing dynamic `this`.",
            "useCases": [
                "Choosing function style"
            ],
            "realTimeUseCases": [
                "Use arrow functions for React component helpers"
            ]
        },
        {
            "id": 18,
            "name": "Higher-Order Function",
            "question": "What is a Higher-Order Function?",
            "answer": "A higher-order function takes functions as arguments and/or returns a function. Examples: map, filter, reduce, and function factories. Useful for abstraction and composition.",
            "useCases": [
                "Function composition",
                "Middleware"
            ],
            "realTimeUseCases": [
                "createLogger middleware that returns a wrapped function"
            ]
        },
        {
            "id": 19,
            "name": "Callback Function",
            "question": "What is a Callback Function?",
            "answer": "A callback is a function passed to another function to be called later (synchronously or asynchronously). Historically used for async patterns before Promises/async-await.",
            "useCases": [
                "Async handling",
                "Event handlers"
            ],
            "realTimeUseCases": [
                "XHR/fetch .then callbacks or event listeners"
            ]
        },
        {
            "id": 20,
            "name": "Function Currying",
            "question": "What is Function Currying?",
            "answer": "Currying transforms a function with multiple arguments into a sequence of functions each taking a single argument. Example: f(a,b) -> f(a)(b). Useful for partial application and reusable configuration.",
            "useCases": [
                "Partial application",
                "Reusable factories"
            ],
            "realTimeUseCases": [
                "createEndpoint(baseUrl)(path) to build API callers"
            ]
        },
        {
            "id": 21,
            "name": "Pure Function",
            "question": "What is Pure Function?",
            "answer": "A pure function returns the same output for the same inputs and has no side effects (doesn't modify external state). Pure functions are easier to test and reason about.",
            "useCases": [
                "Predictability",
                "Testing"
            ],
            "realTimeUseCases": [
                "Pure reducers in Redux"
            ]
        },
        {
            "id": 22,
            "name": "IIFE",
            "question": "What is IIFE?",
            "answer": "Immediately Invoked Function Expression: a function defined and executed immediately to create a private scope. Syntax: (function(){ /* ... */ })(); Used historically for module-like encapsulation before ES modules.",
            "useCases": [
                "Encapsulation",
                "Avoid globals"
            ],
            "realTimeUseCases": [
                "Legacy scripts wrapping module code"
            ]
        },
        {
            "id": 23,
            "name": "First-Class Functions",
            "question": "What are First-Class Functions?",
            "answer": "In JS functions are first-class citizens: they can be assigned to variables, passed to/returned from functions, and have properties. This enables functional programming patterns.",
            "useCases": [
                "Higher-order functions",
                "Callbacks"
            ],
            "realTimeUseCases": [
                "Event handlers stored in variables"
            ]
        },
        {
            "id": 24,
            "name": "this keyword",
            "question": "What is the this keyword?",
            "answer": "`this` refers to the execution context's object. Its value depends on how a function is called: method calls set `this` to the receiver object, standalone functions default to global/undefined in strict mode, constructors set `this` to the new instance.",
            "useCases": [
                "Object methods",
                "Constructors"
            ],
            "realTimeUseCases": [
                "Using methods that access instance properties"
            ]
        },
        {
            "id": 25,
            "name": "this normal vs arrow",
            "question": "How does this behave in normal vs arrow functions?",
            "answer": "Normal functions have dynamic `this` determined by call site (call/apply/bind can change it). Arrow functions inherit `this` lexically from surrounding scope and cannot change it with call/apply/bind.",
            "useCases": [
                "Choosing function type"
            ],
            "realTimeUseCases": [
                "Arrow function in class field to preserve `this` in callbacks"
            ]
        },
        {
            "id": 26,
            "name": "call",
            "question": "What is call()?",
            "answer": "`call` is a function method that invokes a function with an explicit `this` value and arguments passed individually: fn.call(thisArg, arg1, arg2).",
            "useCases": [
                "Method borrowing",
                "Setting this"
            ],
            "realTimeUseCases": [
                "Using array methods for array-like objects: Array.prototype.slice.call(args)"
            ]
        },
        {
            "id": 27,
            "name": "apply",
            "question": "What is apply()?",
            "answer": "`apply` is like call but accepts arguments as an array: fn.apply(thisArg, [arg1, arg2]). Useful when arguments are in an array form.",
            "useCases": [
                "Forwarding args",
                "Varargs handling"
            ],
            "realTimeUseCases": [
                "Math.max.apply(null, arr) to get max from array"
            ]
        },
        {
            "id": 28,
            "name": "bind",
            "question": "What is bind()?",
            "answer": "`bind` returns a new function with `this` permanently bound to the provided value and optionally prefills arguments: const f2 = f.bind(thisArg, a).",
            "useCases": [
                "Event handlers",
                "Partial application"
            ],
            "realTimeUseCases": [
                "Binding class methods in older React class components"
            ]
        },
        {
            "id": 29,
            "name": "call apply bind differences",
            "question": "Differences between call, apply, bind?",
            "answer": "`call` invokes immediately with args listed; `apply` invokes immediately with args array; `bind` returns a new function bound to provided `this` without invoking immediately.",
            "useCases": [
                "API differences",
                "Runtime usage"
            ],
            "realTimeUseCases": [
                "Using bind to pre-bind context for callbacks"
            ]
        },
        {
            "id": 30,
            "name": "== vs ===",
            "question": "What is the difference between == vs ===?",
            "answer": "`==` checks for equality with type coercion; `===` checks for strict equality without coercion. Prefer `===` to avoid unexpected conversions.",
            "useCases": [
                "Equality checks",
                "Bug avoidance"
            ],
            "realTimeUseCases": [
                "Comparing IDs where types might differ (string vs number) -- use ==="
            ]
        },
        {
            "id": 31,
            "name": "NaN",
            "question": "What is NaN?",
            "answer": "NaN stands for Not-a-Number and is the result of invalid numeric operations (e.g., parseInt(\"a\") or 0/0). It is a special numeric value in IEEE-754.",
            "useCases": [
                "Validation",
                "Number parsing"
            ],
            "realTimeUseCases": [
                "Checking parse results from API and handling invalid numbers"
            ]
        },
        {
            "id": 32,
            "name": "NaN equality",
            "question": "Why is NaN === NaN false?",
            "answer": "By specification NaN is not equal to anything, including itself. Use Number.isNaN(value) or isNaN to check for NaN.",
            "useCases": [
                "Edge-case checks"
            ],
            "realTimeUseCases": [
                "Detecting invalid numeric results"
            ]
        },
        {
            "id": 33,
            "name": "Type Coercion",
            "question": "What is Type Coercion?",
            "answer": "Type coercion is the automatic or implicit conversion of values from one type to another (e.g., \"5\" + 1 -> \"51\"). Coercion happens in comparisons and arithmetic operations.",
            "useCases": [
                "Implicit conversions",
                "Operator behavior"
            ],
            "realTimeUseCases": [
                "Guarding against string concatenation when numeric addition expected"
            ]
        },
        {
            "id": 34,
            "name": "Implicit Coercion",
            "question": "What is Implicit Coercion?",
            "answer": "Implicit coercion occurs when JS automatically converts types during operations (e.g., == comparison, arithmetic with mixed types). Explicit coercion uses functions like Number(), String().",
            "useCases": [
                "Debugging errors",
                "Data hygiene"
            ],
            "realTimeUseCases": [
                "Parsing query params which are strings into numbers explicitly"
            ]
        },
        {
            "id": 35,
            "name": "String definition",
            "question": "What is a string in JavaScript?",
            "answer": "A string is a sequence of characters used to represent text. In JS strings are immutable and can be created with single, double quotes, or backticks (template literals).",
            "useCases": [
                "Text data",
                "Templating"
            ],
            "realTimeUseCases": [
                "Product titles and descriptions"
            ]
        },
        {
            "id": 36,
            "name": "Create strings",
            "question": "Ways to create strings?",
            "answer": "Using single quotes ('...'), double quotes (\"...\"), or template literals (backticks) which support interpolation and multi-line strings. Also via String() constructor.",
            "useCases": [
                "Formatting",
                "Interpolation"
            ],
            "realTimeUseCases": [
                "Template literal for constructing URLs with query params"
            ]
        },
        {
            "id": 37,
            "name": "String methods",
            "question": "Important string methods?",
            "answer": "Common methods: length, slice, substring, substr, indexOf, includes, startsWith, endsWith, toLowerCase, toUpperCase, trim, split, replace, match.",
            "useCases": [
                "Parsing",
                "Validation"
            ],
            "realTimeUseCases": [
                "Sanitizing user input and search indexing"
            ]
        },
        {
            "id": 38,
            "name": "String immutability",
            "question": "What is string immutability?",
            "answer": "Strings are immutable â€” operations return a new string rather than modifying the original. To change a string, assign the result of an operation to a new variable.",
            "useCases": [
                "Memory considerations",
                "Safe transformations"
            ],
            "realTimeUseCases": [
                "Transforming product names without mutating input sources"
            ]
        },
        {
            "id": 39,
            "name": "Template Literal",
            "question": "What is Template Literal?",
            "answer": "Template literals (backticks) allow string interpolation with ${expr}, multi-line strings, and tagged templates for custom processing.",
            "useCases": [
                "Readable templates",
                "Multi-line strings"
            ],
            "realTimeUseCases": [
                "Building HTML fragments or URLs with variables"
            ]
        },
        {
            "id": 40,
            "name": "Array definition",
            "question": "What is an array?",
            "answer": "An array is an ordered list-like object used to store multiple values accessed by numeric indices. Arrays are objects with array-specific methods.",
            "useCases": [
                "Collections",
                "Lists"
            ],
            "realTimeUseCases": [
                "Product lists, cart items"
            ]
        },
        {
            "id": 41,
            "name": "Create arrays",
            "question": "Ways to create arrays?",
            "answer": "Literal: [] or new Array(length) or Array.of(...items). Use literals for most cases: const a=[1,2,3].",
            "useCases": [
                "Initialization",
                "Dynamic lists"
            ],
            "realTimeUseCases": [
                "Building product arrays from API responses"
            ]
        },
        {
            "id": 42,
            "name": "map",
            "question": "What is map()?",
            "answer": "map creates a new array by applying a function to each element of the original array. It does not mutate the original array.",
            "useCases": [
                "Transformation",
                "Pure mapping"
            ],
            "realTimeUseCases": [
                "Rendering product cards from product data"
            ]
        },
        {
            "id": 43,
            "name": "filter",
            "question": "What is filter()?",
            "answer": "filter returns a new array containing elements that satisfy a predicate function. Does not mutate original.",
            "useCases": [
                "Filtering datasets"
            ],
            "realTimeUseCases": [
                "Filtering products by category or price range"
            ]
        },
        {
            "id": 44,
            "name": "reduce",
            "question": "What is reduce()?",
            "answer": "reduce applies a reducer function to accumulate array values into a single result (sum, object, etc.). It receives an accumulator and current value.",
            "useCases": [
                "Aggregation",
                "Computations"
            ],
            "realTimeUseCases": [
                "Calculating cart totals"
            ]
        },
        {
            "id": 45,
            "name": "forEach",
            "question": "What is forEach()?",
            "answer": "forEach iterates over array elements and calls a provided function for each element; it returns undefined and is used for side effects rather than producing new arrays.",
            "useCases": [
                "Side-effect iteration"
            ],
            "realTimeUseCases": [
                "Logging items or mutating external state"
            ]
        },
        {
            "id": 46,
            "name": "map vs filter vs reduce vs forEach",
            "question": "Differences between map vs filter vs reduce vs forEach?",
            "answer": "map -> transforms to a new array; filter -> selects subset; reduce -> aggregates to single value; forEach -> iterates for side effects without returning a new collection.",
            "useCases": [
                "Choosing right tool"
            ],
            "realTimeUseCases": [
                "Use reduce to sum prices, map to render UI components"
            ]
        },
        {
            "id": 47,
            "name": "Shallow Copy",
            "question": "What is Shallow Copy?",
            "answer": "A shallow copy duplicates top-level values of an object/array but keeps references to nested objects. e.g., spread operator creates a shallow copy.",
            "useCases": [
                "Copying structures"
            ],
            "realTimeUseCases": [
                "Copying product object to change top-level fields while sharing nested references"
            ]
        },
        {
            "id": 48,
            "name": "Deep Copy",
            "question": "What is Deep Copy?",
            "answer": "Deep copy duplicates nested structures recursively so mutations to the copy do not affect the original. Use structuredClone, JSON methods (with caveats), or custom recursive cloning.",
            "useCases": [
                "Isolated copies"
            ],
            "realTimeUseCases": [
                "Immutable state snapshots for undo/redo"
            ]
        },
        {
            "id": 49,
            "name": "Spread vs Rest",
            "question": "Spread operator vs Rest operator?",
            "answer": "Spread (...) expands iterables into individual elements (e.g., [...arr]). Rest collects function arguments or remaining properties into an array/object (e.g., function(...args) or const {a,...rest}=obj). Same syntax, different context.",
            "useCases": [
                "Argument handling",
                "Cloning objects"
            ],
            "realTimeUseCases": [
                "Merging arrays and extracting remaining props in components"
            ]
        },
        {
            "id": 50,
            "name": "Tricky arrays",
            "question": "Tricky Output Questions on Arrays?",
            "answer": "Common tricky outputs involve reference sharing, sparse arrays, mutation during iteration, and pitfalls of comparing arrays. Example: map with index as key in React causing re-rendering issues. Understand shallow copy vs deep copy.",
            "useCases": [
                "Interview prep",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Avoiding mutation bugs when updating nested cart items"
            ]
        },
        {
            "id": 51,
            "name": "Object definition",
            "question": "What is an object in JavaScript?",
            "answer": "An object is a collection of key-value pairs; keys are strings or symbols and values can be any type. Objects provide structure for modeling real-world entities.",
            "useCases": [
                "Data modeling",
                "Configurations"
            ],
            "realTimeUseCases": [
                "Product objects with id, title, price"
            ]
        },
        {
            "id": 52,
            "name": "Create objects",
            "question": "Ways to create objects?",
            "answer": "Object literal {}, Object.create(proto), constructor functions (new), and class syntax (ES6). Use literals for most cases.",
            "useCases": [
                "Factory patterns",
                "Prototypal inheritance"
            ],
            "realTimeUseCases": [
                "Creating product DTOs from API"
            ]
        },
        {
            "id": 53,
            "name": "Important object methods",
            "question": "Important object methods?",
            "answer": "Object.keys, Object.values, Object.entries, Object.assign, Object.create, Object.freeze, Object.seal, hasOwnProperty, and Object.getPrototypeOf.",
            "useCases": [
                "Inspection",
                "Immutability"
            ],
            "realTimeUseCases": [
                "Extracting keys for display columns or freezing config objects"
            ]
        },
        {
            "id": 54,
            "name": "Object Destructuring",
            "question": "What is Object Destructuring?",
            "answer": "Destructuring extracts properties from objects into variables: const {id, name} = product. Supports defaults, renaming, nested patterns.",
            "useCases": [
                "Cleaner syntax",
                "Parameter unpacking"
            ],
            "realTimeUseCases": [
                "Destructuring props in React components"
            ]
        },
        {
            "id": 55,
            "name": "Optional Chaining",
            "question": "What is Optional Chaining?",
            "answer": "Optional chaining (?.) allows safe access to nested properties without throwing if intermediate is null/undefined: obj?.a?.b. Useful to avoid runtime errors on missing nested data.",
            "useCases": [
                "Safe access",
                "Defensive coding"
            ],
            "realTimeUseCases": [
                "Accessing deep API fields that may be absent"
            ]
        },
        {
            "id": 56,
            "name": "Prototypal Inheritance",
            "question": "What is Prototypal Inheritance?",
            "answer": "JavaScript objects can inherit from other objects via prototype chains. Methods defined on prototypes are shared by instances. ES6 classes are syntactic sugar over prototypes.",
            "useCases": [
                "Shared behavior",
                "Memory efficiency"
            ],
            "realTimeUseCases": [
                "Defining shared methods on model prototypes"
            ]
        },
        {
            "id": 57,
            "name": "Prototype",
            "question": "What is a Prototype?",
            "answer": "A prototype is an object from which other objects inherit properties. Every object has an internal [[Prototype]] (accessible via Object.getPrototypeOf or __proto__).",
            "useCases": [
                "Inheritance model",
                "Method sharing"
            ],
            "realTimeUseCases": [
                "Polyfills attaching methods onto prototypes"
            ]
        },
        {
            "id": 58,
            "name": "Tricky objects",
            "question": "Tricky Output Questions on Objects?",
            "answer": "Tricky cases include property ordering, reference equality, mutating shared nested properties, and enum-like behavior with symbols. Also remember that objects are compared by reference, not by value.",
            "useCases": [
                "Interview prep",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Avoid shallow merges that keep shared nested refs leading to bugs"
            ]
        },
        {
            "id": 59,
            "name": "DOM",
            "question": "What is DOM?",
            "answer": "DOM is the Document Object Model â€” a tree representation of HTML documents that browsers expose as a programmable API to read/modify page structure, content, and styles.",
            "useCases": [
                "DOM manipulation",
                "Rendering UI"
            ],
            "realTimeUseCases": [
                "Updating cart totals and injecting product lists"
            ]
        },
        {
            "id": 60,
            "name": "Why DOM",
            "question": "Why do we use DOM?",
            "answer": "DOM allows scripts to interact with the page: query elements, change text or attributes, add event listeners, and create dynamic user interfaces.",
            "useCases": [
                "Interactive pages",
                "Accessibility"
            ],
            "realTimeUseCases": [
                "Dynamically updating product availability without reload"
            ]
        },
        {
            "id": 61,
            "name": "Important DOM methods",
            "question": "Important DOM methods?",
            "answer": "document.querySelector, querySelectorAll, getElementById, createElement, appendChild, removeChild, addEventListener, closest, matches, classList methods.",
            "useCases": [
                "Selecting elements",
                "Event handling"
            ],
            "realTimeUseCases": [
                "Attaching click handlers for add-to-cart buttons"
            ]
        },
        {
            "id": 62,
            "name": "Event Bubbling",
            "question": "What is Event Bubbling?",
            "answer": "Bubbling is when events propagate from the innermost target up through ancestor elements. Use event.stopPropagation() to prevent bubbling.",
            "useCases": [
                "Delegation",
                "Handling events"
            ],
            "realTimeUseCases": [
                "Click events captured at container to handle many children"
            ]
        },
        {
            "id": 63,
            "name": "Event Capturing",
            "question": "What is Event Capturing?",
            "answer": "Capturing is the opposite phase: events move from document root down to the target. You can register listeners in capture phase by passing {capture:true} to addEventListener.",
            "useCases": [
                "Advanced event control"
            ],
            "realTimeUseCases": [
                "Setting up global listeners that intercept events before children"
            ]
        },
        {
            "id": 64,
            "name": "Event Delegation",
            "question": "What is Event Delegation?",
            "answer": "Delegate events to a common ancestor and detect the actual target via event.target to handle many children efficiently and avoid many listeners.",
            "useCases": [
                "Performance",
                "Simpler listener management"
            ],
            "realTimeUseCases": [
                "Single click listener on product list container for add-to-cart buttons"
            ]
        },
        {
            "id": 65,
            "name": "BOM",
            "question": "What is BOM?",
            "answer": "BOM (Browser Object Model) includes browser-provided objects not part of the DOM like window, navigator, location, history, and screen. These give access to browser-level functionality.",
            "useCases": [
                "Browser APIs",
                "Navigation control"
            ],
            "realTimeUseCases": [
                "Reading location.search for query params"
            ]
        },
        {
            "id": 66,
            "name": "Types of BOM Objects",
            "question": "Types of BOM Objects?",
            "answer": "Common objects: window, document (DOM), navigator, location, history, screen, localStorage, sessionStorage, and XMLHttpRequest/ fetch as web APIs.",
            "useCases": [
                "Browser capabilities",
                "State persistence"
            ],
            "realTimeUseCases": [
                "Using history.pushState for SPA navigation"
            ]
        },
        {
            "id": 67,
            "name": "Important BOM methods",
            "question": "Important BOM methods?",
            "answer": "window.alert, confirm, prompt, location.assign, history.pushState, navigator.geolocation, setTimeout/setInterval, and console APIs.",
            "useCases": [
                "Browser interactions",
                "Timers"
            ],
            "realTimeUseCases": [
                "Using setTimeout to debounce UI updates"
            ]
        },
        {
            "id": 68,
            "name": "localStorage",
            "question": "What is localStorage?",
            "answer": "localStorage is a Web Storage API for storing string key-value pairs that persist across sessions for a given origin. Capacity is typically several MBs and data is not sent with requests.",
            "useCases": [
                "Client persistence",
                "Offline data"
            ],
            "realTimeUseCases": [
                "Storing last-viewed product or cart draft (careful with sensitive data)"
            ]
        },
        {
            "id": 69,
            "name": "sessionStorage",
            "question": "What is sessionStorage?",
            "answer": "sessionStorage is like localStorage but data lasts only for the page session (tab). It is cleared when the tab/window is closed.",
            "useCases": [
                "Tab-scoped persistence"
            ],
            "realTimeUseCases": [
                "Temporary form drafts per tab"
            ]
        },
        {
            "id": 70,
            "name": "Cookies",
            "question": "What are cookies?",
            "answer": "Cookies are small name=value pairs sent with HTTP requests (unless flagged HttpOnly) and used for session tracking. They have size limits and can be configured with attributes (Secure, HttpOnly, SameSite, expires).",
            "useCases": [
                "Authentication",
                "Tracking"
            ],
            "realTimeUseCases": [
                "Server-set session cookie after login"
            ]
        },
        {
            "id": 71,
            "name": "Storage comparison",
            "question": "localStorage vs sessionStorage vs cookies vs cache?",
            "answer": "localStorage/sessionStorage: client-side string storage (no automatic server send). Cookies: sent to server, used for auth, limited size. Cache (Cache API): stores responses for offline usage and service workers.",
            "useCases": [
                "Choosing storage"
            ],
            "realTimeUseCases": [
                "Use cookies for server sessions, localStorage for non-sensitive user prefs"
            ]
        },
        {
            "id": 72,
            "name": "Single-threaded?",
            "question": "Is JavaScript single-threaded or multi-threaded?",
            "answer": "JS (in browsers) is mostly single-threaded (main thread). Web Workers provide parallelism for heavy tasks. Event loop and async APIs allow concurrency without multi-threaded shared memory on main thread.",
            "useCases": [
                "Concurrency model",
                "Offloading work"
            ],
            "realTimeUseCases": [
                "Using Web Workers for heavy image processing"
            ]
        },
        {
            "id": 73,
            "name": "Sync vs Async",
            "question": "What is synchronous vs asynchronous JavaScript?",
            "answer": "Synchronous code runs in sequence blocking the thread. Asynchronous code schedules work (callbacks, Promises, async/await, timers) so the main thread can continue and the work runs later (via event loop micro/macrotasks).",
            "useCases": [
                "Responsive UIs",
                "Non-blocking IO"
            ],
            "realTimeUseCases": [
                "Fetching API data without freezing UI"
            ]
        },
        {
            "id": 74,
            "name": "Event Loop",
            "question": "What is the Event Loop?",
            "answer": "The event loop is a runtime mechanism that handles the call stack and task queues (macrotasks and microtasks). It picks tasks to execute so async callbacks and promise reactions run after current stack completes.",
            "useCases": [
                "Async scheduling",
                "Concurrency reasoning"
            ],
            "realTimeUseCases": [
                "Understanding why setTimeout 0 runs after Promise.then"
            ]
        },
        {
            "id": 75,
            "name": "Call Stack",
            "question": "What is the Call Stack?",
            "answer": "Call stack is the LIFO stack of function frames currently executing. Synchronous function calls push frames, returns pop them. Long-running sync tasks block the stack and the event loop.",
            "useCases": [
                "Debugging",
                "Stack traces"
            ],
            "realTimeUseCases": [
                "Avoid blocking operations in UI thread"
            ]
        },
        {
            "id": 76,
            "name": "Microtasks",
            "question": "What are Microtasks?",
            "answer": "Microtasks (Promise callbacks, mutation observer callbacks) run after the current stack but before the next macrotask. They are used for promise resolution (queueMicrotask, Promise.then).",
            "useCases": [
                "Promise scheduling",
                "Ordering guarantees"
            ],
            "realTimeUseCases": [
                "Promise.then executes before setTimeout callbacks"
            ]
        },
        {
            "id": 77,
            "name": "Macrotasks",
            "question": "What are Macrotasks?",
            "answer": "Macrotasks include setTimeout, setInterval, I/O, and UI rendering tasks. The event loop processes one macrotask, then microtasks, then rendering, then next macrotask.",
            "useCases": [
                "Task scheduling",
                "UI updates"
            ],
            "realTimeUseCases": [
                "setTimeout used for deferred UI updates"
            ]
        },
        {
            "id": 78,
            "name": "Promise",
            "question": "What is Promise?",
            "answer": "A Promise is an object representing eventual completion/failure of an async operation. It has states: pending, fulfilled, rejected. Use then/catch/finally or async/await for handling.",
            "useCases": [
                "Async control flow",
                "Error handling"
            ],
            "realTimeUseCases": [
                "Fetching product data with axios returning a Promise"
            ]
        },
        {
            "id": 79,
            "name": "Promise Chaining",
            "question": "What is Promise Chaining?",
            "answer": "Promise chaining links multiple then handlers to perform sequential async operations where each step returns a Promise. Return values pass to next then; errors propagate to catch.",
            "useCases": [
                "Sequential async flows"
            ],
            "realTimeUseCases": [
                "Fetch product -> fetch inventory -> update UI"
            ]
        },
        {
            "id": 80,
            "name": "async await",
            "question": "What is async/await?",
            "answer": "async/await syntax lets you write asynchronous code that looks synchronous. `async` marks a function that returns a Promise; `await` pauses until a Promise resolves (inside async), simplifying control flow and error handling with try/catch.",
            "useCases": [
                "Cleaner async code",
                "Sequential async operations"
            ],
            "realTimeUseCases": [
                "Simpler API calls in service functions"
            ]
        },
        {
            "id": 81,
            "name": "Callback Hell",
            "question": "What is Callback Hell?",
            "answer": "Callback hell refers to deeply nested callbacks that are hard to read and maintain. Promises and async/await mitigate this by flattening async control flow.",
            "useCases": [
                "Refactoring legacy async code"
            ],
            "realTimeUseCases": [
                "Refactor nested XHR callbacks to async/await"
            ]
        },
        {
            "id": 82,
            "name": "setTimeout",
            "question": "What is setTimeout()?",
            "answer": "setTimeout schedules a function to run after a given delay (ms) and is a macrotask. It returns a timeout id which can be cleared with clearTimeout.",
            "useCases": [
                "Delays",
                "Debouncing"
            ],
            "realTimeUseCases": [
                "Delay showing a tooltip or retrying an API call"
            ]
        },
        {
            "id": 83,
            "name": "setInterval",
            "question": "What is setInterval()?",
            "answer": "setInterval repeatedly runs a function at specified intervals. Use clearInterval to stop it. Be cautious to avoid overlapping executions and memory leaks.",
            "useCases": [
                "Periodic tasks"
            ],
            "realTimeUseCases": [
                "Polling inventory updates (prefer webhooks or SSE if possible)"
            ]
        },
        {
            "id": 84,
            "name": "Debouncing",
            "question": "What is Debouncing?",
            "answer": "Debouncing groups rapid calls into a single one after a pause: only the last call executes after delay. Useful for input events (search) to reduce frequency of expensive ops.",
            "useCases": [
                "Rate-limiting events",
                "Performance"
            ],
            "realTimeUseCases": [
                "Debounce search input to reduce API calls"
            ]
        },
        {
            "id": 85,
            "name": "Throttling",
            "question": "What is Throttling?",
            "answer": "Throttling ensures a function runs at most once in a specified time window. Useful for scroll/resize handlers to limit execution rate.",
            "useCases": [
                "Rate control",
                "Optimizing handlers"
            ],
            "realTimeUseCases": [
                "Throttle scroll handlers to update visible items"
            ]
        },
        {
            "id": 86,
            "name": "Debounce vs Throttle",
            "question": "Difference between Debouncing vs Throttling?",
            "answer": "Debounce waits until events stop for a delay; throttle enforces a max call rate. Debounce suits finalizing input; throttle suits periodic updates during continuous events.",
            "useCases": [
                "Choose rate control"
            ],
            "realTimeUseCases": [
                "Debounce search, throttle scroll"
            ]
        },
        {
            "id": 87,
            "name": "Memory Leaks",
            "question": "What are Memory Leaks?",
            "answer": "Memory leaks occur when references to unused objects persist, preventing GC from reclaiming memory. Common causes: event listeners not removed, closures holding large structures, forgotten timers, global caches.",
            "useCases": [
                "Stability",
                "Performance"
            ],
            "realTimeUseCases": [
                "Remove event listeners in component cleanup to prevent leaks"
            ]
        },
        {
            "id": 88,
            "name": "Detect fix leaks",
            "question": "How to detect and fix Memory Leaks?",
            "answer": "Use browser DevTools memory snapshots/heap profiler, look for retained nodes, remove unused listeners, clear timers, null out large references, and avoid global caches. Use Lighthouse and long-running monitoring.",
            "useCases": [
                "Diagnostics",
                "Maintenance"
            ],
            "realTimeUseCases": [
                "Profiling a page with increasing memory over time"
            ]
        },
        {
            "id": 89,
            "name": "Garbage Collection",
            "question": "What is Garbage Collection?",
            "answer": "GC automatically reclaims memory for unreachable objects. Modern engines use mark-and-sweep algorithms to find reachable objects from roots and free the rest.",
            "useCases": [
                "Memory management"
            ],
            "realTimeUseCases": [
                "Rely on GC but avoid retaining references unnecessarily"
            ]
        },
        {
            "id": 90,
            "name": "Event Loop Starvation",
            "question": "What is Event Loop Starvation?",
            "answer": "Starvation happens when long-running synchronous tasks block the event loop, preventing async callbacks and rendering from running, causing UI freezes. Break work into smaller chunks or use workers.",
            "useCases": [
                "Responsiveness",
                "Task partitioning"
            ],
            "realTimeUseCases": [
                "Offload heavy processing to Web Workers"
            ]
        },
        {
            "id": 91,
            "name": "XSS",
            "question": "What is XSS (Cross-Site Scripting)?",
            "answer": "XSS occurs when attackers inject malicious scripts into pages that execute in other users' browsers. Prevent it by sanitizing user input, escaping output, using CSP, and HttpOnly cookies.",
            "useCases": [
                "Security",
                "Input validation"
            ],
            "realTimeUseCases": [
                "Escape user-generated reviews before inserting into DOM"
            ]
        },
        {
            "id": 92,
            "name": "CSRF",
            "question": "What is CSRF (Cross-Site Request Forgery)?",
            "answer": "CSRF tricks authenticated users into making unwanted requests. Mitigate with anti-CSRF tokens, SameSite cookies, and verifying origin/referer headers.",
            "useCases": [
                "Request validation",
                "Auth security"
            ],
            "realTimeUseCases": [
                "Include CSRF tokens in state-changing form submissions"
            ]
        },
        {
            "id": 93,
            "name": "XSS vs CSRF",
            "question": "XSS vs CSRF differences?",
            "answer": "XSS injects scripts into pages to run in victim's browser; CSRF forges legitimate requests from the victim to the server. XSS compromises client-side code; CSRF abuses authenticated sessions.",
            "useCases": [
                "Threat modeling"
            ],
            "realTimeUseCases": [
                "Use CSP and CSRF tokens together for layered defense"
            ]
        },
        {
            "id": 94,
            "name": "CORS",
            "question": "What is CORS?",
            "answer": "Cross-Origin Resource Sharing is a browser mechanism that restricts cross-origin requests unless the server sends appropriate Access-Control-Allow-* headers. Configure server to allow authorized origins or use proxies.",
            "useCases": [
                "API security",
                "Cross-origin requests"
            ],
            "realTimeUseCases": [
                "Enable CORS for API domain from frontend origin in staging"
            ]
        },
        {
            "id": 95,
            "name": "Content Security Policy",
            "question": "What is Content Security Policy?",
            "answer": "CSP is an HTTP header that restricts sources for scripts, styles, and other resources to mitigate XSS by whitelisting trusted origins and disallowing inline scripts.",
            "useCases": [
                "Security hardening"
            ],
            "realTimeUseCases": [
                "Set CSP to only allow scripts from self and trusted CDNs"
            ]
        },
        {
            "id": 96,
            "name": "Service Worker",
            "question": "What is a Service Worker?",
            "answer": "A service worker is a script that runs in the background, separate from web pages, enabling offline caching, background sync, and push notifications. It intercepts network requests via the Cache API.",
            "useCases": [
                "Offline support",
                "Background sync"
            ],
            "realTimeUseCases": [
                "Cache assets for PWA offline product browsing"
            ]
        },
        {
            "id": 97,
            "name": "Service Worker lifecycle",
            "question": "Service Worker Life Cycle?",
            "answer": "Phases: registration -> installation (install event) -> activation (activate event) -> fetch events. Update flow includes skipWaiting and clients.claim to control activation timing.",
            "useCases": [
                "PWA life cycle management"
            ],
            "realTimeUseCases": [
                "Updating cached assets gracefully on new deploys"
            ]
        },
        {
            "id": 98,
            "name": "Caching strategies",
            "question": "What are caching strategies?",
            "answer": "Common strategies: Cache First, Network First, Stale-While-Revalidate, Cache Only, Network Only. Choose based on freshness and availability needs.",
            "useCases": [
                "Offline UX",
                "Performance"
            ],
            "realTimeUseCases": [
                "Cache-first for static assets, network-first for dynamic API data with fallback"
            ]
        },
        {
            "id": 99,
            "name": "PWA",
            "question": "What is PWA?",
            "answer": "Progressive Web App is a web application that uses modern APIs (service workers, manifest) to provide app-like experience â€” installable, offline-capable, and responsive.",
            "useCases": [
                "Mobile-like experiences",
                "Offline"
            ],
            "realTimeUseCases": [
                "Make product catalog available offline with service worker caching"
            ]
        },
        {
            "id": 100,
            "name": "Offline caching",
            "question": "How does offline caching work?",
            "answer": "Service workers intercept fetch events and serve responses from Cache API when offline; use caching strategies and versioning to update caches.",
            "useCases": [
                "Offline mode",
                "Fast loads"
            ],
            "realTimeUseCases": [
                "Show cached product pages when network unavailable"
            ]
        },
        {
            "id": 101,
            "name": "Closures",
            "question": "What are Closures?",
            "answer": "A closure is a function that captures variables from its lexical scope, allowing the function to access those variables even after the outer function has returned.",
            "useCases": [
                "Encapsulation",
                "Private state"
            ],
            "realTimeUseCases": [
                "createCounter() that returns increment function with private count variable"
            ]
        },
        {
            "id": 102,
            "name": "Closures use cases",
            "question": "Real-time use cases of Closures?",
            "answer": "Use cases: factory functions, memoization, event callbacks that remember context, managing private per-instance state in functional patterns.",
            "useCases": [
                "State encapsulation"
            ],
            "realTimeUseCases": [
                "Per-component memoized handlers retaining props"
            ]
        },
        {
            "id": 103,
            "name": "Module Pattern",
            "question": "What is Module Pattern?",
            "answer": "Module pattern organizes code into self-contained units (IIFE or ES modules) exposing public API while keeping private internals. ES Modules are modern replacement for older patterns.",
            "useCases": [
                "Encapsulation",
                "Dependency management"
            ],
            "realTimeUseCases": [
                "Component utility modules exported as named functions"
            ]
        },
        {
            "id": 104,
            "name": "WeakMap WeakSet",
            "question": "What is WeakMap & WeakSet?",
            "answer": "WeakMap/WeakSet hold weak references to keys (objects) allowing GC if no other refs exist. Keys must be objects; useful for associating metadata without preventing GC.",
            "useCases": [
                "Memory-sensitive caching"
            ],
            "realTimeUseCases": [
                "Storing metadata for DOM nodes without preventing their collection"
            ]
        },
        {
            "id": 105,
            "name": "Symbol",
            "question": "What is Symbol?",
            "answer": "Symbol is a primitive for unique identifiers, often used as non-enumerable object property keys or to define custom behavior (well-known symbols).",
            "useCases": [
                "Unique keys",
                "Meta-props"
            ],
            "realTimeUseCases": [
                "Using Symbol.toStringTag for custom object tagging"
            ]
        },
        {
            "id": 106,
            "name": "Microtask Queue",
            "question": "What is Event Loop Microtask Queue?",
            "answer": "Microtask queue holds microtasks (Promise jobs, queueMicrotask) executed after current task and before the next macrotask and rendering; ensures promise continuations run quickly.",
            "useCases": [
                "Task ordering",
                "Promise behavior"
            ],
            "realTimeUseCases": [
                "Ensuring .then handlers run before setTimeout callbacks"
            ]
        },
        {
            "id": 107,
            "name": "Shadow DOM",
            "question": "What is Shadow DOM?",
            "answer": "Shadow DOM provides encapsulated DOM and styles for web components, preventing style leakage and enabling component-level scoping.",
            "useCases": [
                "Component encapsulation"
            ],
            "realTimeUseCases": [
                "Custom UI elements with isolated styles"
            ]
        },
        {
            "id": 108,
            "name": "Virtual DOM",
            "question": "What is Virtual DOM?",
            "answer": "Virtual DOM is an in-memory representation of UI used by frameworks (React) to compute diffs and apply minimal updates to real DOM for performance.",
            "useCases": [
                "Efficient updates",
                "Framework internals"
            ],
            "realTimeUseCases": [
                "React using Virtual DOM to batch updates"
            ]
        },
        {
            "id": 109,
            "name": "Execution Context",
            "question": "What is Execution Context?",
            "answer": "Execution context is the environment in which JavaScript code is evaluated (variable object, scope chain, this). Global, function, and eval contexts exist. Each function call creates a new execution context.",
            "useCases": [
                "Runtime understanding"
            ],
            "realTimeUseCases": [
                "Understanding variable lifetimes and closures"
            ]
        },
        {
            "id": 110,
            "name": "Lexical Environment",
            "question": "What is Lexical Environment?",
            "answer": "Lexical environment is a structure that holds identifier-variable mapping and a reference to outer environment; it models scope and is used to resolve variable lookups.",
            "useCases": [
                "Scope model",
                "Closures"
            ],
            "realTimeUseCases": [
                "Debugging variable resolution issues"
            ]
        },
        {
            "id": 111,
            "name": "Func decl vs expr",
            "question": "What is the difference between function declaration vs function expression?",
            "answer": "Function declarations (function f(){}) are hoisted with their definitions; function expressions (const f = function(){}) are not hoisted and behave like variables (TDZ for let/const). Choose declaration for named, hoisted functions.",
            "useCases": [
                "Hoisting behavior",
                "API design"
            ],
            "realTimeUseCases": [
                "Use declarations for utility functions used before definition"
            ]
        },
        {
            "id": 112,
            "name": "Generators",
            "question": "What are Generators?",
            "answer": "Generators (function*) produce iterators and can pause execution with yield. Useful for lazy sequences and advanced async patterns (co), though async/await is usually preferred.",
            "useCases": [
                "Iterators",
                "Lazy evaluation"
            ],
            "realTimeUseCases": [
                "Custom paginated data iterator"
            ]
        },
        {
            "id": 113,
            "name": "Observables",
            "question": "What are Observables?",
            "answer": "Observables (RxJS) represent streams of values over time and provide rich operators for composition. They are not native to JS but widely used in reactive programming.",
            "useCases": [
                "Reactive streams",
                "Event composition"
            ],
            "realTimeUseCases": [
                "Streaming search suggestions and debounced inputs"
            ]
        },
        {
            "id": 114,
            "name": "Memoization",
            "question": "What is Memoization?",
            "answer": "Memoization caches function results for given inputs to avoid recomputation. Implement via closures or libraries. Useful for expensive pure functions.",
            "useCases": [
                "Performance",
                "Caching"
            ],
            "realTimeUseCases": [
                "Memoize derived product lists or price calculations"
            ]
        },
        {
            "id": 115,
            "name": "Tricky hoisting outputs",
            "question": "Tricky Output-Based Questions: hoisting",
            "answer": "Output questions on hoisting often show var hoisting (undefined vs ReferenceError for let/const) and function declaration hoisting. Understand initialization vs declaration to reason about outputs.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Explain console logs under hoisting scenarios"
            ]
        },
        {
            "id": 116,
            "name": "Tricky this outputs",
            "question": "Tricky Output-Based Questions: this",
            "answer": "This tricky outputs include method calls vs detached function calls, arrow functions capturing lexical this, and bind/call/apply effects. Use call site to reason about this value.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Explain output when extracting methods as callbacks"
            ]
        },
        {
            "id": 117,
            "name": "Tricky closures outputs",
            "question": "Tricky Output-Based Questions: closures",
            "answer": "Closures tricky outputs often involve loop variables captured by closures; use let to fix or create IIFE to capture current value. Understand captured references vs values.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Loop callback capture issues with var"
            ]
        },
        {
            "id": 118,
            "name": "Tricky promises outputs",
            "question": "Tricky Output-Based Questions: promises",
            "answer": "Promised-based outputs often test microtask ordering: Promise.then runs before setTimeout. Also test error propagation and returned promises inside then handlers.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Order of async logs with promises and timers"
            ]
        },
        {
            "id": 119,
            "name": "Tricky async await outputs",
            "question": "Tricky Output-Based Questions: async/await",
            "answer": "Async/await outputs test error handling with try/catch, awaiting non-promise values, and how async functions always return promises.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Explain behavior of awaited non-Promise values"
            ]
        },
        {
            "id": 120,
            "name": "Tricky arrays objects outputs",
            "question": "Tricky Output-Based Questions: arrays & objects",
            "answer": "Tricky outputs include reference sharing, mutation, and equality by reference. Also prototype property shadowing and enumeration order edge cases.",
            "useCases": [
                "Interview prep"
            ],
            "realTimeUseCases": [
                "Avoiding mutation-related bugs in state updates"
            ]
        }
    ],
    "ES6-Features": [
        {
            "id": 1,
            "name": "What is the difference between var let and const in JavaScript",
            "question": "What is the difference between var, let, and const in JavaScript?",
            "answer": "var is function-scoped and hoisted with undefined; let is block-scoped and not hoisted (TDZ); const is block-scoped, not hoisted (TDZ), and cannot be reassigned.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 2,
            "name": "What are the drawbacks of using var",
            "question": "What are the drawbacks of using var?",
            "answer": "Drawbacks: function scope (confusing), hoisting issues, can be redeclared in same scope, pollutes global namespace, and causes unexpected behaviors.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 3,
            "name": "What is block scope and how does letconst provide it",
            "question": "What is block scope and how does let/const provide it?",
            "answer": "Block scope limits variable accessibility to a block ({}). let and const create block-scoped bindings inside if, for, while, functions, etc., preventing access outside the block.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 4,
            "name": "What is Temporal Dead Zone TDZ in JavaScript",
            "question": "What is Temporal Dead Zone (TDZ) in JavaScript?",
            "answer": "TDZ is the time between entering a scope and when let/const binding is initialized. Accessing the variable throws ReferenceError during TDZ.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 5,
            "name": "Why is letconst not hoisted like var",
            "question": "Why is let/const not hoisted like var?",
            "answer": "let/const are hoisted but not initialized (TDZ state), preventing access before declaration. This enforces safer patterns than var's hoisting-to-undefined behavior.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 6,
            "name": "What happens when we redeclare variables using var vs letcon",
            "question": "What happens when we redeclare variables using var vs let/const?",
            "answer": "var allows redeclaration in same scope; let/const throw SyntaxError if redeclared in the same block scope, preventing accidental overwrites.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 7,
            "name": "What is hoisting in JavaScript",
            "question": "What is hoisting in JavaScript?",
            "answer": "Hoisting moves declarations to the top of their scope. var and function declarations are hoisted; function expressions and let/const are not initialized until declaration line.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 8,
            "name": "How variables and functions behave during hoisting",
            "question": "How variables and functions behave during hoisting?",
            "answer": "Function declarations are fully hoisted with body; var declarations are hoisted and initialized as undefined; let/const are hoisted but uninitialized (TDZ).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 9,
            "name": "Why letconst variables cannot be accessed before initializat",
            "question": "Why let/const variables cannot be accessed before initialization?",
            "answer": "let/const remain in TDZ from scope entry until the declaration line, preventing accidental use of undefined values like var allows.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 10,
            "name": "What are arrow functions in ES6",
            "question": "What are arrow functions in ES6?",
            "answer": "Arrow functions use => syntax, have lexical this (no own this), no arguments object, cannot be constructors, and provide concise function syntax.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 11,
            "name": "Differences between arrow functions and normal functions",
            "question": "Differences between arrow functions and normal functions?",
            "answer": "Arrow: lexical this, no arguments, not hoisted, cannot use new; Normal: dynamic this, has arguments, function declarations hoisted, usable as constructors.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 12,
            "name": "Why arrow functions do not have their own this",
            "question": "Why arrow functions do not have their own this?",
            "answer": "Arrow functions inherit this from surrounding lexical scope (parent function/object) rather than getting dynamic this from call site.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 13,
            "name": "When should we not use arrow functions",
            "question": "When should we not use arrow functions?",
            "answer": "Avoid arrow functions for: constructors, methods needing dynamic this, callbacks with arguments object, or functions that should be hoisted.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 14,
            "name": "What are template literals in ES6",
            "question": "What are template literals in ES6?",
            "answer": "Template literals use backticks (`) for multi-line strings and ${expression} interpolation, replacing string concatenation for better readability.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 15,
            "name": "What is string interpolation",
            "question": "What is string interpolation?",
            "answer": "String interpolation embeds expressions inside template literals using ${} syntax; expressions are evaluated and converted to strings automatically.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 16,
            "name": "What are tagged template literals",
            "question": "What are tagged template literals?",
            "answer": "Tagged templates call a function with template literal parts and substitutions: function`template${expr}` allows custom processing of template strings.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 17,
            "name": "What are default parameters in JavaScript",
            "question": "What are default parameters in JavaScript?",
            "answer": "Default parameters provide fallback values for function arguments if not supplied: function(a=10) {}. Works with destructuring and expressions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 18,
            "name": "How default parameters work with destructuring",
            "question": "How default parameters work with destructuring?",
            "answer": "Default parameters work with destructured parameters: function({a=5, b=10}={}) {}. Inner defaults apply to missing destructured properties.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 19,
            "name": "What is array destructuring",
            "question": "What is array destructuring?",
            "answer": "Array destructuring extracts array elements into variables: const [a, b, c] = arr; supports skipping, rest operator, and defaults.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 20,
            "name": "What is object destructuring",
            "question": "What is object destructuring?",
            "answer": "Object destructuring extracts object properties into variables: const {name, age} = obj; supports renaming, defaults, nested patterns, and rest.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 21,
            "name": "What is nested destructuring",
            "question": "What is nested destructuring?",
            "answer": "Nested destructuring extracts values from nested structures: const {user: {name, address: {city}}} = data; works for mixed arrays/objects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 22,
            "name": "What is rest destructuring",
            "question": "What is rest destructuring?",
            "answer": "Rest destructuring collects remaining elements: const [a, ...rest] = arr; or const {x, ...props} = obj. Useful for extracting unwanted props.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 23,
            "name": "What is the rest operator  in JavaScript",
            "question": "What is the rest operator (...) in JavaScript?",
            "answer": "Rest operator collects multiple elements into an array (in parameters) or properties into an object (in destructuring): function(...args), [a, ...rest].",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 24,
            "name": "What is the spread operator  in JavaScript",
            "question": "What is the spread operator (...) in JavaScript?",
            "answer": "Spread operator expands iterables/objects into individual elements: [...arr], {...obj}, func(...args). Used for cloning, merging, and passing arguments.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 25,
            "name": "Difference between rest and spread operators",
            "question": "Difference between rest and spread operators?",
            "answer": "Rest collects multiple values into a single variable (parameters, destructuring). Spread expands a single iterable into multiple values (function calls, arrays, objects).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 26,
            "name": "How to merge arrays using spread operator",
            "question": "How to merge arrays using spread operator?",
            "answer": "Merge arrays: const merged = [...arr1, ...arr2]; or concat. Spread creates a new array without mutating originals.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 27,
            "name": "How to clone objects using spread operator",
            "question": "How to clone objects using spread operator?",
            "answer": "Clone objects: const copy = {...original}; creates shallow copy. For deep copy use JSON methods or libraries like lodash.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 28,
            "name": "What are ES6 modules",
            "question": "What are ES6 modules?",
            "answer": "ES6 modules are reusable code blocks with their own scope using import/export. Each module is isolated and explicitly declares dependencies.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 29,
            "name": "What is named export vs default export",
            "question": "What is named export vs default export?",
            "answer": "Named export: export const fn = (){} imported via import {fn}; Default export: export default fn; imported via import fn;. A module has one default, many named.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 30,
            "name": "What is reexporting in ES6",
            "question": "What is re-exporting in ES6?",
            "answer": "re-exporting makes imported items available for other modules: export {x, y} from \"./module\"; or export {default} from \"./module\";",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 31,
            "name": "What are dynamic imports",
            "question": "What are dynamic imports?",
            "answer": "Dynamic imports load modules at runtime: import(\"./module\").then(m => {}); or with await. Useful for code splitting and conditional loading.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 32,
            "name": "What is a closure in JavaScript",
            "question": "What is a closure in JavaScript?",
            "answer": "A closure is a function that remembers variables from its lexical scope after the outer function returns, enabling private state and encapsulation.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 33,
            "name": "How closures work internally",
            "question": "How closures work internally?",
            "answer": "Closures work via scope chain and lexical environment: when a function is created, it retains references to outer variables. Scopes form a chain for variable lookup.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 34,
            "name": "What are the use cases of closures",
            "question": "What are the use cases of closures?",
            "answer": "Use cases: data privacy, factory functions, event handlers retaining context, memoization, partial application, and module patterns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 35,
            "name": "What are closurerelated memory leaks",
            "question": "What are closure-related memory leaks?",
            "answer": "Closures unintentionally retain large outer objects preventing GC. Fix by nullifying references, using WeakMap, or restructuring to avoid capturing unnecessary objects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 36,
            "name": "What is a callback function",
            "question": "What is a callback function?",
            "answer": "A callback is a function passed to another function to be called later (synchronously or asynchronously). Common in event handlers and async patterns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 37,
            "name": "What are the problems with callbacks",
            "question": "What are the problems with callbacks?",
            "answer": "Problems: callback hell (nesting), error handling complexity, difficult debugging, and hard-to-follow control flow.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 38,
            "name": "What is callback hell",
            "question": "What is callback hell?",
            "answer": "Callback hell is deeply nested callbacks making code hard to read: func(arg, (err, result) => { func2(result, (err, result2) => { ... }); });",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 39,
            "name": "How to avoid callback hell",
            "question": "How to avoid callback hell?",
            "answer": "Avoid callback hell by: using Promises, async/await, breaking callbacks into named functions, or using utility libraries.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 40,
            "name": "What is a Promise in JavaScript",
            "question": "What is a Promise in JavaScript?",
            "answer": "A Promise represents eventual completion/failure of async operation. States: pending, fulfilled, rejected. Use then/catch/finally for handling outcomes.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 41,
            "name": "What are the states of a Promise",
            "question": "What are the states of a Promise?",
            "answer": "Pending: initial state. Fulfilled: resolved with value. Rejected: failed with reason. Once settled (fulfilled/rejected), state is immutable.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 42,
            "name": "What is Promise chaining",
            "question": "What is Promise chaining?",
            "answer": "Promise chaining links then() calls to perform sequential async operations where return values pass to next then(); errors propagate to catch().",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 43,
            "name": "What is Promiseall",
            "question": "What is Promise.all()?",
            "answer": "Promise.all() takes array of promises, returns promise resolving when all settle. Rejects if any promise rejects; resolves with array of all results.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 44,
            "name": "What is PromiseallSettled",
            "question": "What is Promise.allSettled()?",
            "answer": "Promise.allSettled() waits for all promises to settle (resolve or reject) and returns array of {status, value/reason} objects. Never rejects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 45,
            "name": "What is Promiserace",
            "question": "What is Promise.race()?",
            "answer": "Promise.race() returns promise that settles with first promise to settle (resolve or reject). Useful for timeout patterns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 46,
            "name": "What is Promiseany",
            "question": "What is Promise.any()?",
            "answer": "Promise.any() returns promise fulfilled by first fulfilled promise. Rejects only if all promises reject (with AggregateError of reasons).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 47,
            "name": "What is Promiseresolve",
            "question": "What is Promise.resolve()?",
            "answer": "Promise.resolve(value) returns a promise resolved with the value. If value is promise, returns it; otherwise wraps value in resolved promise.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 48,
            "name": "What is Promisereject",
            "question": "What is Promise.reject()?",
            "answer": "Promise.reject(reason) returns a promise rejected with the reason. Used to create pre-rejected promises for error handling.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 49,
            "name": "Why Promises solve callback hell problems",
            "question": "Why Promises solve callback hell problems?",
            "answer": "Promises flatten nested callbacks via chaining and async/await, enabling better error handling (single catch), cleaner syntax, and improved readability.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 50,
            "name": "What are the disadvantages of Promises",
            "question": "What are the disadvantages of Promises?",
            "answer": "Disadvantages: unhandled rejections can silently fail, promise overhead, still nested with multiple chains, and chaining syntax less readable than async/await.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 51,
            "name": "What is asyncawait in JavaScript",
            "question": "What is async/await in JavaScript?",
            "answer": "async/await is syntactic sugar over Promises. async marks function returning Promise; await pauses execution until Promise resolves, enabling synchronous-looking async code.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 52,
            "name": "How asyncawait works internally",
            "question": "How async/await works internally?",
            "answer": "async/await transpiles to Promise chains. await is replaced with .then() internally, and async function returns a Promise. Error handling uses try/catch.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 53,
            "name": "What problems of callbacks and promises does asyncawait solv",
            "question": "What problems of callbacks and promises does async/await solve?",
            "answer": "async/await provides synchronous-looking code, better error handling via try/catch, improved readability, and eliminates callback nesting and promise chaining complexity.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 54,
            "name": "What happens when we forget await",
            "question": "What happens when we forget await?",
            "answer": "Forgetting await executes the promise without waiting; function returns immediately and continues, likely causing logic errors or undefined behavior downstream.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 55,
            "name": "What is trycatch error handling in asyncawait",
            "question": "What is try/catch error handling in async/await?",
            "answer": "try/catch wraps async/await code to handle rejections: try { await promise } catch(err) { }. Catches both thrown errors and promise rejections.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 56,
            "name": "What is the event loop in JavaScript",
            "question": "What is the event loop in JavaScript?",
            "answer": "Event loop is runtime mechanism coordinating call stack and task queues (macrotasks, microtasks). Executes stack, microtasks, renders UI, then next macrotask.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 57,
            "name": "What is the call stack",
            "question": "What is the call stack?",
            "answer": "Call stack is LIFO structure holding function execution frames. Synchronous code pushes/pops frames. Blocking operations block the stack and event loop.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 58,
            "name": "What is the microtask queue vs macrotask queue",
            "question": "What is the microtask queue vs macrotask queue?",
            "answer": "Microtask queue: Promise callbacks, queueMicrotask (runs after current stack, before rendering). Macrotask queue: setTimeout, I/O, rendering (one per event loop iteration).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 59,
            "name": "How promises are executed in the event loop",
            "question": "How promises are executed in the event loop?",
            "answer": "Promise.then callbacks are microtasks executed after current call stack but before next macrotask and rendering, ensuring fast promise resolution handling.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 60,
            "name": "Difference between nextTick microtasks and macrotasks",
            "question": "Difference between nextTick, microtasks, and macrotasks?",
            "answer": "nextTick (Node.js) runs before microtasks. Microtasks (promises) run before rendering. Macrotasks (setTimeout) run after rendering with longer delays.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 61,
            "name": "What is debouncing in JavaScript",
            "question": "What is debouncing in JavaScript?",
            "answer": "Debouncing groups rapid function calls into a single execution after inactivity period. Waits for events to stop before firing once.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 62,
            "name": "What is throttling in JavaScript",
            "question": "What is throttling in JavaScript?",
            "answer": "Throttling limits function execution frequency to at most once per time interval, ensuring regular execution during continuous events.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 63,
            "name": "What are realtime use cases of debouncing",
            "question": "What are real-time use cases of debouncing?",
            "answer": "Debouncing use cases: search input (wait for user to stop typing), form field validation, window resize handlers, autocomplete suggestions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 64,
            "name": "What are realtime use cases of throttling",
            "question": "What are real-time use cases of throttling?",
            "answer": "Throttling use cases: scroll event handlers, mouse move tracking, infinite scroll, API polling, and performance-sensitive event handlers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 65,
            "name": "What are generators in JavaScript",
            "question": "What are generators in JavaScript?",
            "answer": "Generators are functions that yield multiple values and can pause/resume execution. Use function* syntax and yield keyword. Return iterator objects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 66,
            "name": "What is the syntax of generator functions",
            "question": "What is the syntax of generator functions?",
            "answer": "Generator syntax: function* genName() { yield value1; yield value2; }. Call returns iterator; call next() to advance and get {value, done}.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 67,
            "name": "What is the purpose of yield keyword",
            "question": "What is the purpose of yield keyword?",
            "answer": "yield pauses generator execution and returns value; next() resumes execution from yield point. Enables lazy evaluation and iterator patterns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 68,
            "name": "What is the difference between yield and return",
            "question": "What is the difference between yield and return?",
            "answer": "yield pauses and resumes execution (next() calls); return ends generator. yield allows multiple values; return provides final value and sets done:true.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 69,
            "name": "How generators were used before asyncawait co library",
            "question": "How generators were used before async/await (co library)?",
            "answer": "co library automated generator-based async patterns by wrapping yields in promises and auto-calling next(). Provided async/await-like syntax before ES2017.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 70,
            "name": "What are observables in JavaScript",
            "question": "What are observables in JavaScript?",
            "answer": "Observables (RxJS) represent streams of async values over time. Support subscription pattern, operators for composition, and rich functional pipelines.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 71,
            "name": "What is the difference between observables and promises",
            "question": "What is the difference between observables and promises?",
            "answer": "Observables: multiple values, cancelable, lazy, compositional operators. Promises: single value, cannot cancel, eager, simpler chaining.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 72,
            "name": "What are subscriptions in observables",
            "question": "What are subscriptions in observables?",
            "answer": "Subscriptions connect observer to observable; multiple subscribers create separate streams. Call unsubscribe() to stop listening and free resources.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 73,
            "name": "What are operators like map filter take",
            "question": "What are operators like map, filter, take?",
            "answer": "Operators transform observable streams: map changes values, filter selects by condition, take limits number of emissions. Chainable and lazy.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 74,
            "name": "What are memory leaks due to not unsubscribing",
            "question": "What are memory leaks due to not unsubscribing?",
            "answer": "Not unsubscribing retains references to observer/subscription preventing GC. Causes memory growth in long-running apps; always unsubscribe in cleanup.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 75,
            "name": "What is scope in JavaScript",
            "question": "What is scope in JavaScript?",
            "answer": "Scope is the region where a variable is accessible. JavaScript has global, function, block, and module scopes. Scopes form a chain for variable lookup.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 76,
            "name": "What are the types of scopes",
            "question": "What are the types of scopes?",
            "answer": "Global scope: accessible everywhere. Function scope: var and functions create. Block scope: let/const create inside {}. Module scope: ES modules have.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 77,
            "name": "What is lexical scope",
            "question": "What is lexical scope?",
            "answer": "Lexical scope means a function's scope is determined by its definition location in code, not call location. Inner functions access outer scope variables.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 78,
            "name": "What is block scope",
            "question": "What is block scope?",
            "answer": "Block scope limits variable visibility to a block ({}). let/const create block scope in if, for, while, functions. var does not create block scope.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 79,
            "name": "What is scope chaining in JavaScript",
            "question": "What is scope chaining in JavaScript?",
            "answer": "Scope chaining is the process of looking up variables: start in current scope, then outer scopes, up to global. Forms chain for identifier resolution.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 80,
            "name": "How does the scope chain work internally",
            "question": "How does the scope chain work internally?",
            "answer": "Each function has reference to outer lexical environment. Variable lookup traverses the chain of lexical environments until variable found or reaches global.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 81,
            "name": "Difference between scope chain and call stack",
            "question": "Difference between scope chain and call stack?",
            "answer": "Scope chain determines variable accessibility (lexical). Call stack tracks function execution order (runtime). Different concepts for different purposes.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 82,
            "name": "What is a prototype in JavaScript",
            "question": "What is a prototype in JavaScript?",
            "answer": "A prototype is an object from which other objects inherit properties. Every object has [[Prototype]] (accessible via __proto__); functions have prototype property.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 83,
            "name": "What is the prototype chain",
            "question": "What is the prototype chain?",
            "answer": "Prototype chain is the link of [[Prototype]] references: when property not found, lookup continues in prototype. Chain ends at Object.prototype.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 84,
            "name": "What is proto",
            "question": "What is proto?",
            "answer": "__proto__ is accessor for [[Prototype]]; Object.getPrototypeOf() is preferred. Used to access prototype chain for inheritance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 85,
            "name": "What is Objectcreate",
            "question": "What is Object.create()?",
            "answer": "Object.create(proto, properties) creates new object with specified prototype. Enables explicit prototype-based inheritance without constructor functions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 86,
            "name": "How inheritance works through prototypes",
            "question": "How inheritance works through prototypes?",
            "answer": "Objects inherit via prototype chain. Properties/methods defined on prototype are shared by all instances. ES6 class syntax provides cleaner inheritance syntax.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 87,
            "name": "What is this keyword in JavaScript",
            "question": "What is this keyword in JavaScript?",
            "answer": "this refers to the execution context's object. Value depends on call site: method calls set this to receiver, functions to global/undefined in strict mode.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 88,
            "name": "How does this behave in global scope",
            "question": "How does this behave in global scope?",
            "answer": "In global scope, this refers to globalObject (window in browsers, global in Node.js). In strict mode, this is undefined in standalone function calls.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 89,
            "name": "How does this behave inside a function",
            "question": "How does this behave inside a function?",
            "answer": "Inside function, this depends on call pattern: receiver.method() -> this=receiver, fn() -> this=global/undefined, new fn() -> this=new instance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 90,
            "name": "How does this behave inside arrow functions",
            "question": "How does this behave inside arrow functions?",
            "answer": "Arrow functions have lexical this inherited from surrounding scope. Cannot change with call/apply/bind; always refers to parent function/object this.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 91,
            "name": "How does this behave inside classes",
            "question": "How does this behave inside classes?",
            "answer": "In class methods, this refers to instance. In static methods, this=class. Arrow functions in class fields preserve this as the instance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 92,
            "name": "What is a normal function",
            "question": "What is a normal function?",
            "answer": "Normal function (function declaration/expression) has own this (dynamic), arguments object, can be constructor, and is hoisted (declarations).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 93,
            "name": "What is an arrow function",
            "question": "What is an arrow function?",
            "answer": "Arrow function has lexical this, no arguments, cannot be constructor, not hoisted, and provides concise syntax for callbacks.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 94,
            "name": "What is a constructor function",
            "question": "What is a constructor function?",
            "answer": "Constructor function is normal function called with new keyword to create instances. Initializes instance properties; prototype contains shared methods.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 95,
            "name": "Differences between function declaration and function expres",
            "question": "Differences between function declaration and function expression?",
            "answer": "Declaration: hoisted with body, named. Expression: not hoisted, can be anonymous/named, assigned to variable. Choose declaration for reusable utilities.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 96,
            "name": "What are enhanced object literals in ES6",
            "question": "What are enhanced object literals in ES6?",
            "answer": "Enhanced literals: shorthand properties {name}, shorthand methods {fn(){}}, computed property names {[expr]:value}, and method shorthand.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 97,
            "name": "What are computed property names",
            "question": "What are computed property names?",
            "answer": "Computed property names use [expression] syntax: {[getKey()]: value}. Enables dynamic property names without intermediate variables.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 98,
            "name": "What is objectfreeze vs objectseal",
            "question": "What is object.freeze() vs object.seal()?",
            "answer": "freeze(): prevents adding/removing/modifying properties (fully immutable). seal(): prevents adding/removing but allows modifying existing properties.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 99,
            "name": "What is an iterable in JavaScript",
            "question": "What is an iterable in JavaScript?",
            "answer": "An iterable is object with Symbol.iterator method returning iterator. Enables for...of loops and spread operator. Arrays, Strings, Maps, Sets are iterables.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 100,
            "name": "What is an iterator",
            "question": "What is an iterator?",
            "answer": "An iterator is object with next() method returning {value, done}. Powers for...of loops and spread. Enables custom iteration logic.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 101,
            "name": "How forof loop works internally",
            "question": "How for...of loop works internally?",
            "answer": "for...of calls Symbol.iterator on iterable, gets iterator, repeatedly calls next() until done:true. Cleaner than for...in for iterables.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 102,
            "name": "What are classes in ES6",
            "question": "What are classes in ES6?",
            "answer": "Classes are syntactic sugar over prototype-based inheritance. Provide constructor, methods, getters/setters, static members, and cleaner inheritance via extends.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 103,
            "name": "What are class constructors",
            "question": "What are class constructors?",
            "answer": "Constructor is special method called on instantiation via new. Initializes instance properties. Only one constructor per class; use static factory methods for variants.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 104,
            "name": "What are getters and setters",
            "question": "What are getters and setters?",
            "answer": "Getters (get prop()) enable computed property access; setters (set prop(val)) enable validation. Provide controlled access and side-effect triggering.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 105,
            "name": "What is inheritance using extends",
            "question": "What is inheritance using extends?",
            "answer": "extends keyword creates class inheritance: class Child extends Parent {}. Child inherits methods/properties; use super() to call parent constructor.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 106,
            "name": "What is Symbol in JavaScript",
            "question": "What is Symbol in JavaScript?",
            "answer": "Symbol is primitive for unique identifiers. Often used for non-enumerable object keys, well-known symbols (Symbol.iterator), and private-like properties.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 107,
            "name": "What are use cases of Symbol",
            "question": "What are use cases of Symbol?",
            "answer": "Use cases: unique object keys, private properties, defining custom protocol methods (Symbol.iterator, Symbol.toStringTag), preventing property collisions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 108,
            "name": "What is Map in JavaScript",
            "question": "What is Map in JavaScript?",
            "answer": "Map is key-value collection where keys can be any type (unlike objects where keys are strings/symbols). Maintains insertion order; has size property.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 109,
            "name": "What is Set in JavaScript",
            "question": "What is Set in JavaScript?",
            "answer": "Set is collection of unique values (duplicates ignored). Maintains insertion order; useful for deduplication and membership testing.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 110,
            "name": "Differences between Map and Object",
            "question": "Differences between Map and Object?",
            "answer": "Map: any key type, has size, iterable, better performance for frequent add/remove. Object: string/symbol keys, no size property, not directly iterable.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 111,
            "name": "Differences between Set and Array",
            "question": "Differences between Set and Array?",
            "answer": "Set: unique values, faster lookup, no indices. Array: ordered, allows duplicates, index access, more methods. Choose by need for uniqueness and access patterns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 112,
            "name": "What causes memory leaks in JavaScript",
            "question": "What causes memory leaks in JavaScript?",
            "answer": "Causes: forgotten timers/listeners, circular references, closures retaining large objects, global variables, DOM references after removal, and event handler detachment failure.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 113,
            "name": "How closures cause memory leaks",
            "question": "How closures cause memory leaks?",
            "answer": "Closures capture outer variables; if outer contains large objects and closure outlives need, objects remain in memory. Fix by clearing references or using WeakMap.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 114,
            "name": "What is garbage collection",
            "question": "What is garbage collection?",
            "answer": "Garbage collection automatically reclaims memory of unreachable objects. Modern engines use mark-and-sweep and generational GC for efficiency.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 115,
            "name": "What is markandsweep algorithm",
            "question": "What is mark-and-sweep algorithm?",
            "answer": "Mark-and-sweep marks reachable objects from roots, then sweeps (frees) unmarked objects. Prevents memory fragmentation and efficiently reclaims unused memory.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 116,
            "name": "What is event delegation",
            "question": "What is event delegation?",
            "answer": "Event delegation attaches single listener to ancestor and uses event.target to identify actual target. Efficient for many children and handles dynamic elements.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 117,
            "name": "What is shadow DOM",
            "question": "What is shadow DOM?",
            "answer": "Shadow DOM provides encapsulated DOM/styles within web components. Prevents style leakage and DOM traversal outside shadow boundary.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 118,
            "name": "What is immutability in JavaScript",
            "question": "What is immutability in JavaScript?",
            "answer": "Immutability means objects/values cannot change after creation. Benefits: predictability, easier debugging, safe concurrency. Libraries: Immer, Immutable.js.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 119,
            "name": "What is deep copy vs shallow copy",
            "question": "What is deep copy vs shallow copy?",
            "answer": "Shallow copy: copies top-level, nested objects remain referenced. Deep copy: recursively clones all levels. Use structuredClone(), JSON methods, or libraries.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 120,
            "name": "What is optional chaining",
            "question": "What is optional chaining (?.)?",
            "answer": "Optional chaining (?.) safely accesses nested properties: obj?.a?.b. Returns undefined if intermediate is null/undefined, preventing TypeError.",
            "useCases": [],
            "realTimeUseCases": []
        }
    ],
    "React JS": [
        {
            "id": 1,
            "name": "React JS",
            "question": "What is React JS?, why to use it?, what are the benefits of it?",
            "answer": "â˜‘ï¸What is React JS?â˜ï¸React JS is an Open Source JavaScript library used to build fast, interactive, component-based user interfaces.âœŒï¸It works using a virtual DOM and declarative UI approach.ðŸ¤ŸIt helps create reusable UI components for single-page applications.â˜‘ï¸Why do we use React JS Means?â˜ï¸To build fast, scalable, and maintainable front-end applications.âœŒï¸To manage complex UI state easily using components + hooks.ðŸ¤ŸTo create highly interactive and dynamic UIs without page reloads.â˜‘ï¸What are the Benefits of React JSâ˜ï¸The Main Benefits of React JS are - Component-Based Architecture  â†’ We will develop Reusable, clean, maintainable code.âœŒï¸Fast Rendering â†’ Virtual DOM makes UI updates efficient.ðŸ¤ŸReact Hooks supports â†’ Easy state & side-effect management in functional components.âœ‹ Unidirectional Data Flow â†’ Predictable and easier debugging.ðŸ‘ŒReact JS has Large Ecosystem â†’ Libraries, community support,tools.ðŸ«±React is a Cross-Platform â†’ React Native for mobile using same concepts.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 2,
            "name": "Already Angular",
            "question": "Already we have Angular, then why to use React JS? means what are the main Benefits if we use React JS Over Angular for Developing Front end Application?",
            "answer": "â˜ï¸ React is Lightweight & Flexible:React is a library, not a full framework like Angular.You pick only what you need â†’ faster development, less complexity.âœŒï¸ Faster Performance (Virtual DOM):React uses Virtual DOM, which updates the UI efficiently.Angularâ€™s real DOM updates can be slower in large apps.ðŸ¤Ÿ Easy to Learn & Use:React uses simple JavaScript + JSX.Angular has many concepts (modules, decorators, DI, RxJS) â†’ bigger learning curve.âœ‹ Component-Based with Reusability:Reactâ€™s component structure is more straightforward and easy to reuse.Angular components are more structured but heavier.ðŸ‘Œ Better Control Over Architecture:React gives developers freedom to choose routing, state management, libraries.Angular forces a fixed pattern of how to build things.ðŸ«± Huge Ecosystem & Community Support:React has a massive ecosystem (Redux, React Query, Next.js).More job opportunities and third-party integrations.ðŸ«² Faster Rendering & Better Optimization:React re-renders only impacted components.Angular sometimes re-renders whole component trees (digest cycle).ðŸ«³ Hooks Make Logic Cleaner:React Hooks make state management elegant and simple.Angular uses services + RxJS which are more complex.â˜‘ï¸ Simple One-Line Answer for InterviewsðŸ‘‰ â€œWe use React over Angular because it is lightweight, faster with Virtual DOM, easier to learn, highly flexible, and gives better performance with simpler component logic.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 3,
            "name": "Angular Also supports Virtual DOM",
            "question": "Angular Also supports Virtual DOM, then what is the special in React JS and why to use it?",
            "answer": "â˜ï¸Compared to Angular,  React is simpler and lightweight and React is just a UI library.Angular is a full-blown framework with many mandatory concepts.âœŒï¸ React gives more freedom:You choose routing, state management (Redux, Zustand, Context).Angular forces a strict structure with decorators, services, DI, RxJS, modules.ðŸ¤Ÿ React is easier to learn:React = JavaScript + JSX + Hooks.Angular = TypeScript + Decorators + DI + RxJS + Modules + Templates â†’ heavy.âœ‹ Reactâ€™s component model is cleaner:Functional components + Hooks make logic reuse very simple. Angular relies on services, directives, and RxJS for most logic.ðŸ‘Œ React is faster for UI-heavy applications:Virtual DOM updates only the affected component.Angular triggers change detection across the whole component tree unless manually optimized.ðŸ«± React ecosystem is larger:Next.js, Remix, React Query, Redux Toolkit, Material UI, etc.Faster development, more libraries, more community support.ðŸ«² React gives more control to the developer:You design your architecture.Angular enforces its own heavy architecture.â˜‘ï¸ Short crisp interview answer:ðŸ‘‰ â€œReact is preferred because it is lightweight, easier to learn, uses Virtual DOM for faster updates, gives developers full flexibility to choose libraries, and has a larger ecosystem compared to Angularâ€™s strict and heavy framework approach.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 4,
            "name": "main differences Angular & ReactJS?",
            "question": "Explain what are the main differences between Angular and react JS?",
            "answer": "â˜ï¸ Type of Technology:Angular is a full-fledged framework.React is a UI library.âœŒï¸ Learning Curve:Angular is harder: uses TypeScript, decorators, modules, DI, RxJS.React is simpler: uses JavaScript + JSX + Hooks.ðŸ¤ŸArchitecture:Angular comes with everything built-in (routing, HTTP, forms, state).React gives freedom to choose libraries (Redux, React Router, Axios).âœ‹ Rendering Approach:Angular uses Incremental DOM + Change Detection.React uses Virtual DOM + Reconciliation, which is faster for UI updates.ðŸ‘Œ Data Binding:Angular supports two-way binding.React uses one-way binding, making state flow predictable. ðŸ«± Performance:Angular re-runs change detection across components unless optimized.React updates only the affected component due to Virtual DOM.ðŸ«² State Management:Angular uses services, RxJS, and Observables. React uses Hooks, Context API, Redux, Zustand, etc.ðŸ«³ Flexibility:Angular is strict with its predefined structure.React is flexible â€” you design your own architecture.ðŸ«´ Community & Ecosystem:Angular updates are heavier and less frequent.React has a huge ecosystem (Next.js, React Query, Redux Toolkit). ðŸ‘ Usage Style:Angular uses HTML templates + TypeScript-heavy code. React uses JSX (JavaScript + HTML in one place).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 5,
            "name": "React Advantages",
            "question": "What are the React JS Advantages over Angular?",
            "answer": "â˜ï¸ React is light weight and simpler: React is just a UI library.Angular is a heavy framework with many built-in features, making it more complex.âœŒï¸ Faster performance with Virtual DOM: React updates only the required part of the UI. Angularâ€™s change-detection is heavier and checks more components. ðŸ¤Ÿ Easier to learn: React needs basic JavaScript + JSX + Hooks. Angular requires learning RxJS, DI, decorators, modules, templates, etc. âœ‹ More flexibility: React allows choosing routing, state management, API libraries, and architecture. Angular forces predefined patterns and structure.ðŸ‘Œ Cleaner component logic with Hooks: Hooks make state  management and side effects simple. Angular uses services + RxJS, which is more complicated. ðŸ«± Better ecosystem and community : React has huge community support and large ecosystem tools like Next.js, Redux Toolkit, React Query, Material UI.Faster updates, more libraries, more open-source contributions. ðŸ«² Reusability:Reactâ€™s functional components + custom hooks make code reuse very easy.Angularâ€™s patterns are more structured and require more boilerplate. ðŸ«³ Faster development:Lightweight structure + reusable components + minimal setup = quicker development cycles. Angular requires more setup and configuration for small-to-medium projects. ðŸ«´ Easier debugging: One-way data flow in React makes debugging more predictable. Angularâ€™s two-way binding sometimes complicates debugging.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 6,
            "name": "React Dis-advantages",
            "question": "What are the React JS Dis-advantages?",
            "answer": "React JS has some disadvantages these are:â˜ï¸ Too many choices / No fixed structure: React is just a library, so developers must choose routing, state management, and architecture manually. This creates confusion for beginners. âœŒï¸ Fast-changing ecosystem: React updates frequently, and many libraries become outdated quickly. Developers must keep learning and adjusting. ðŸ¤Ÿ JSX learning curve: JSX mixes HTML with JavaScript, which feels strange initially. Some developers find it hard to read or adopt. âœ‹ Requires additional libraries: React does not provide routing, form handling, or HTTP services by default. You must use extra libraries (React Router, Axios, Redux), increasing setup effort. ðŸ‘Œ Performance issues if not optimized: Incorrect use of hooks, unnecessary re-renders, or stale props can slow down the UI.Developers must understand optimization tools like memo, useCallback, useMemo.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 7,
            "name": "React use cases?",
            "question": "What are the React JS Real-world use cases?",
            "answer": "We use React JS in different use cases like â˜ï¸ E-Commerce Applications:Product listing, filters, cart, checkout, dynamic pricing.Fast UI updates and reusable components make e-commerce smooth.âœŒï¸ Social Media Platforms:Feeds, stories, chats, notifications update instantly.Reactâ€™s virtual DOM handles high-frequency updates efficiently.ðŸ¤Ÿ Dashboards & Analytics Tools:Real-time charts, filters, widgets, live metrics.React renders complex UI components without lag.âœ‹ Content Management Systems (CMS):Admin panels, content editors, dynamic pages.Highly interactive UIs are easy to build with React.ðŸ‘Œ Single Page Applications (SPA):Apps where UI updates without page reload.Examples: Gmail-like apps, booking apps, ticketing, OTT dashboards.ðŸ«± Mobile Apps (via React Native):Same React skills can build mobile apps for iOS & Android.Reusability of components reduces development cost.ðŸ«² Streaming & Media Applications:Netflix-like UI, dynamic thumbnails, category sliders.Smooth navigation due to Reactâ€™s rendering efficiency.ðŸ«³ Enterprise Applications:Employee portals, inventory systems, CRM, HRMS.React helps build scalable and maintainable front-end modules.ðŸ«´ Real-time Collaboration Tools:Chat apps, whiteboards, document editors, Kanban boards.React handles frequent state changes effectively.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 8,
            "name": "React features",
            "question": "what are the React JS main features?",
            "answer": "React JS has 9 main features:â˜ï¸ One is Component-Based Architecture:UI is split into small, reusable components.Makes code clean, maintainable, and scalable.âœŒï¸ Virtual DOM:React updates only the changed parts of the UI.Gives fast performance and smooth user experience.ðŸ¤Ÿ One-Way Data Binding:Data flows in a single direction.Makes debugging and state management predictable.âœ‹ JSX (JavaScript + XML):Allows writing HTML inside JavaScript.Easy to understand and improves developer productivity.ðŸ‘Œ Hooks (useState, useEffect, etc.):Manage state and side effects inside functional components.Removes the need for class components.ðŸ«± Declarative UI:You describe what the UI should look like.React handles the UI updates efficiently.ðŸ«² Strong Ecosystem Support:Libraries like Redux, React Router, React Query, Next.js. Helps developers build complete applications easily.ðŸ«³ Cross-Platform Support:React Native allows building mobile apps using the same React concepts.Reduces development time and learning effort.ðŸ«´ Fast Rendering:Optimized rendering with diffing algorithms and batching.Better performance in large applications.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 9,
            "name": "React Architecture",
            "question": "Explain about React JS Architecture how exactly it works?",
            "answer": "React JS will works based on the â˜ï¸ 1. Component-Based Architecture:React breaks the UI into small, reusable components (Header, Sidebar, ProductCard, etc.).Each component manages its own state, UI, and logic.âœŒï¸ 2. Virtual DOM Layer (Core of React):When UI changes, React does not update the real DOM immediately.React first updates a Virtual DOMâ€”a lightweight copy of the actual DOM.React then compares old vs new Virtual DOM using Diffing Algorithm.ðŸ¤Ÿ 3. Reconciliation Process (Diffing + Efficient Updates): React checks which part changed in the Virtual DOM. It updates only that specific part in the real DOM. This makes UI updates faster and smoother. âœ‹ 4. Renderer Layer (ReactDOM): ReactDOM is responsible for finally updating the real browser DOM.ReactDOM takes the minimal updates identified by reconciliation and applies them. ðŸ‘Œ 5. State & Props Flow (One-Way Data Flow): State â†’ Internal data of a component. Props â†’ Data received from parent component. Data flows top to bottom â†’ makes debugging and UI flow predictable. ðŸ«± 6. Hooks Layer (Functional Logic Control): Hooks like useState, useEffect, useMemo, useCallback handle: State, Side effects, Performance optimization, Subscriptions, They allow building powerful logic inside functional components. ðŸ«² 7. Event System (Synthetic Events): React wraps browser events with its own Synthetic Event System. Ensures cross-browser consistency and better performance. ðŸ«³ 8. React Fiber (Internal Engine):Fiber is Reactâ€™s internal engine that handles:Scheduling updates,Splitting rendering into chunks,Making UI smooth even during heavy operations,Helps React prioritize important UI updates first.ðŸ«´ 9. Optional: State Management Layer (Redux / Context):For large apps, global state management is handled using:Redux,Context API,:Manages shared data like cart, login info, user preferences.â˜‘ï¸ Short 20-second Interview SummaryðŸ‘‰ â€œReact works using a component-based architecture where every UI part is built as a reusable component. When the UI updates, React updates a Virtual DOM instead of the real DOM. It then identifies the exact changes and updates only those parts in the actual DOM through the reconciliation process. Data flows from parent to child components, and Hooks manage logic inside functional components. This architecture makes React fast, scalable, and easy to maintain.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 10,
            "name": "Virtual DOM",
            "question": "Explain clearly about React JS Virtual DOM - How it works internally? Why to use it because we have already RealDOM? , then Why to use and what are the benefits of it in React JS?",
            "answer": "â˜‘ï¸What is Virtual DOM in React?: â˜ï¸ Virtual DOM is a lightweight JavaScript copy of the Real DOM.âœŒï¸ It is not the actual browser DOM â€” itâ€™s just an in-memory representation.ðŸ¤ŸReact uses it to calculate the most efficient way to update the real UI.â˜‘ï¸Why Real DOM is slow?:â˜ï¸Real DOM updates are expensive because: Changing even small UI parts triggers full reflows & repaints. Browser recalculates layout, styles, and renders again.âœŒï¸Frequent UI updates (cart, filters, search) make the app slow.Real DOM is powerful but not optimized for high-frequency updates. â˜‘ï¸How Virtual DOM Works Internally? (Step-by-step):1. UI change happens: A state change or props change triggers React to re-render the component.2. React creates a new Virtual DOM tree: React generates a new virtual DOM snapshot of the UI. 3. React compares Old vs New Virtual DOM (Diffing):React checks what actually changed using an optimized algorithm. It detects minimal differences â€” even at node, attribute, or text level. 4. React updates only the required part of Real DOM : Not the entire page, not the entire component tree. Only the exact changed elements are updated using Reconciliation. 5. Browser work becomes minimal : Very small, precise DOM changes = smoother UI and better performance. â˜‘ï¸Why React uses Virtual DOM even though Real DOM exists? â˜ï¸Real DOM is slow for interactive apps (e-commerce, dashboards, social apps). âœŒï¸Virtual DOM reduces the number of direct updates to Real DOM. ðŸ¤ŸIt allows React to batch updates, avoiding unnecessary work. âœ‹ It gives React full control over how and when to update UI efficiently.â˜‘ï¸Main Benefits of Virtual DOM in React: â˜ï¸Faster UI Updates: Only updates the changed elements, not the whole DOM. âœŒï¸ Better Performance in Big Applications: Works smoothly even with large components, lists, grids, filters, etc. ðŸ¤ŸPredictable Rendering React decides precisely what needs to change â€” no random reflows. âœ‹Improved User Experience Smooth transitions, fast interactions, no lag. ðŸ‘Œ Cross-platform Rendering: Same Virtual DOM concept works for React Native, Next.js, and server rendering. ðŸ«±Batching Updates: React groups multiple state updates into one efficient DOM update. â˜‘ï¸Short Interview Answer (20 Seconds)ðŸ‘‰ â€œReact uses Virtual DOM as a lightweight copy of the real DOM to calculate changes efficiently. When the UI updates, React compares the old and new virtual DOM, finds minimal changes, and updates only those parts in the real DOM. This avoids heavy reflows, makes rendering fast, and improves performance of large, interactive applications.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 11,
            "name": "React JS",
            "question": "What is React JS, why to use it, what are the benefits of it",
            "answer": "â˜‘ï¸What is React JS?â˜ï¸React JS is a JavaScript library used to build fast, interactive, component-based user interfaces.âœŒï¸It works using a virtual DOM and declarative UI approach.ðŸ¤ŸIt helps create reusable UI components for single-page applications.â˜‘ï¸Why do we use React JS?â˜ï¸To build fast, scalable, and maintainable front-end applications.âœŒï¸To manage complex UI state easily using components + hooks.ðŸ¤ŸTo create highly interactive and dynamic UIs without page reloads.â˜‘ï¸Benefits of React JSâ˜ï¸Component-Based â†’ Reusable, clean, maintainable code.âœŒï¸Fast Rendering â†’ Virtual DOM makes UI updates efficient.ðŸ¤ŸHooks â†’ Easy state & side-effect management in functional components.âœ‹ Unidirectional Data Flow â†’ Predictable and easier debugging.ðŸ‘ŒLarge Ecosystem â†’ Libraries, community support,tools.ðŸ«±Cross-Platform â†’ React Native for mobile using same concepts.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 12,
            "name": "Already Angular",
            "question": "Already we have Angular, then why to use React JS? means what are the main Benefits if we use React JS Over Angular for Developing Front end Application?",
            "answer": "â˜ï¸ React is Lightweight & Flexible:React is a library, not a full framework like Angular.You pick only what you need â†’ faster development, less complexity.âœŒï¸ Faster Performance (Virtual DOM):React uses Virtual DOM, which updates the UI efficiently.Angularâ€™s real DOM updates can be slower in large apps.ðŸ¤Ÿ Easy to Learn & Use:React uses simple JavaScript + JSX.Angular has many concepts (modules, decorators, DI, RxJS) â†’ bigger learning curve.âœ‹ Component-Based with Reusability:Reactâ€™s component structure is more straightforward and easy to reuse.Angular components are more structured but heavier.ðŸ‘Œ Better Control Over Architecture:React gives developers freedom to choose routing, state management, libraries.Angular forces a fixed pattern of how to build things.ðŸ«± Huge Ecosystem & Community Support:React has a massive ecosystem (Redux, React Query, Next.js).More job opportunities and third-party integrations.ðŸ«² Faster Rendering & Better Optimization:React re-renders only impacted components.Angular sometimes re-renders whole component trees (digest cycle).ðŸ«³ Hooks Make Logic Cleaner:React Hooks make state management elegant and simple.Angular uses services + RxJS which are more complex.â˜‘ï¸ Simple One-Line Answer for InterviewsðŸ‘‰ â€œWe use React over Angular because it is lightweight, faster with Virtual DOM, easier to learn, highly flexible, and gives better performance with simpler component logic.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 13,
            "name": "Angular Also supports Virtual DOM",
            "question": "Angular Also supports Virtual DOM, then what is the special in React JS and why to use it?",
            "answer": "â˜ï¸Compared to Angular,  React is simpler and lightweight and React is just a UI library.Angular is a full-blown framework with many mandatory concepts.âœŒï¸ React gives more freedom:You choose routing, state management (Redux, Zustand, Context).Angular forces a strict structure with decorators, services, DI, RxJS, modules.ðŸ¤Ÿ React is easier to learn:React = JavaScript + JSX + Hooks.Angular = TypeScript + Decorators + DI + RxJS + Modules + Templates â†’ heavy.âœ‹ Reactâ€™s component model is cleaner:Functional components + Hooks make logic reuse very simple. Angular relies on services, directives, and RxJS for most logic.ðŸ‘Œ React is faster for UI-heavy applications:Virtual DOM updates only the affected component.Angular triggers change detection across the whole component tree unless manually optimized.ðŸ«± React ecosystem is larger:Next.js, Remix, React Query, Redux Toolkit, Material UI, etc.Faster development, more libraries, more community support.ðŸ«² React gives more control to the developer:You design your architecture.Angular enforces its own heavy architecture.â˜‘ï¸ Short crisp interview answer:ðŸ‘‰ â€œReact is preferred because it is lightweight, easier to learn, uses Virtual DOM for faster updates, gives developers full flexibility to choose libraries, and has a larger ecosystem compared to Angularâ€™s strict and heavy framework approach.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 14,
            "name": "main differences Angular & Rreact JS?",
            "question": "Explain what are the main differences between Angular and react JS?",
            "answer": "â˜ï¸ Type of Technology:Angular is a full-fledged framework.React is a UI library.âœŒï¸ Learning Curve:Angular is harder: uses TypeScript, decorators, modules, DI, RxJS.React is simpler: uses JavaScript + JSX + Hooks.ðŸ¤ŸArchitecture:Angular comes with everything built-in (routing, HTTP, forms, state).React gives freedom to choose libraries (Redux, React Router, Axios).âœ‹ Rendering Approach:Angular uses Incremental DOM + Change Detection.React uses Virtual DOM + Reconciliation, which is faster for UI updates.ðŸ‘Œ Data Binding:Angular supports two-way binding.React uses one-way binding, making state flow predictable. ðŸ«± Performance:Angular re-runs change detection across components unless optimized.React updates only the affected component due to Virtual DOM.ðŸ«² State Management:Angular uses services, RxJS, and Observables. React uses Hooks, Context API, Redux, Zustand, etc.ðŸ«³ Flexibility:Angular is strict with its predefined structure.React is flexible â€” you design your own architecture.ðŸ«´ Community & Ecosystem:Angular updates are heavier and less frequent.React has a huge ecosystem (Next.js, React Query, Redux Toolkit). ðŸ‘ Usage Style:Angular uses HTML templates + TypeScript-heavy code. React uses JSX (JavaScript + HTML in one place).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 15,
            "name": "React Advantages",
            "question": "What are the React JS Advantages over Angular?",
            "answer": "â˜ï¸ React is lightweight and simpler: React is just a UI library.Angular is a heavy framework with many built-in features, making it more complex.âœŒï¸ Faster performance with Virtual DOM: React updates only the required part of the UI. Angularâ€™s change-detection is heavier and checks more components. ðŸ¤Ÿ Easier to learn: React needs basic JavaScript + JSX + Hooks. Angular requires learning RxJS, DI, decorators, modules, templates, etc. âœ‹ More flexibility: React allows choosing routing, state management, API libraries, and architecture. Angular forces predefined patterns and structure.ðŸ‘Œ Cleaner component logic with Hooks: Hooks make state  management and side effects simple. Angular uses services + RxJS, which is more complicated. ðŸ«± Better ecosystem and community : React has huge community support and large ecosystem tools like Next.js, Redux Toolkit, React Query, Material UI.Faster updates, more libraries, more open-source contributions. ðŸ«² Reusability:Reactâ€™s functional components + custom hooks make code reuse very easy.Angularâ€™s patterns are more structured and require more boilerplate. ðŸ«³ Faster development:Lightweight structure + reusable components + minimal setup = quicker development cycles. Angular requires more setup and configuration for small-to-medium projects. ðŸ«´ Easier debugging: One-way data flow in React makes debugging more predictable. Angularâ€™s two-way binding sometimes complicates debugging.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 16,
            "name": "Tell me",
            "question": "Tell me something about yourself?",
            "answer": "Hi, Iâ€™m Aruna Kumari.I have overall 5 years of experience as a Full-Stack Developer, currently working with Verizon in Bangalore location. I am expertise in frontend technologies like React.js, Redux, JavaScript, HTML, CSS and backend Technologies like Node.js, Express JS, RESTful API, Microservices, MySQL and also worked on CI-CD tools like Git, GitHub, Jenkins and AWS for the code deployment. So far, I worked on three different domains like eCommerce, Insurance and HealthCare Projects. And currently waiting for the chance to work in new company thanks",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 17,
            "name": "Current Project",
            "question": "Explain about your Current Project",
            "answer": "My current project is NMG (Neiman Marcus Group) â˜‘ï¸ which is an American eCommerce Project. The main purpose of this project is â˜‘ï¸To provide a seamless online shopping experience for NMG customers.â˜‘ï¸To manage product listings, pricing, inventory, and offers efficiently.â˜‘ï¸ To handle secure user authentication, cart management, checkout, and payments.â˜‘ï¸ To support high traffic, fast search results, and smooth order processing and alsoâ˜‘ï¸ To integrate with warehouses, delivery partners, and internal ERP systems.â˜‘ï¸ In this Project, we have different modules likeâ˜‘ï¸ User Management Module=>under this we have - Login, registration, profile, address book.â˜‘ï¸ Product Catalog Module=>under this we have - Category pages, product details, filters, search.â˜‘ï¸ Inventory Management Module=> under this we have - Stock updates, availability, SKU management.â˜‘ï¸ Cart & Wishlist Module=> under this we have - Add/remove items, update quantities, save for later.â˜‘ï¸Checkout & Payments Module=> Address selection, payment gateway, order summary.â˜‘ï¸ Order Management Module=> Order creation, tracking, returns/refunds.â˜‘ï¸ Offers & Promotions Module=> Coupons, discount rules, seasonal campaigns.â˜‘ï¸ Admin Portal Module=> Product upload, pricing updates, inventory dashboard. *** I used - Backend Skills like (Node JS + Express JS + Microservices + MySQL)-âœŒï¸ Developed RESTful APIs for products, cart, auth, orders.âœŒï¸ Followed Microservices architecture for scalability.âœŒï¸ Used Express JS for routing, middleware, validations.âœŒï¸ Implemented JWT authentication & session handling.âœŒï¸ Used MySQL for user data, inventory, orders, transactions.âœŒï¸ Implemented async operations, caching, pagination.âœŒï¸ *** I used Frontend Skills like (React JS + Redux + HTML + CSS + JavaScript)âœŒï¸ Built responsive UI using React JS.âœŒï¸ Managed state using Redux Toolkit. Implemented product listing, cart UI, checkout flows.âœ‹ Reused React components for faster development.ðŸ‘Œ Used Axios to call backend REST APIs.ðŸ«± Applied CSS/Styled Components for branding/UI design.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 18,
            "name": "Roles and Responsibilities",
            "question": "Explain about your Roles and Responsibilities on this NMG Project",
            "answer": "My Roles is a React JS and Node JS Full Stack Developer And My Responsibilities are: â˜ï¸ Gathering and Analysing the Requirements from the UX Designers, Architect and sometimes from the Clients also.  After that depends on the requirements as given in the JIRA ticketing tool, â˜ï¸ Developing RESTful APIs using Node JS & Express JS for products, cart, orders, users. âœŒï¸ Building Microservices for authentication, catalog, orders, inventory. ðŸ¤Ÿ Writing optimized SQL queries and designing SQL tables for eCommerce flows. âœ‹ Implementing JWT authentication, middleware, validation, error handling. ðŸ‘Œ Integrating backend APIs with React frontend using Axios/Fetch.ðŸ«± Developing responsive UI screens for product listing, cart, checkout, profile.ðŸ«² Managing application state using Redux / Redux Toolkit.ðŸ«³ Optimizing API performance using pagination, caching, indexing.ðŸ«´ Handling end-to-end features: requirement â†’ UI â†’ API â†’ DB â†’ testing.ðŸ‘ Collaborating with QA, UI/UX, and backend teams for smooth releases.ðŸ™Œ Fixing production bugs and improving application performance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 19,
            "name": "Daily Activities",
            "question": "Explain about your Day-to-Day Daily Activities on this NMG Project",
            "answer": "My Day-to-Day Daily Activities are:â˜ï¸ Attending daily stand-ups for sharing work progress & blockers, for example what I did today and what are my plannings to do tomorrow and also need to discuss about Is there any blocker or pending task.â˜ï¸Checking the emails and JIRA ticketing tool for User Stories.âœŒï¸ Working on assigned UI or API tasks for new features.ðŸ¤Ÿ Writing and testing REST APIs and integrating with frontend.âœ‹ Developing React components and updating Redux states.ðŸ‘Œ Fixing bugs from QA and production tickets.ðŸ«± Writing SQL queries for validations and backend logic.ðŸ«² Doing code reviews and pushing code to Git.ðŸ«³ Testing APIs using Postman and validating UI flows.ðŸ«´ Collaborating with backend, QA, and UI/UX teamsðŸ‘ Participating in deployment activities for QA/UAT/Prod.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 20,
            "name": "Backend Challenges",
            "question": "Explain Technically faced challenges on your NMG eCommerce Project as a Node JS, Express JS, RESTful API, Microservices, SQL Developer",
            "answer": "Yes, I faced some issues while developing Backend Applications. Here main challenges are:â˜ï¸ Challenge 1 â€” Slow product-listing API (high latency)â€¢Main issue: product listing API was slow under load (page loads > 3s).â€¢Why it happened: Unoptimized SQL (full-table scans) + N+1 queries for product images and variants.â€¢How found:Profiling with slow-query logs, EXPLAIN plans, and backend tracing (high DB time).â€¢Fix: Added proper indexes, rewrote queries with joins/CTEs, batch-fetched related data, introduced pagination.â€¢Benefits: Response times dropped significantly, lower DB CPU, better user experience and conversion.âœŒï¸Challenge 2 â€” Inventory race conditions (overselling)â€¢Main issue: Two concurrent checkouts sold the same last SKU.â€¢Why it happened: Lack of transactional control across services and no atomic stock decrement.â€¢How found: Customer complaints + audit logs showed duplicate successful orders for same SKU.â€¢Fix: Implemented DB-level transactions with SELECT ...FOR UPDATE / optimistic locking and moved stock decrement into a single atomic operation; added idempotency keys for order creation.â€¢Benefits: Eliminated overselling, reduced refunds, improved trust and fewer manual fixes.ðŸ¤Ÿ Challenge 3 â€” Inconsistent cache (stale product/pricing data)â€¢Main issue: Users saw old prices after admin updates.â€¢Why it happened: Redis cache TTLs + missing cache invalidation after updates across microservices.â€¢How found: Reproducible steps: update price in Admin â†’ frontend still showed old price; logs showed cache hit.â€¢Fix: Implemented cache invalidation events via message broker (Kafka/Rabbit) and short TTL for critical keys.â€¢Benefits: Data consistency across services, correct pricing during checkout, fewer pricing disputes.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 21,
            "name": "Frontend Challenges",
            "question": "Explain Technically faced challenges on your NMG eCommerce Project as a React JS, Redux, CSS, JavaScript, HTML, CSS Developer",
            "answer": "Yes, I faced some Challenges while developing frontend Application:â˜ï¸Challenge 1 â€” Slow initial page load / large bundleâ€¢Main issue here is: First-load time high, slow Time-to-Interactive.â€¢Why that issue came means: Large JS bundle (many libs + unused code) and no code-splitting.â€¢How I found issue means: Lighthouse scores, network waterfall showed huge main.js and long parse time. So â€¢I could Fixed this issue â€” steps:1.Audit bundle with webpack source-map-explorer.2.Remove unused libs, replace heavy libs with lighter alternatives.3.Implement route-based code-splitting (React.lazy + Suspense).4.Use dynamic imports for large components (product carousel, admin panels).5.Enable production optimizations: tree-shaking, minification, gzip/Brotli.â€¢Benefits: Faster first paint, improved SEO, higher conversion and Lighthouse scores.âœŒï¸Challenge 2â€”UI state inconsistency (cart & product sync issues)â€¢Main issue: Cart count/UI didnâ€™t reflect backend changes or multiple tabs.â€¢Why: Local component state + stale Redux state + no real-time sync.â€¢How found: Repro on two tabs and after API responses; logs showed stale state updates.â€¢Fix â€” steps:1.Centralize canonical state in Redux (single source oftruth).2.Use optimistic updates with rollback on failure.3.Add websocket or polling to sync cart across tabs/sessions.4.Use action idempotency and sequence numbers to avoid out-of-order updates.â€¢Benefits: Consistent UI, fewer checkout errors, better cross-tab UX.ðŸ¤Ÿ Challenge 3â€”Slow rendering / janky UI on product grid (performance)â€¢Main issue: Scrolling grid janks; repaint delays on hover/filters.â€¢Why: Re-rendering many DOM nodes; expensive computations in render.â€¢How found: React Profiler showed frequent re-renders and long commit times.â€¢Fix â€” steps:1.Memoize pure components with React.memo.2.Use useMemo / useCallback for derived data and handlers.3.Virtualize long lists (react-window / react-virtualized).4.Move heavy calculations outside render (precompute or web worker).â€¢Benefits: Smooth scrolling, lower CPU, improved perceived performance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 22,
            "name": "Ratings",
            "question": "How much rate can you give for React JS, Redux, CSS, JavaScript?",
            "answer": "I will give 4 rating for out of 5 to each technology Means for React JS is â€“ 4,Redux is â€“ 4,JavaScript is â€“ 4,HTML is â€“ 4,CSS is â€“ 4 for out of 5.=========> for Node JS is â€“ 4, Express JS is â€“ 4. RESTful API is â€“ 4,Microservices is â€“ 4, MySQL is â€“ 4 for out of 5",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 23,
            "name": "React JS",
            "question": "What is React JS, why to use it, what are the benefits of it",
            "answer": "â˜‘ï¸What is React JS?â˜ï¸React JS is a JavaScript library used to build fast, interactive, component-based user interfaces.âœŒï¸It works using a virtual DOM and declarative UI approach.ðŸ¤ŸIt helps create reusable UI components for single-page applications.â˜‘ï¸Why do we use React JS?â˜ï¸To build fast, scalable, and maintainable front-end applications.âœŒï¸To manage complex UI state easily using components + hooks.ðŸ¤ŸTo create highly interactive and dynamic UIs without page reloads.â˜‘ï¸Benefits of React JSâ˜ï¸Component-Based â†’ Reusable, clean, maintainable code.âœŒï¸Fast Rendering â†’ Virtual DOM makes UI updates efficient.ðŸ¤ŸHooks â†’ Easy state & side-effect management in functional components.âœ‹ Unidirectional Data Flow â†’ Predictable and easier debugging.ðŸ‘ŒLarge Ecosystem â†’ Libraries, community support,tools.ðŸ«±Cross-Platform â†’ React Native for mobile using same concepts.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 24,
            "name": "Already Angular",
            "question": "Already we have Angular, then why to use React JS? means what are the main Benefits if we use React JS Over Angular for Developing Front end Application?",
            "answer": "â˜ï¸ React is Lightweight & Flexible:React is a library, not a full framework like Angular.You pick only what you need â†’ faster development, less complexity.âœŒï¸ Faster Performance (Virtual DOM):React uses Virtual DOM, which updates the UI efficiently.Angularâ€™s real DOM updates can be slower in large apps.ðŸ¤Ÿ Easy to Learn & Use:React uses simple JavaScript + JSX.Angular has many concepts (modules, decorators, DI, RxJS) â†’ bigger learning curve.âœ‹ Component-Based with Reusability:Reactâ€™s component structure is more straightforward and easy to reuse.Angular components are more structured but heavier.ðŸ‘Œ Better Control Over Architecture:React gives developers freedom to choose routing, state management, libraries.Angular forces a fixed pattern of how to build things.ðŸ«± Huge Ecosystem & Community Support:React has a massive ecosystem (Redux, React Query, Next.js).More job opportunities and third-party integrations.ðŸ«² Faster Rendering & Better Optimization:React re-renders only impacted components.Angular sometimes re-renders whole component trees (digest cycle).ðŸ«³ Hooks Make Logic Cleaner:React Hooks make state management elegant and simple.Angular uses services + RxJS which are more complex.â˜‘ï¸ Simple One-Line Answer for InterviewsðŸ‘‰ â€œWe use React over Angular because it is lightweight, faster with Virtual DOM, easier to learn, highly flexible, and gives better performance with simpler component logic.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 25,
            "name": "Angular Also supports Virtual DOM",
            "question": "Angular Also supports Virtual DOM, then what is the special in React JS and why to use it?",
            "answer": "â˜ï¸Compared to Angular,  React is simpler and lightweight and React is just a UI library.Angular is a full-blown framework with many mandatory concepts.âœŒï¸ React gives more freedom:You choose routing, state management (Redux, Zustand, Context).Angular forces a strict structure with decorators, services, DI, RxJS, modules.ðŸ¤Ÿ React is easier to learn:React = JavaScript + JSX + Hooks.Angular = TypeScript + Decorators + DI + RxJS + Modules + Templates â†’ heavy.âœ‹ Reactâ€™s component model is cleaner:Functional components + Hooks make logic reuse very simple. Angular relies on services, directives, and RxJS for most logic.ðŸ‘Œ React is faster for UI-heavy applications:Virtual DOM updates only the affected component.Angular triggers change detection across the whole component tree unless manually optimized.ðŸ«± React ecosystem is larger:Next.js, Remix, React Query, Redux Toolkit, Material UI, etc.Faster development, more libraries, more community support.ðŸ«² React gives more control to the developer:You design your architecture.Angular enforces its own heavy architecture.â˜‘ï¸ Short crisp interview answer:ðŸ‘‰ â€œReact is preferred because it is lightweight, easier to learn, uses Virtual DOM for faster updates, gives developers full flexibility to choose libraries, and has a larger ecosystem compared to Angularâ€™s strict and heavy framework approach.â€",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 26,
            "name": "main differences Angular & Rreact JS?",
            "question": "Explain what are the main differences between Angular and react JS?",
            "answer": "â˜ï¸ Type of Technology:Angular is a full-fledged framework.React is a UI library.âœŒï¸ Learning Curve:Angular is harder: uses TypeScript, decorators, modules, DI, RxJS.React is simpler: uses JavaScript + JSX + Hooks.ðŸ¤ŸArchitecture:Angular comes with everything built-in (routing, HTTP, forms, state).React gives freedom to choose libraries (Redux, React Router, Axios).âœ‹ Rendering Approach:Angular uses Incremental DOM + Change Detection.React uses Virtual DOM + Reconciliation, which is faster for UI updates.ðŸ‘Œ Data Binding:Angular supports two-way binding.React uses one-way binding, making state flow predictable. ðŸ«± Performance:Angular re-runs change detection across components unless optimized.React updates only the affected component due to Virtual DOM.ðŸ«² State Management:Angular uses services, RxJS, and Observables. React uses Hooks, Context API, Redux, Zustand, etc.ðŸ«³ Flexibility:Angular is strict with its predefined structure.React is flexible â€” you design your own architecture.ðŸ«´ Community & Ecosystem:Angular updates are heavier and less frequent.React has a huge ecosystem (Next.js, React Query, Redux Toolkit). ðŸ‘ Usage Style:Angular uses HTML templates + TypeScript-heavy code. React uses JSX (JavaScript + HTML in one place).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 27,
            "name": "React Advantages",
            "question": "What are the React JS Advantages over Angular?",
            "answer": "â˜ï¸ React is lightweight and simpler: React is just a UI library.Angular is a heavy framework with many built-in features, making it more complex.âœŒï¸ Faster performance with Virtual DOM: React updates only the required part of the UI. Angularâ€™s change-detection is heavier and checks more components. ðŸ¤Ÿ Easier to learn: React needs basic JavaScript + JSX + Hooks. Angular requires learning RxJS, DI, decorators, modules, templates, etc. âœ‹ More flexibility: React allows choosing routing, state management, API libraries, and architecture. Angular forces predefined patterns and structure.ðŸ‘Œ Cleaner component logic with Hooks: Hooks make state  management and side effects simple. Angular uses services + RxJS, which is more complicated. ðŸ«± Better ecosystem and community : React has huge community support and large ecosystem tools like Next.js, Redux Toolkit, React Query, Material UI.Faster updates, more libraries, more open-source contributions. ðŸ«² Reusability:Reactâ€™s functional components + custom hooks make code reuse very easy.Angularâ€™s patterns are more structured and require more boilerplate. ðŸ«³ Faster development:Lightweight structure + reusable components + minimal setup = quicker development cycles. Angular requires more setup and configuration for small-to-medium projects. ðŸ«´ Easier debugging: One-way data flow in React makes debugging more predictable. Angularâ€™s two-way binding sometimes complicates debugging.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 28,
            "name": "What is API integration",
            "question": "What is API integration using useEffect and axios?",
            "answer": "Pattern: define async function inside useEffect, call axios.get/post/etc, update state with response, handle errors. Steps: define function inside effect to avoid stale closures, call axios, set loading states, handle errors with try/catch. Best practice: cancel in-flight requests on unmount to prevent memory leaks.",
            "useCases": [
                "Data fetching"
            ],
            "realTimeUseCases": [
                "All NMG data fetching uses useEffect + axios pattern"
            ]
        },
        {
            "id": 29,
            "name": "Axios vs Fetch API",
            "question": "Difference between axios and fetch.",
            "answer": "Fetch: built-in browser API, no install, promise-based, must handle JSON parsing, no interceptors or timeout built-in. Axios: third-party library, promise-based, auto JSON parsing, built-in interceptors, timeout, request cancellation. Fetch is modern and built-in; Axios is more feature-rich for REST APIs.",
            "useCases": [
                "API choice"
            ],
            "realTimeUseCases": [
                "NMG uses Axios for simplicity and interceptors"
            ]
        },
        {
            "id": 30,
            "name": "When to use axios vs fetch",
            "question": "When to use axios and when to use fetch?",
            "answer": "Use Axios: complex APIs, interceptors needed, legacy browsers, need convenience. Use Fetch: simple requests, zero dependencies, modern browsers only, minimal footprint. Modern approach: use Axios for production apps (interceptors handle auth, errors globally). Use Fetch for simple scripts. For NMG eCommerce (complex, multiple APIs), Axios is the right choice.",
            "useCases": [
                "API strategy"
            ],
            "realTimeUseCases": [
                "NMG production uses Axios; simple tasks might use Fetch"
            ]
        },
        {
            "id": 31,
            "name": "Axios interceptors",
            "question": "What are axios interceptors?",
            "answer": "Middleware that run before/after requests or responses. Request interceptor: runs before request sent (add auth token, headers). Response interceptor: runs after response received (handle errors, transform data). Use for: global auth, error handling, logging, token refresh. Example: add auth token in request interceptor before every API call.",
            "useCases": [
                "Global API handling"
            ],
            "realTimeUseCases": [
                "NMG uses request interceptor to add JWT token, response interceptor to handle 401"
            ]
        },
        {
            "id": 32,
            "name": "Axios library details",
            "question": "Explain axios library in detail.",
            "answer": "Axios is an HTTP client library for JavaScript (browser + Node.js). Features: promise-based API, request/response interceptors, request cancellation, timeout support, auto JSON transformation, XSRF protection, upload/download progress, global defaults. Installation: npm install axios. Usage: axios.get(url, config), axios.post(url, data, config). Axios instance: create custom config with axios.create(). Widely used in production React apps.",
            "useCases": [
                "HTTP client"
            ],
            "realTimeUseCases": [
                "NMG uses Axios for all HTTP requests with global interceptors"
            ]
        },
        {
            "id": 33,
            "name": "HTTP methods with axios",
            "question": "Explain axios GET, POST, PUT, PATCH, DELETE.",
            "answer": "GET: Retrieve data. axios.get('/api/products'). POST: Create data. axios.post('/api/products', {name}). PUT: Replace entire resource. axios.put('/api/products/1', {...}). PATCH: Partial update. axios.patch('/api/products/1', {price}). DELETE: Remove resource. axios.delete('/api/products/1'). Request body for POST/PUT/PATCH: second param. Query params: use params in config. Response: {data, status, headers}. All return Promises.",
            "useCases": [
                "REST operations"
            ],
            "realTimeUseCases": [
                "NMG uses all methods: GET products, POST order, PATCH cart, DELETE item"
            ]
        },
        {
            "id": 34,
            "name": "HTTP methods in eCommerce",
            "question": "When to use GET, POST, PUT, PATCH, DELETE in eCommerce project?",
            "answer": "GET: Fetch products, user profile, order history, cart. POST: Create order, add review, register user, add to cart. PUT: Update entire order, replace wishlist. PATCH: Update user profile, update cart item quantity, mark notification read. DELETE: Remove item from cart, delete review, remove address. Best practice: GET for read, POST for create, PUT for full replace, PATCH for partial, DELETE for remove. Idempotency: GET/PUT/DELETE are idempotent; POST/PATCH are not.",
            "useCases": [
                "eCommerce operations"
            ],
            "realTimeUseCases": [
                "NMG: GET /products, POST /orders, PATCH /cart, DELETE /cart/:id"
            ]
        },
        {
            "id": 35,
            "name": "POST vs PUT",
            "question": "Difference between POST and PUT.",
            "answer": "POST: Creates new resource. Request without ID. Response includes new ID. Not idempotent. Example: POST /api/products with {name, price}. PUT: Replaces entire resource. Request includes ID. Idempotent. Example: PUT /api/products/1 with {name, price} (must include all fields). Semantics: POST creates; PUT replaces. Use POST when creating, PUT when updating entire resource.",
            "useCases": [
                "API design"
            ],
            "realTimeUseCases": [
                "NMG: POST /orders (create), PUT /user/profile (full update)"
            ]
        },
        {
            "id": 36,
            "name": "PUT vs PATCH",
            "question": "Difference between PUT and PATCH.",
            "answer": "PUT: Replace entire resource. Must send complete object. Fields not included are removed/reset. PATCH: Partial update. Send only fields to update. Other fields unchanged. Example: PATCH /api/products/1 {price: 99} (only price changes). Idempotency: both are idempotent. Use PUT for full replacement; use PATCH for partial updates. Modern APIs prefer PATCH for updates.",
            "useCases": [
                "Update strategies"
            ],
            "realTimeUseCases": [
                "NMG: PATCH /cart/:id {quantity: 5} (partial), not full PUT"
            ]
        },
        {
            "id": 37,
            "name": "HTTP status codes",
            "question": "HTTP status codes in axios.",
            "answer": "2xx (Success): 200 OK, 201 Created, 204 No Content. 3xx (Redirect): 301, 302, 304. 4xx (Client Error): 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable. 5xx (Server Error): 500, 502, 503. Axios treats 2xx as success, others as error. Handle errors: catch(error) => if (error.response.status === 401) {...}",
            "useCases": [
                "Error handling"
            ],
            "realTimeUseCases": [
                "NMG handles 401 (refresh token), 422 (show validation), 500 (retry/fallback)"
            ]
        },
        {
            "id": 38,
            "name": "CRUD with axios",
            "question": "CRUD operations using axios.",
            "answer": "Create (POST): axios.post('/api/products', {name, price}). Read (GET): axios.get('/api/products/:id'). Update (PATCH): axios.patch('/api/products/:id', {name}). Delete (DELETE): axios.delete('/api/products/:id'). Error handling: wrap in try/catch. Loading state: set before request, clear after response/error. In React: use useEffect + useState + axios for full CRUD with loading/error states.",
            "useCases": [
                "Data operations"
            ],
            "realTimeUseCases": [
                "NMG Cart CRUD: POST (add), GET (fetch), PATCH (update qty), DELETE (remove)"
            ]
        },
        {
            "id": 39,
            "name": "useReducer hook",
            "question": "What is useReducer?",
            "answer": "useReducer is a Hook for complex state logic with multiple related state updates. Syntax: const [state, dispatch] = useReducer(reducer, initialState). Reducer: pure function (state, action) => newState. Dispatch: send action to reducer. Similar to Redux but local to component. Use when: state has multiple fields that update together, or complex transitions. Can extract reducer to separate file for testing.",
            "useCases": [
                "Complex state"
            ],
            "realTimeUseCases": [
                "Checkout form state: email, address, payment, errors all managed together"
            ]
        },
        {
            "id": 40,
            "name": "Why use useReducer",
            "question": "Why use useReducer?",
            "answer": "Use useReducer when: 1) State has multiple sub-fields that update together. 2) Complex state transitions with interdependencies. 3) Want to reuse state logic across components. 4) Easier to test (pure reducer function). 5) Want to track state history. vs useState: useState simpler for independent state values; useReducer better for related values. useReducer scales better as state complexity grows.",
            "useCases": [
                "State management"
            ],
            "realTimeUseCases": [
                "Checkout form uses useReducer to manage form state, validation, submission"
            ]
        },
        {
            "id": 41,
            "name": "useReducer internals",
            "question": "How useReducer works internally?",
            "answer": "React calls reducer function with current state and action: reducer(state, action). Reducer returns new state (must be pure). React updates state and re-renders component. Multiple dispatch calls batch into single re-render. Reducer must be pure (same inputs = same output). Actions are dispatched synchronously. useReducer is essentially local Redux within component.",
            "useCases": [
                "Understanding State Management"
            ],
            "realTimeUseCases": [
                "Knowing internals helps debug state updates in NMG checkout"
            ]
        },
        {
            "id": 42,
            "name": "useReducer eCommerce",
            "question": "Real-time eCommerce use cases of useReducer.",
            "answer": "1) CheckoutForm: manage multiple fields (email, address, card, errors) with coordinated updates. 2) Filter state: manage category, price, rating filters. 3) Cart operations: add, remove, update quantity. 4) Search: manage query, results, loading, errors. 5) Modal: manage open state, data, errors. 6) Wizard: multi-step form with coordinated field validation. useReducer scales better than useState for multi-field updates.",
            "useCases": [
                "Form/State Management"
            ],
            "realTimeUseCases": [
                "NMG checkout form uses useReducer for email, address, card, errors"
            ]
        },
        {
            "id": 43,
            "name": "Custom Hooks",
            "question": "What is Custom Hook?",
            "answer": "Custom Hook is a JavaScript function that uses built-in Hooks (useState, useEffect, etc.) to extract and reuse stateful logic. Naming convention: must start with 'use'. Example: function useFetch(url) { const [data, setData] = useState(null); useEffect(...); return data; }. Use in components: const data = useFetch('/api/products'). Benefits: encapsulate logic, reuse across components, easier testing.",
            "useCases": [
                "Logic Reuse",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "useCart, useFetch, useAuth custom hooks in NMG"
            ]
        },
        {
            "id": 44,
            "name": "Why Custom Hooks",
            "question": "Why do we need Custom Hooks?",
            "answer": "Custom Hooks solve: 1) Code duplication: multiple components fetch data â†’ create useFetch Hook. 2) Logic extraction: complex Hook logic in separate function. 3) Testability: Hook tested independently. 4) Reusability: share logic without HOCs or render props. 5) Readability: gives logic a name. Before Hooks: use HOCs or render props (complex); Custom Hooks are simpler.",
            "useCases": [
                "Code Organization"
            ],
            "realTimeUseCases": [
                "NMG has useFetch, useAuth, useCart to avoid duplication"
            ]
        },
        {
            "id": 45,
            "name": "Create Custom Hooks",
            "question": "How to create Custom Hooks?",
            "answer": "Steps: 1) Create function starting with 'use': function useFetch(url) {...}. 2) Use built-in Hooks inside: useState, useEffect, useContext, etc. 3) Return state/functions/values needed. 4) Call from components like any Hook. Rules: call Hooks at top level, only from components/Hooks.",
            "useCases": [
                "Custom Logic"
            ],
            "realTimeUseCases": [
                "useCart Hook encapsulates add/remove/update cart logic"
            ]
        },
        {
            "id": 46,
            "name": "Custom Hooks eCommerce",
            "question": "Real-time eCommerce use cases of Custom Hooks.",
            "answer": "1) useFetch(url): fetch API data with loading/error. 2) useAuth(): manage login/logout/session. 3) useCart(): add/remove/update items, persist to localStorage. 4) useDebounce(value, ms): debounce search input. 5) usePagination(items, pageSize): manage pagination. 6) useLocalStorage(key): persist state. 7) useAsync(fn): async function with loading/error. 8) useWindowSize(): track window dimensions. NMG could create all these Hooks.",
            "useCases": [
                "Practical Hooks"
            ],
            "realTimeUseCases": [
                "NMG has custom Hooks for cart, auth, fetch, localStorage"
            ]
        },
        {
            "id": 47,
            "name": "Context API",
            "question": "What is Context API?",
            "answer": "Context API is a React feature for sharing state across component tree without prop drilling. Steps: 1) Create context: const MyContext = React.createContext(). 2) Provider: wrap app with MyContext.Provider. 3) Consumer: use useContext(MyContext). Best for: theme, language, user auth, app-wide settings. Limitations: no middleware, no devtools like Redux. For simple global state, Context is perfect.",
            "useCases": [
                "Global State"
            ],
            "realTimeUseCases": [
                "NMG uses Context for user auth, theme"
            ]
        },
        {
            "id": 48,
            "name": "Why Context API",
            "question": "Why use Context API?",
            "answer": "Use Context API to: 1) Avoid prop drilling. 2) Share global state (theme, auth). 3) Keep code simple (no Redux boilerplate). 4) Built-in React feature. Benefits: cleaner code, easier to understand than Redux. Limitations: re-renders all consumers on change. When to use: simple global state. When to use Redux: complex state with many updates. NMG uses Context for auth, Redux for cart.",
            "useCases": [
                "State Strategy"
            ],
            "realTimeUseCases": [
                "NMG chose Context for user auth (rarely changes), Redux for cart"
            ]
        },
        {
            "id": 49,
            "name": "When Context API",
            "question": "When to use Context API?",
            "answer": "Use Context API when: 1) State is global but rarely changes. 2) Avoiding prop drilling. 3) Want minimal setup. 4) Small to medium app. Don't use when: 1) State changes frequently. 2) Many independent pieces of state. 3) Need middleware. 4) Need devtools. Decision: start with Context, graduate to Redux if state gets complex.",
            "useCases": [
                "Decision Making"
            ],
            "realTimeUseCases": [
                "NMG uses Context for auth/theme, Redux for cart/products"
            ]
        },
        {
            "id": 50,
            "name": "Implement Context API",
            "question": "Steps to implement Context API.",
            "answer": "1) Create context file: export const UserContext = React.createContext(). 2) Create provider component with state/functions. 3) Wrap app: UserProvider wraps App. 4) Use in components: const {user} = useContext(UserContext). 5) Optimize: wrap value in useMemo. Full example with auth logic in provider.",
            "useCases": [
                "Implementation"
            ],
            "realTimeUseCases": [
                "NMG UserProvider wraps app, used in Header, Account, Checkout"
            ]
        },
        {
            "id": 51,
            "name": "Context eCommerce",
            "question": "Real-time eCommerce use cases of Context API.",
            "answer": "1) UserContext: user data, login, logout. 2) ThemeContext: dark/light mode toggle. 3) LanguageContext: i18n language. 4) NotificationContext: show toast notifications. 5) CurrencyContext: selected currency. 6) CartContext: simple cart for small app. 7) FilterContext: product filters. NMG uses UserContext + ThemeContext. Redux scales better for complex cart.",
            "useCases": [
                "eCommerce Global State"
            ],
            "realTimeUseCases": [
                "NMG UserContext in Header shows user name, sign out"
            ]
        },
        {
            "id": 52,
            "name": "Context API benefits",
            "question": "Benefits of Context API.",
            "answer": "1) Avoids prop drilling. 2) Built-in React (no external library). 3) Simple API (useContext is easy). 4) Flexible (works with any data). 5) Lazy evaluation. 6) Easy to test (mock Provider). 7) Good for static/rarely-changing data. Limitations: re-renders all consumers on any change, no middleware, no devtools. Benefits make Context ideal for theme, language, user auth.",
            "useCases": [
                "Context Advantages"
            ],
            "realTimeUseCases": [
                "NMG benefits from Context simplicity for user auth"
            ]
        },
        {
            "id": 53,
            "name": "Context vs Redux advantages",
            "question": "Advantages and Disadvantages of Context API vs Redux.",
            "answer": "Context advantages: simpler, built-in, no boilerplate. Disadvantages: re-renders all consumers, no middleware. Redux advantages: predictable state, middleware, devtools, performance optimizations. Disadvantages: boilerplate, learning curve. Comparison: Context for theme/auth (simple). Redux for cart/products (complex). Decision: start with Context, switch to Redux if needed.",
            "useCases": [
                "Architecture Decision"
            ],
            "realTimeUseCases": [
                "NMG uses Context for auth, Redux for cart/products"
            ]
        },
        {
            "id": 54,
            "name": "Context vs Redux when",
            "question": "When to use Context API vs Redux?",
            "answer": "Use Context: 1) Global state rarely changes. 2) Small/medium app. 3) Want minimal setup. 4) State is flat. Use Redux: 1) Complex state with many updates. 2) Large app. 3) Need middleware. 4) Want time-travel debugging. 5) Nested objects. Hybrid: Context for simple state (user), Redux for complex (cart). Modern apps: Context for simple, Redux/Zustand for complex.",
            "useCases": [
                "Architecture"
            ],
            "realTimeUseCases": [
                "NMG: Context for UserContext, Redux for CartReducer"
            ]
        },
        {
            "id": 55,
            "name": "Redux State Container",
            "question": "What is Redux?",
            "answer": "Redux is a predictable state container for JavaScript apps. Centralizes application state in a single store. Core concepts: Store, Action, Reducer, Dispatch, Subscribe. Benefits: predictable state, time-travel debugging, middleware support. Use for: complex state, multiple async operations, large apps.",
            "useCases": [
                "State Management"
            ],
            "realTimeUseCases": [
                "NMG uses Redux for cart, products, auth"
            ]
        },
        {
            "id": 56,
            "name": "Why Redux",
            "question": "Why use Redux?",
            "answer": "Use Redux for: Complex state management, predictable state, time-travel debugging, middleware support, large apps with many components. Benefits: easier to debug, test state in isolation, scale app. Drawbacks: boilerplate, learning curve. For small apps: Context API. For large apps: Redux.",
            "useCases": [
                "State Strategy"
            ],
            "realTimeUseCases": [
                "NMG eCommerce uses Redux for cart and products"
            ]
        },
        {
            "id": 57,
            "name": "When Redux",
            "question": "When to use Redux?",
            "answer": "Use Redux when: State is complex, many components access same state, frequent state updates, need to debug state changes, app is large. Avoid Redux for: simple apps, small state, static state. Decision: start with Context, upgrade to Redux if state gets complex.",
            "useCases": [
                "Decision Making"
            ],
            "realTimeUseCases": [
                "NMG chose Redux for cart/products with frequent updates"
            ]
        },
        {
            "id": 58,
            "name": "useSelector Hook",
            "question": "What is useSelector?",
            "answer": "useSelector is a Hook that extracts state from Redux store. Syntax: const selectedState = useSelector(state => state.cart.items). Automatically subscribes and re-renders when selected state changes. Benefits: cleaner than connect HOC, easier composition. Example: const items = useSelector(state => state.cart.items);",
            "useCases": [
                "Redux Hooks"
            ],
            "realTimeUseCases": [
                "NMG uses useSelector to get cart items and user data"
            ]
        },
        {
            "id": 59,
            "name": "useDispatch Hook",
            "question": "What is useDispatch?",
            "answer": "useDispatch is a Hook that returns the dispatch function from Redux store. Syntax: const dispatch = useDispatch(). Use to dispatch actions: dispatch(addToCart(product)). Benefits: simpler than connect HOC, easier composition. useDispatch + useSelector replace the older connect() HOC pattern.",
            "useCases": [
                "Redux Hooks"
            ],
            "realTimeUseCases": [
                "NMG uses useDispatch to add/remove cart items"
            ]
        },
        {
            "id": 60,
            "name": "Redux Thunk",
            "question": "What is Redux Thunk?",
            "answer": "Redux Thunk is middleware that allows dispatch to accept functions instead of just objects. Syntax: dispatch((dispatch, getState) => { fetchData().then(data => dispatch(action(data))); }). Use for: async operations before dispatching actions. Redux Thunk is the simplest way to handle side effects in Redux.",
            "useCases": [
                "Async Operations"
            ],
            "realTimeUseCases": [
                "NMG uses Redux Thunk to fetch products and place orders"
            ]
        },
        {
            "id": 61,
            "name": "Redux Saga",
            "question": "What is Redux Saga?",
            "answer": "Redux Saga is middleware for managing side effects using generator functions. Use for: complex async operations, cancellation, retry logic. More powerful but complex than Thunk. Benefits: easier to test, better control flow. When to use: complex flows requiring cancellation, timeout, retry logic.",
            "useCases": [
                "Advanced Async"
            ],
            "realTimeUseCases": [
                "NMG could use Saga for complex order processing flows"
            ]
        },
        {
            "id": 62,
            "name": "Thunk vs Saga",
            "question": "Difference between Redux Thunk and Redux Saga.",
            "answer": "Thunk: simpler, functions return promises. Best for: straightforward async operations. Learning curve: low. Saga: more powerful, generator-based. Best for: complex async flows, cancellation. Learning curve: high. Decision: start with Thunk, upgrade to Saga if needed.",
            "useCases": [
                "Middleware Choice"
            ],
            "realTimeUseCases": [
                "NMG: Thunk for product fetch, might use Saga for payments"
            ]
        },
        {
            "id": 63,
            "name": "Redux Toolkit",
            "question": "What is Redux Toolkit?",
            "answer": "Redux Toolkit (RTK) is the recommended way to write Redux code. Features: createSlice, configureStore, createAsyncThunk, createEntityAdapter. Benefits: less boilerplate, best practices built-in, better DevTools. Installation: npm install @reduxjs/toolkit. Replaces Redux + Redux DevTools setup.",
            "useCases": [
                "Modern Redux"
            ],
            "realTimeUseCases": [
                "NMG uses Redux Toolkit for cart and product slices"
            ]
        },
        {
            "id": 64,
            "name": "Redux Toolkit vs Normal Redux",
            "question": "Difference between Normal Redux and Redux Toolkit.",
            "answer": "Normal Redux: manual action creators, separate action files, more boilerplate. Redux Toolkit: createSlice combines actions/reducers, automatic immutability, less code. RTK uses Immer library. Example: Toolkit requires ~5 lines vs 30+ lines in normal Redux. Modern apps: always use Redux Toolkit.",
            "useCases": [
                "Redux Setup"
            ],
            "realTimeUseCases": [
                "NMG switched to Redux Toolkit for simpler code"
            ]
        },
        {
            "id": 65,
            "name": "useReducer vs Redux",
            "question": "Which is good Redux or useReducer and why?",
            "answer": "useReducer: local component state, no middleware, simpler setup. Redux: app-level state, middleware support, devtools. Decision: useReducer for form state (local), Redux for cart/auth (global). Hybrid: use both in same app for different purposes.",
            "useCases": [
                "State Tool Choice"
            ],
            "realTimeUseCases": [
                "NMG: useReducer for checkout form, Redux for cart/products"
            ]
        },
        {
            "id": 66,
            "name": "Get Updated Redux State",
            "question": "How to get updated Redux state in React components?",
            "answer": "Use useSelector Hook: const state = useSelector(state => state.cart). useSelector subscribes to store and re-renders when selected state changes. Alternative (class): use connect HOC (legacy). To dispatch: const dispatch = useDispatch(); dispatch(action());",
            "useCases": [
                "Redux Usage"
            ],
            "realTimeUseCases": [
                "NMG components use useSelector to get cart, products, user state"
            ]
        },
        {
            "id": 67,
            "name": "Error Boundaries",
            "question": "What are Error Boundaries?",
            "answer": "Error Boundaries are React components that catch errors anywhere in child component tree. Must be class components. Methods: componentDidCatch() catches errors, getDerivedStateFromError() updates state. Use for: catching render errors, displaying fallback UI. Don't catch errors from event handlers (use try/catch instead).",
            "useCases": [
                "Error Handling"
            ],
            "realTimeUseCases": [
                "NMG ErrorBoundary wraps main App to show error fallback"
            ]
        },
        {
            "id": 68,
            "name": "Why Error Boundaries",
            "question": "Why use Error Boundaries?",
            "answer": "Use Error Boundaries to: Prevent full app crash, show user-friendly error messages, log errors to monitoring service, allow graceful degradation. Without Error Boundaries: one bad component crashes entire app. With Error Boundaries: only that component subtree fails, rest of app works.",
            "useCases": [
                "Stability"
            ],
            "realTimeUseCases": [
                "NMG ErrorBoundary prevents entire eCommerce app from crashing"
            ]
        },
        {
            "id": 69,
            "name": "Implement Error Boundaries",
            "question": "How to implement Error Boundaries?",
            "answer": "Create class component: class ErrorBoundary extends React.Component with componentDidCatch(error, info). Render: return hasError ? ErrorFallback : this.props.children. Wrap: ErrorBoundary wraps App. Only catches child tree errors, not own render errors.",
            "useCases": [
                "Implementation"
            ],
            "realTimeUseCases": [
                "NMG ErrorBoundary logs to Sentry, shows fallback UI"
            ]
        },
        {
            "id": 70,
            "name": "Error Boundaries eCommerce",
            "question": "Real-time eCommerce use cases of Error Boundaries.",
            "answer": "1) ProductCard error shows product unavailable, rest of ProductList works. 2) Payment gateway error shows retry without reloading. 3) Cart calculation error shows cart but disables checkout. 4) API error shows message. 5) Image load error shows placeholder. Error Boundaries essential for reliable eCommerce apps.",
            "useCases": [
                "eCommerce Reliability"
            ],
            "realTimeUseCases": [
                "NMG ErrorBoundary wraps ProductCard, Cart, Checkout"
            ]
        },
        {
            "id": 71,
            "name": "Exception Handling",
            "question": "How to handle exceptions in React JS?",
            "answer": "Methods: Try-catch in async code, Error Boundaries for render errors, useEffect cleanup for subscriptions, global error handler for unhandled rejections, error states in component using useState, show error UI with message and retry, logging to server, user-friendly messages. Best practice: catch early, centralize error handling, show friendly messages.",
            "useCases": [
                "Error Handling"
            ],
            "realTimeUseCases": [
                "NMG catches payment errors, logs to Sentry, shows friendly messages"
            ]
        },
        {
            "id": 72,
            "name": "React Lifecycle",
            "question": "React Life Cycle methods.",
            "answer": "Mounting: constructor > render > componentDidMount. Updating: new props/state > render > componentDidUpdate. Unmounting: componentWillUnmount. Deprecated: componentWillMount, componentWillReceiveProps. Modern: use Hooks (useEffect, useLayoutEffect). Lifecycle methods only in class components.",
            "useCases": [
                "Class Components"
            ],
            "realTimeUseCases": [
                "Legacy NMG components use lifecycle; new ones use Hooks"
            ]
        },
        {
            "id": 73,
            "name": "React Hooks Overview",
            "question": "What are Hooks in React?",
            "answer": "Hooks are functions that let you use React state and effects in functional components. Common Hooks: useState, useEffect, useContext, useReducer, useRef, useCallback, useMemo, useLayoutEffect. Benefits: cleaner code, easier testing, code reuse. Rules: call only from top-level, same order every render.",
            "useCases": [
                "Functional Components"
            ],
            "realTimeUseCases": [
                "NMG uses Hooks extensively in all modern components"
            ]
        },
        {
            "id": 74,
            "name": "Rules of Hooks",
            "question": "Rules of Hooks.",
            "answer": "1) Only call Hooks at top level (not inside loops, conditions). 2) Only call Hooks from React components or custom Hooks. Why: React relies on call order to match Hooks between renders. Breaking rules causes: wrong state updates, infinite loops, memory leaks. ESLint plugin enforces these rules.",
            "useCases": [
                "Best Practices"
            ],
            "realTimeUseCases": [
                "NMG developers follow Hook rules; linter warns about violations"
            ]
        },
        {
            "id": 75,
            "name": "List Hooks Methods",
            "question": "List Hooks methods.",
            "answer": "Basic: useState, useEffect, useContext. Advanced: useReducer, useRef, useCallback, useMemo, useLayoutEffect. Library-specific: useSelector, useDispatch (Redux), useParams (React Router). Custom Hooks: useFetch, useAuth, useCart. Total 10+ built-in Hooks + infinite custom Hooks.",
            "useCases": [
                "Hook Reference"
            ],
            "realTimeUseCases": [
                "NMG components use 5-7 Hooks per complex component"
            ]
        },
        {
            "id": 76,
            "name": "useState Hook",
            "question": "What is useState?",
            "answer": "useState allows functional components to have state. Syntax: const [value, setValue] = useState(initialValue). Returns: current value, function to update. Re-renders component when state changes. Rules: call at top level, same order every render. Can use multiple useState for different state values.",
            "useCases": [
                "State Management"
            ],
            "realTimeUseCases": [
                "NMG form inputs use useState for each field"
            ]
        },
        {
            "id": 77,
            "name": "Why use useState",
            "question": "Why use useState?",
            "answer": "useState enables functional components to have state without class components. Benefits: simpler syntax, can have multiple useState calls, easier to test, no this binding, works with other Hooks, cleaner code. useState revolutionized React by making functional components the recommended way.",
            "useCases": [
                "Functional State"
            ],
            "realTimeUseCases": [
                "useState eliminated need for class components in NMG"
            ]
        },
        {
            "id": 78,
            "name": "useState Internals",
            "question": "How useState works internally?",
            "answer": "React maintains a state array per component instance. On first render: useState creates state slot. On subsequent renders: React returns same slot in same order. Calling order matters: conditional useState changes order, wrong state returned. setValue triggers re-render. React batches multiple setState calls into single render.",
            "useCases": [
                "Understanding React"
            ],
            "realTimeUseCases": [
                "Understanding helps avoid bugs from conditional useState calls"
            ]
        },
        {
            "id": 79,
            "name": "useState eCommerce",
            "question": "Real-time use cases of useState in eCommerce.",
            "answer": "1) ProductCard: manage quantity, selected size/color. 2) Cart: visibility toggle, expanded items. 3) CheckoutForm: form inputs (email, address, payment). 4) FilterBar: selected filters. 5) Modal: open/close state. 6) Search: search input and results. 7) Pagination: current page. 8) Sorting: sort option. useState used extensively for all UI interactions.",
            "useCases": [
                "UI state"
            ],
            "realTimeUseCases": [
                "useState in NMG ProductCard, Cart, Checkout, Filters"
            ]
        },
        {
            "id": 80,
            "name": "useEffect Hook",
            "question": "What is useEffect?",
            "answer": "useEffect is a Hook that runs side effects after render. Syntax: useEffect(() => { effect code; return () => { cleanup } }, [dependencies]). Phases: Effect runs after mount/updates, cleanup runs before unmount or next effect, dependency array controls when effect runs. Replaces lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount).",
            "useCases": [
                "Side effects"
            ],
            "realTimeUseCases": [
                "useEffect fetches product data in NMG"
            ]
        },
        {
            "id": 81,
            "name": "Why useEffect",
            "question": "Why use useEffect?",
            "answer": "useEffect enables side effects in functional components without class methods. Benefits: handles both mount and update in one place, automatic cleanup, dependency array prevents unnecessary runs, cleaner syntax than lifecycle methods, easy to combine effects, works with async. Separates side effect logic from render logic.",
            "useCases": [
                "Effect Management"
            ],
            "realTimeUseCases": [
                "useEffect replaces componentDidMount/componentDidUpdate in NMG"
            ]
        },
        {
            "id": 82,
            "name": "useEffect No Dependency",
            "question": "What happens if dependency array is not given in useEffect?",
            "answer": "No dependency array: Effect runs after every render (mount + every update). Can cause: infinite loops, excessive API calls, memory leaks. Example: useEffect(() => { fetchData(); }) fetches on every render. Solution: Always provide dependency array. With []: runs once on mount. With [deps]: runs when deps change.",
            "useCases": [
                "Common mistake"
            ],
            "realTimeUseCases": [
                "Without deps array, API calls repeat in NMG"
            ]
        },
        {
            "id": 83,
            "name": "useEffect Empty Dependency",
            "question": "What happens if dependency array is empty?",
            "answer": "Empty array []: Effect runs once on component mount and cleanup runs on unmount. Perfect for one-time initialization: fetch initial data, set up subscriptions, initialize timers. Cleanup function important for subscriptions/timers. Example: useEffect(() => { subscribe(); return () => unsubscribe(); }, []) sets up once, cleans up on unmount.",
            "useCases": [
                "One-time setup"
            ],
            "realTimeUseCases": [
                "Fetch products on ProductList mount with useEffect(..., [])"
            ]
        },
        {
            "id": 84,
            "name": "useEffect With Dependencies",
            "question": "What happens if state/props are given as dependencies?",
            "answer": "Dependency array with values: Effect runs when any dependency changes. React compares new to previous. Example: useEffect(() => { fetchProduct(productId); }, [productId]) runs when productId changes. With multiple: [userId, filters] runs when either changes. Gotcha: object/array by reference always different. Solution: wrap in useMemo or restructure.",
            "useCases": [
                "Dependency tracking"
            ],
            "realTimeUseCases": [
                "useEffect runs on dependency changes in NMG"
            ]
        },
        {
            "id": 85,
            "name": "useEffect Cleanup",
            "question": "What is cleanup function in useEffect?",
            "answer": "Cleanup function (returned from useEffect) runs before next effect or on unmount. Used for: cancel subscriptions/listeners, clear timers, abort fetch requests, remove event listeners, close WebSocket connections. Without cleanup: memory leaks, multiple subscriptions. Example: return () => clearInterval(timer);",
            "useCases": [
                "Resource cleanup"
            ],
            "realTimeUseCases": [
                "useEffect cleanup prevents memory leaks in NMG"
            ]
        },
        {
            "id": 86,
            "name": "useEffect Use Cases",
            "question": "Real-time eCommerce use cases of useEffect.",
            "answer": "1) ProductList: fetch products on mount/filters change. 2) ProductDetail: fetch details when productId changes. 3) Cart: fetch data, subscribe. 4) Checkout: validate address, fetch shipping. 5) Header: track login, fetch notifications. 6) Search: debounce input, fetch results. 7) Analytics: track page views. 8) Payment: Stripe initialization. useEffect drives data fetching in NMG.",
            "useCases": [
                "Data flow"
            ],
            "realTimeUseCases": [
                "useEffect fetches products, orders, notifications in NMG"
            ]
        },
        {
            "id": 87,
            "name": "useEffect vs Lifecycle",
            "question": "Equivalents of useEffect to class lifecycle methods.",
            "answer": "useEffect replaces: 1) componentDidMount: useEffect(() => {...}, []) once on mount. 2) componentDidUpdate: useEffect(() => {...}, [deps]) on dependency change. 3) componentWillUnmount: useEffect(() => () => {...}) cleanup function. Class methods called at specific times; useEffect unifies them. Modern Hooks approach is cleaner.",
            "useCases": [
                "Migration from class"
            ],
            "realTimeUseCases": [
                "Understanding helps refactor class components to Hooks"
            ]
        },
        {
            "id": 88,
            "name": "useLayoutEffect",
            "question": "What is useLayoutEffect?",
            "answer": "useLayoutEffect is similar to useEffect but fires synchronously after DOM mutations and before browser paint. Timing: Component renders > useLayoutEffect runs (blocking) > Browser paints. Use for: measuring DOM, synchronous DOM adjustments (prevent flicker). Most effects should be useEffect. Rule: use useEffect first; switch to useLayoutEffect only if see flicker.",
            "useCases": [
                "DOM measurements"
            ],
            "realTimeUseCases": [
                "Measure dropdown position before paint in NMG modal"
            ]
        },
        {
            "id": 89,
            "name": "useRef",
            "question": "What is useRef?",
            "answer": "useRef returns a mutable ref object that persists across renders. Syntax: const ref = useRef(initialValue). Access: ref.current. Key difference from useState: changing ref.current doesn't trigger re-render. Use for: 1) Access DOM nodes (focus, select text). 2) Keep mutable values (timers). 3) Store non-render values.",
            "useCases": [
                "DOM access"
            ],
            "realTimeUseCases": [
                "Focus input after mount, store Stripe ref in checkout"
            ]
        },
        {
            "id": 90,
            "name": "useState vs useRef",
            "question": "Difference between useState and useRef.",
            "answer": "useState: Triggers re-render. Use for UI state. useRef: No re-render. Use for non-UI values. Example: form input value > useState (shows immediately); timer ID > useRef (doesn't need to show). Decision: if change should update UI, use useState; if change is internal (not UI), use useRef.",
            "useCases": [
                "State vs Ref"
            ],
            "realTimeUseCases": [
                "Form input: useState. Timer ID: useRef. Both in same component."
            ]
        },
        {
            "id": 91,
            "name": "useCallback",
            "question": "What is useCallback?",
            "answer": "useCallback memoizes a function so it returns the same function reference across renders (if dependencies unchanged). Syntax: const memoizedCallback = useCallback(() => { function body }, [dependencies]). Use for: passing callbacks to child components to prevent unnecessary re-renders. useCallback is optimization; use sparingly.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Memoize onChange callbacks in ProductList to prevent re-renders"
            ]
        },
        {
            "id": 92,
            "name": "useMemo",
            "question": "What is useMemo?",
            "answer": "useMemo memoizes a value so it recalculates only when dependencies change. Syntax: const memoizedValue = useMemo(() => { expensive calculation; return result; }, [dependencies]). Use for: expensive calculations, derived data, preventing child re-renders. Example: filter large list once, return same reference. Don't overuse; measure performance first.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Memoize filtered products list to prevent child re-renders in NMG"
            ]
        },
        {
            "id": 93,
            "name": "React Knowledge Summary",
            "question": "Summary of all React concepts covered.",
            "answer": "Fundamentals: React, JSX, Components, Virtual DOM, one-way binding. Components: Functional, Class, Props, State. Hooks: useState, useEffect, useContext, useReducer, useRef, useCallback, useMemo. Advanced: HOCs, Error Boundaries, Suspense, Custom Hooks. State Management: Context API, Redux. Data Fetching: Axios, fetch, useEffect. Performance: Memoization. Testing, Routing, Forms, Styling. This comprehensive knowledge covers production React development.",
            "useCases": [
                "Learning Path"
            ],
            "realTimeUseCases": [
                "NMG eCommerce uses all these concepts in production"
            ]
        },
        {
            "id": 94,
            "name": "Real DOM",
            "question": "What is Real DOM and how it works internally?",
            "answer": "Real DOM is the browser's document object model â€” the tree representation of UI elements. When you change the DOM directly the browser performs layout, paint, and compositing which can be expensive for many updates. React minimizes work on the real DOM by computing changes in the Virtual DOM and applying only minimal updates.",
            "useCases": [
                "Rendering"
            ],
            "realTimeUseCases": [
                "Final updates to the browser after virtual diffing"
            ]
        },
        {
            "id": 95,
            "name": "JSX",
            "question": "What is JSX?",
            "answer": "JSX is a syntax extension for JavaScript that looks like HTML and describes UI structure; under the hood it is transformed to React.createElement calls or similar by a compiler (Babel). It is optional but commonly used for readability and declarative UI.",
            "useCases": [
                "Templates"
            ],
            "realTimeUseCases": [
                "Component templates in product pages"
            ]
        },
        {
            "id": 96,
            "name": "How JSX works",
            "question": "How JSX works?",
            "answer": "JSX expressions are transpiled to JavaScript calls (e.g., React.createElement) which create React elements (virtual nodes). The transpiler also handles attributes and children conversions into JavaScript objects that React can reconciliate.",
            "useCases": [
                "Component authoring"
            ],
            "realTimeUseCases": [
                "Writing product card components"
            ]
        },
        {
            "id": 97,
            "name": "JSX browsers",
            "question": "Why JSX does not work directly in browsers?",
            "answer": "Browsers do not understand JSX syntax; it must be transformed to plain JavaScript (React.createElement calls or compiled functions) by tools like Babel or TypeScript before the bundle runs in the browser.",
            "useCases": [
                "Build step"
            ],
            "realTimeUseCases": [
                "Dev builds with Babel/TS compiling JSX to JS"
            ]
        },
        {
            "id": 98,
            "name": "Babel",
            "question": "What is Babel and why to use it?",
            "answer": "Babel is a JavaScript compiler that transforms modern JS/JSX/TypeScript syntax into browser-compatible JavaScript. Use it to enable JSX, ES modules, and modern language features in older browsers or build pipelines.",
            "useCases": [
                "Transpilation"
            ],
            "realTimeUseCases": [
                "Compiling JSX and modern ES features for production bundles"
            ]
        },
        {
            "id": 99,
            "name": "Webpack",
            "question": "What is Webpack? Why use it?",
            "answer": "Webpack is a module bundler that processes JS/CSS/assets and produces optimized bundles. It handles code splitting, loaders, plugins, and can optimize assets for production.",
            "useCases": [
                "Bundling"
            ],
            "realTimeUseCases": [
                "Creating optimized production bundles with code-splitting for product pages"
            ]
        },
        {
            "id": 100,
            "name": "webpack.config",
            "question": "How to configure webpack.config.js?",
            "answer": "A basic webpack.config defines entry, output, module.rules (loaders for JS/CSS/images), plugins (HTML, DefinePlugin), and optimization (splitChunks). For React apps use Babel loader for JSX and configure dev/prod modes.",
            "useCases": [
                "Build config"
            ],
            "realTimeUseCases": [
                "Customizing build for server-side rendering or vendor splitting"
            ]
        },
        {
            "id": 101,
            "name": "Functional Component",
            "question": "What is Functional Component?",
            "answer": "A functional component is a JavaScript function that returns React elements. With Hooks, functional components can hold state and side effects, replacing most class components.",
            "useCases": [
                "Component design"
            ],
            "realTimeUseCases": [
                "Presentational product cards implemented as functional components"
            ]
        },
        {
            "id": 102,
            "name": "Functional vs Class",
            "question": "Why to use Functional Components over Class Components?",
            "answer": "Functional components are simpler, avoid this binding, enable Hooks for state/effects, and generally lead to less boilerplate and clearer logic composition.",
            "useCases": [
                "Modern patterns"
            ],
            "realTimeUseCases": [
                "Refactoring legacy class components to hooks-based functional components"
            ]
        },
        {
            "id": 103,
            "name": "Benefits of Functional Components",
            "question": "What are benefits of Functional Components?",
            "answer": "Less boilerplate, easier testing, Hooks for reusable logic, better composition, and often smaller bundles. They also allow Compiler/runtime optimizations.",
            "useCases": [
                "Maintainability"
            ],
            "realTimeUseCases": [
                "Reusable hooks across product pages"
            ]
        },
        {
            "id": 104,
            "name": "Functional use cases",
            "question": "Real-time use cases of Functional Components in eCommerce project.",
            "answer": "ProductCard, FilterBar, CheckoutStep components â€” all can be functional components using Hooks for local state and effects.",
            "useCases": [
                "UI components"
            ],
            "realTimeUseCases": [
                "Product list, cart item, filter controls"
            ]
        },
        {
            "id": 105,
            "name": "Class Component",
            "question": "What is Class Component?",
            "answer": "A class component is a React component defined with ES6 classes extending React.Component; it supports lifecycle methods and state via this.state. Before Hooks, classes were required for stateful logic.",
            "useCases": [
                "Legacy code"
            ],
            "realTimeUseCases": [
                "Older admin panels or libraries using class-based components"
            ]
        },
        {
            "id": 106,
            "name": "When to use class",
            "question": "When to use Class Components instead of Functional Components?",
            "answer": "Today there are few reasons â€” mostly migrating legacy code or using libraries that require class lifecycles; otherwise prefer functional components with Hooks.",
            "useCases": [
                "Migration"
            ],
            "realTimeUseCases": [
                "Maintaining legacy components until refactor"
            ]
        },
        {
            "id": 107,
            "name": "Benefits of class",
            "question": "What are benefits of Class Components?",
            "answer": "Stable lifecycle method structure and familiarity in older codebases; some third-party libraries historically required class lifecycle hooks.",
            "useCases": [
                "Legacy interoperability"
            ],
            "realTimeUseCases": [
                "Compatibility with older component libraries"
            ]
        },
        {
            "id": 108,
            "name": "Class use cases",
            "question": "Real-time eCommerce use cases of Class Components.",
            "answer": "Legacy dashboard widgets or third-party integrations not yet migrated to Hooks.",
            "useCases": [
                "Legacy"
            ],
            "realTimeUseCases": [
                "Old admin widgets in maintenance mode"
            ]
        },
        {
            "id": 109,
            "name": "Controlled vs Uncontrolled",
            "question": "Difference between Controlled and Uncontrolled Components.",
            "answer": "Controlled components have their value controlled by React state (value + onChange). Uncontrolled components rely on DOM refs for current value. Controlled offers predictability; uncontrolled can be simpler for simple forms.",
            "useCases": [
                "Forms"
            ],
            "realTimeUseCases": [
                "Cart quantity inputs (controlled) vs file inputs (uncontrolled)"
            ]
        },
        {
            "id": 110,
            "name": "When Controlled vs Uncontrolled",
            "question": "When to use Controlled and Uncontrolled Components?",
            "answer": "Use controlled when you need validation, immediate UI sync, or complex form interactions. Use uncontrolled for simple, infrequently-read inputs to reduce re-renders.",
            "useCases": [
                "Form design"
            ],
            "realTimeUseCases": [
                "Checkout forms use controlled inputs for validation"
            ]
        },
        {
            "id": 111,
            "name": "State",
            "question": "What is State in React?",
            "answer": "State is internal data managed by a component (via useState/useReducer or this.state) that influences its rendering. State changes trigger re-renders.",
            "useCases": [
                "UI data"
            ],
            "realTimeUseCases": [
                "Cart item counts stored in state"
            ]
        },
        {
            "id": 112,
            "name": "Props",
            "question": "What is Props in React?",
            "answer": "Props are read-only inputs passed from parent to child components. They allow data flow down the component tree and make components reusable.",
            "useCases": [
                "Component APIs"
            ],
            "realTimeUseCases": [
                "Product details passed to ProductCard as props"
            ]
        },
        {
            "id": 113,
            "name": "State vs Props",
            "question": "Difference between State and Props.",
            "answer": "Props are external and immutable for the child; state is internal and mutable via setState/useState. Props come from parents; state is managed by the component.",
            "useCases": [
                "Component patterns"
            ],
            "realTimeUseCases": [
                "Parent passes product data via props; card manages local UI state"
            ]
        },
        {
            "id": 114,
            "name": "State Lifting",
            "question": "What is State Lifting?",
            "answer": "Lifting state means moving shared state up to the nearest common ancestor so multiple components can access and modify the same data via props.",
            "useCases": [
                "Shared state"
            ],
            "realTimeUseCases": [
                "Lifting selected filters state to a parent that renders product list and filter summary"
            ]
        },
        {
            "id": 115,
            "name": "Props Drilling",
            "question": "What is Props Drilling?",
            "answer": "Props drilling is passing props through intermediate components that don't need them just to reach a deeply nested component. It becomes unwieldy when many levels are involved.",
            "useCases": [
                "Anti-pattern"
            ],
            "realTimeUseCases": [
                "Passing user token many levels down to a deep modal component"
            ]
        },
        {
            "id": 116,
            "name": "Props Drilling issue",
            "question": "What is the issue with Props Drilling?",
            "answer": "It makes components tightly coupled, harder to refactor, and increases boilerplate for passing values through many levels.",
            "useCases": [
                "Maintainability"
            ],
            "realTimeUseCases": [
                "Difficulty refactoring header->nav->submenu data flows"
            ]
        },
        {
            "id": 117,
            "name": "Solve Props Drilling",
            "question": "How to solve Props Drilling?",
            "answer": "Use Context API, global state (Redux/Zustand), or component composition to avoid passing props through irrelevant intermediates.",
            "useCases": [
                "Patterns"
            ],
            "realTimeUseCases": [
                "Use Context for auth info rather than drilling through many components"
            ]
        },
        {
            "id": 118,
            "name": "React.createElement",
            "question": "What is React.createElement?",
            "answer": "React.createElement is the function that creates React elements (virtual nodes). JSX compiles to calls to React.createElement (or equivalent) which produce the object React uses for reconciliation.",
            "useCases": [
                "Runtime details"
            ],
            "realTimeUseCases": [
                "Understanding JSX compilation when debugging render issues"
            ]
        },
        {
            "id": 119,
            "name": "Component vs createElement",
            "question": "Difference between Component and React.createElement.",
            "answer": "A Component is a function/class that returns elements; React.createElement constructs element objects. Components are user-defined; createElement is the primitive used by React to represent UI nodes.",
            "useCases": [
                "Conceptual"
            ],
            "realTimeUseCases": [
                "Debugging element trees in devtools"
            ]
        },
        {
            "id": 120,
            "name": "Pure Component",
            "question": "What is Pure Component in React?",
            "answer": "A PureComponent is a class that implements shouldComponentUpdate with a shallow props/state comparison; in functional code you can use React.memo for similar behavior. It avoids unnecessary re-renders for pure props.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Memoizing product list items that receive immutable props"
            ]
        },
        {
            "id": 121,
            "name": "Pure problem solved",
            "question": "What problem Pure Component solves?",
            "answer": "It reduces unnecessary re-renders by skipping updates when props/state did not change shallowly, improving performance for expensive renders.",
            "useCases": [
                "Perf optimization"
            ],
            "realTimeUseCases": [
                "Large product grids where many items don't change"
            ]
        },
        {
            "id": 122,
            "name": "When use Pure",
            "question": "When to use Pure Component?",
            "answer": "When component renders are expensive and props are mostly immutable/primitives; measure with profiler first.",
            "useCases": [
                "Optimization"
            ],
            "realTimeUseCases": [
                "Memoize header icons or product tiles"
            ]
        },
        {
            "id": 123,
            "name": "Pure eCommerce",
            "question": "Real-time eCommerce use cases of Pure Component.",
            "answer": "ProductCard and Category tiles benefit from memoization to avoid re-render when unrelated items update.",
            "useCases": [
                "Product rendering"
            ],
            "realTimeUseCases": [
                "Memoized product tiles in long lists"
            ]
        },
        {
            "id": 124,
            "name": "Higher Order Component",
            "question": "What is Higher Order Component?",
            "answer": "HOC is a function that takes a component and returns a new component with added behavior (e.g., withAuth, withLoading). Before Hooks, HOCs were common for logic reuse.",
            "useCases": [
                "Code reuse"
            ],
            "realTimeUseCases": [
                "withAuth HOC to guard routes in older code"
            ]
        },
        {
            "id": 125,
            "name": "HOC problem",
            "question": "What problem HOC solves?",
            "answer": "HOCs abstract repeated logic (data fetching, subscriptions) and inject props or behavior into wrapped components.",
            "useCases": [
                "Cross-cutting concerns"
            ],
            "realTimeUseCases": [
                "Logging, analytics or permission checks added via HOCs"
            ]
        },
        {
            "id": 126,
            "name": "When to use HOC",
            "question": "When to use HOC?",
            "answer": "HOCs are useful when needing to reuse behavior across many components; today custom Hooks or component composition are often preferred.",
            "useCases": [
                "Reuse"
            ],
            "realTimeUseCases": [
                "Legacy wrappers adding feature flags to components"
            ]
        },
        {
            "id": 127,
            "name": "HOC eCommerce",
            "question": "Real-time eCommerce use cases of HOC.",
            "answer": "Wrapping pages with analytics or A/B experiment logic via HOC; or adding auth gating in admin sections.",
            "useCases": [
                "Instrumentation"
            ],
            "realTimeUseCases": [
                "withExperiment HOC for feature flags"
            ]
        },
        {
            "id": 128,
            "name": "Controlled Component",
            "question": "What is Controlled Component?",
            "answer": "A controlled component has its value driven by React state, with an onChange handler updating state; the component value is single-source-of-truth in React.",
            "useCases": [
                "Form control"
            ],
            "realTimeUseCases": [
                "Checkout inputs with live validation"
            ]
        },
        {
            "id": 129,
            "name": "Why Controlled",
            "question": "Why to use Controlled Component?",
            "answer": "Controlled components allow immediate validation, easier testing, and predictable values across the app.",
            "useCases": [
                "Validation"
            ],
            "realTimeUseCases": [
                "Ensuring coupon codes validate as user types"
            ]
        },
        {
            "id": 130,
            "name": "Controlled eCommerce",
            "question": "Real-time use cases of Controlled Component in eCommerce.",
            "answer": "Checkout form fields, address auto-complete, quantity inputs requiring validation and sync.",
            "useCases": [
                "Checkout"
            ],
            "realTimeUseCases": [
                "Live validation of card number and CVV"
            ]
        },
        {
            "id": 131,
            "name": "Uncontrolled Component",
            "question": "What is Uncontrolled Component?",
            "answer": "Uncontrolled components rely on DOM nodes to manage values (refs) instead of React state; useful for non-critical inputs or third-party integrations.",
            "useCases": [
                "Simple inputs"
            ],
            "realTimeUseCases": [
                "File uploads handled via native input refs"
            ]
        },
        {
            "id": 132,
            "name": "Why Uncontrolled",
            "question": "Why to use Uncontrolled Component?",
            "answer": "They can reduce re-renders and be simpler when you don't need live value updates in React state.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Large forms where only final submit is needed"
            ]
        },
        {
            "id": 133,
            "name": "Uncontrolled eCommerce",
            "question": "Real-time eCommerce use cases of Uncontrolled Component.",
            "answer": "File inputs for product images in admin tools or integrations where immediate validation is not necessary.",
            "useCases": [
                "Admin features"
            ],
            "realTimeUseCases": [
                "Image upload forms in seller portal"
            ]
        },
        {
            "id": 134,
            "name": "useEffect internals",
            "question": "How useEffect works internally?",
            "answer": "React schedules effects to run after painting; effects are tracked with their dependency lists and run only when dependencies change. Cleanup functions run before the next effect or on unmount. React batches state updates and may optimize effect invocation timing.",
            "useCases": [
                "Side-effect understanding"
            ],
            "realTimeUseCases": [
                "Implementing safe subscriptions and cancellations in product polling"
            ]
        },
        {
            "id": 135,
            "name": "axios vs fetch opinion",
            "question": "Which is good axios or fetch and why?",
            "answer": "Axios offers convenience: automatic JSON transforms, interceptors, timeouts, and cancelation helpers. Fetch is built-in and minimal. For production apps with auth/token flows, Axios often simplifies implementation; for tiny scripts, fetch is fine.",
            "useCases": [
                "HTTP client choice"
            ],
            "realTimeUseCases": [
                "NMG uses Axios for interceptors and token refresh"
            ]
        },
        {
            "id": 136,
            "name": "useContext",
            "question": "What is useContext?",
            "answer": "useContext is a Hook to access the nearest Provider's value for a Context object. It simplifies consuming context without render props or Consumers.",
            "useCases": [
                "Global access"
            ],
            "realTimeUseCases": [
                "Accessing current user or theme in header components"
            ]
        },
        {
            "id": 137,
            "name": "Why useContext",
            "question": "Why use useContext?",
            "answer": "It avoids prop drilling for values that many components need (like auth, theme) and keeps code concise.",
            "useCases": [
                "Convenience"
            ],
            "realTimeUseCases": [
                "User info in nav and account areas"
            ]
        },
        {
            "id": 138,
            "name": "useContext internals",
            "question": "How useContext works internally?",
            "answer": "useContext reads the current context value from React's context registry associated with the rendering tree; when the Provider value changes, React re-renders consumers.",
            "useCases": [
                "Behavior understanding"
            ],
            "realTimeUseCases": [
                "Understanding performance implications when provider value changes frequently"
            ]
        },
        {
            "id": 139,
            "name": "useContext eCommerce",
            "question": "Real-time eCommerce use cases of useContext.",
            "answer": "User auth state, theme, currency and language contexts shared across many components.",
            "useCases": [
                "Global state"
            ],
            "realTimeUseCases": [
                "CurrencyContext to format prices across product pages"
            ]
        },
        {
            "id": 140,
            "name": "Redux principles",
            "question": "Principles of Redux architecture.",
            "answer": "Single source of truth (store), state is read-only (actions), changes via pure reducers, predictable state transitions, and optional middleware for side-effects.",
            "useCases": [
                "App state"
            ],
            "realTimeUseCases": [
                "Cart and product store with actions and reducers"
            ]
        },
        {
            "id": 141,
            "name": "Redux lifecycle",
            "question": "Lifecycle components of Redux.",
            "answer": "Typical lifecycle: dispatch action -> middleware intercept (optional) -> reducer updates store -> subscribers (components) re-render. Async flows often use thunks/sagas for side effects.",
            "useCases": [
                "Flow understanding"
            ],
            "realTimeUseCases": [
                "Order placement flow with middleware for API calls"
            ]
        },
        {
            "id": 142,
            "name": "Redux flow",
            "question": "Redux architecture flow end-to-end.",
            "answer": "User triggers UI action -> component dispatches an action -> middleware handles async (if any) -> reducer produces new state -> store notifies subscribers -> UI updates. Persist and hydration may exist for caching.",
            "useCases": [
                "End-to-end flow"
            ],
            "realTimeUseCases": [
                "Cart add-to-cart triggers API and updates UI"
            ]
        },
        {
            "id": 143,
            "name": "Redux internal lifecycle",
            "question": "Redux architecture internal life cycle.",
            "answer": "Internally Redux reduces by invoking reducers with current state and action, creates new state objects (immutably), and notifies subscribers. Middleware wraps dispatch to add behaviors like logging or async handling.",
            "useCases": [
                "Deep internals"
            ],
            "realTimeUseCases": [
                "Custom middleware for analytics on actions"
            ]
        },
        {
            "id": 144,
            "name": "Redux Middlewares",
            "question": "What are Middlewares in Redux?",
            "answer": "Middlewares are functions that wrap dispatch to intercept actions for logging, async control, routing, or error handling (e.g., thunk, saga, logger). They enhance dispatch behavior.",
            "useCases": [
                "Async & logging"
            ],
            "realTimeUseCases": [
                "Auth token refresh implemented as middleware"
            ]
        },
        {
            "id": 145,
            "name": "Types of Middlewares",
            "question": "Types of Middlewares in Redux.",
            "answer": "Common types: thunk (function-based), saga (generator-based), logger, promise middleware, and custom middlewares for analytics or batching.",
            "useCases": [
                "Selection"
            ],
            "realTimeUseCases": [
                "Thunk for simple async, saga for complex flows like payments"
            ]
        },
        {
            "id": 146,
            "name": "Thunk vs Saga opinion",
            "question": "Which one is good Thunk or Saga and why?",
            "answer": "Thunk is simpler and good for straightforward async flows. Saga provides more control (cancel, retry, complex orchestration) but has higher complexity. Choose Thunk for most use-cases; adopt Saga for complex, long-running side effects.",
            "useCases": [
                "Middleware choice"
            ],
            "realTimeUseCases": [
                "Thunk for product fetch; Saga for payment flow orchestration"
            ]
        }
    ],
    "Redux": [
        {
            "id": 1,
            "name": "What is Redux",
            "question": "What is Redux?",
            "answer": "Redux is a predictable state container for JavaScript apps that centralizes application state in a single store and enforces unidirectional data flow.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 2,
            "name": "Why to use Redux",
            "question": "Why to use Redux?",
            "answer": "Use Redux to manage complex app state across many components, enable time-travel debugging, centralize logic, and make state changes predictable and testable.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 3,
            "name": "When to use Redux in a project",
            "question": "When to use Redux in a project?",
            "answer": "Use Redux when app state is shared by many components, when state changes are complex, or when you need predictable state transitions and tooling like DevTools.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 4,
            "name": "What problem does Redux solve",
            "question": "What problem does Redux solve?",
            "answer": "Redux solves state management complexity by providing a single source of truth, explicit update patterns via actions/reducers, and easier debugging.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 5,
            "name": "What are the core principles of Redux",
            "question": "What are the core principles of Redux?",
            "answer": "Core principles: single source of truth (one store), state is read-only (changes via actions), and changes are made with pure reducers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 6,
            "name": "What are the Components parts of Redux Architecture",
            "question": "What are the Components (parts) of Redux Architecture?",
            "answer": "Components: Store (holds state), Actions (descriptions of changes), Reducers (pure functions to update state), Middleware (side-effect handling), and View layer (subscribes to store).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 7,
            "name": "What is a Store in Redux",
            "question": "What is a Store in Redux?",
            "answer": "Store holds the application state tree, provides getState(), dispatch(action), and subscribe(listener). It is created with reducers and enhancers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 8,
            "name": "What is an Action in Redux",
            "question": "What is an Action in Redux?",
            "answer": "Action is a plain object describing an intention to change state, usually with a `type` field and optional payload.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 9,
            "name": "What is a Reducer in Redux",
            "question": "What is a Reducer in Redux?",
            "answer": "Reducer is a pure function (state, action) => newState that determines how state changes in response to actions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 10,
            "name": "What is a Root Reducer",
            "question": "What is a Root Reducer?",
            "answer": "Root reducer combines multiple slice reducers (via combineReducers) into a single reducer for the store.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 11,
            "name": "What is the Global State in Redux",
            "question": "What is the Global State in Redux?",
            "answer": "Global state is the single source of truth in Redux: the state tree stored in the store that all parts of the app can access.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 12,
            "name": "How Redux updates the state internally",
            "question": "How Redux updates the state internally?",
            "answer": "Redux updates state by dispatching actions; middleware can intercept actions; reducers compute the next state immutably; the store notifies subscribers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 13,
            "name": "What is the flow of Redux Architecture",
            "question": "What is the flow of Redux Architecture?",
            "answer": "Flow: View dispatches action -> Middleware (optional) intercepts -> Action reaches Reducer -> Reducer returns new state -> Store updates -> View re-renders from new state.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 14,
            "name": "Explain stepbystep how Redux works internally",
            "question": "Explain step-by-step how Redux works internally.",
            "answer": "Step-by-step: 1) create store with root reducer; 2) component dispatches action; 3) middleware can handle side-effects; 4) reducer computes next state; 5) store updates and notifies subscribers; 6) UI reads new state and updates.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 15,
            "name": "How to implement Redux in React JS stepbystep",
            "question": "How to implement Redux in React JS step-by-step?",
            "answer": "Implement Redux in React: install redux & react-redux, create reducers and rootReducer, create store (optionally with middleware), wrap App with <Provider store={store}>, use useSelector/useDispatch or connect() to access state and dispatch actions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 16,
            "name": "What is the difference between Redux and Context API",
            "question": "What is the difference between Redux and Context API?",
            "answer": "Context is for passing data through component tree; Redux is a full state management solution with predictable updates, middleware, and devtools. Context is simpler for light use-cases; Redux better for complex state logic.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 17,
            "name": "What is the difference between Redux and Redux Toolkit",
            "question": "What is the difference between Redux and Redux Toolkit?",
            "answer": "Redux Toolkit (RTK) is the official, opinionated set of utilities to simplify Redux: reduces boilerplate, provides createSlice, configureStore, and includes best-practices like Immer and DevTools by default.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 18,
            "name": "What are the advantages of using Redux",
            "question": "What are the advantages of using Redux?",
            "answer": "Advantages: predictable state updates, central store, easier debugging/time-travel, middleware ecosystem, testability, and separation of concerns.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 19,
            "name": "What are the disadvantages of Redux",
            "question": "What are the disadvantages of Redux?",
            "answer": "Disadvantages: boilerplate (mitigated by RTK), added complexity for small apps, learning curve, possible overuse for simple state needs.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 20,
            "name": "What is connect in Redux",
            "question": "What is connect() in Redux?",
            "answer": "connect() is a HOC from react-redux that maps state and dispatch to component props (older API); newer apps prefer hooks (useSelector/useDispatch).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 21,
            "name": "What is useSelector in Redux",
            "question": "What is useSelector() in Redux?",
            "answer": "useSelector(selector) is a hook to read values from the Redux store and subscribe the component to updates of that selected value.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 22,
            "name": "What is useDispatch in Redux",
            "question": "What is useDispatch() in Redux?",
            "answer": "useDispatch() returns the store's dispatch function so components can dispatch actions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 23,
            "name": "What is storegetState",
            "question": "What is store.getState()?",
            "answer": "store.getState() returns the current state tree held by the Redux store.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 24,
            "name": "What is storesubscribe",
            "question": "What is store.subscribe()?",
            "answer": "store.subscribe(listener) registers a callback to be invoked whenever the state changes; returns an unsubscribe function.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 25,
            "name": "How to fetch updated state from Redux to React components",
            "question": "How to fetch updated state from Redux to React components?",
            "answer": "Use react-redux hooks: useSelector to select state slices; connect() with mapStateToProps is alternative. Ensure selectors are memoized for perf.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 26,
            "name": "Where to keep API integration logic in Redux architecture",
            "question": "Where to keep API integration logic in Redux architecture?",
            "answer": "Keep API logic in thunks/async actions, RTK Query endpoints, or separate services. Avoid placing heavy logic in reducers; use middleware for side-effects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 27,
            "name": "Where to keep Thunks or Sagas in Redux folder structure",
            "question": "Where to keep Thunks or Sagas in Redux folder structure?",
            "answer": "Place thunks/sagas under state feature folders, e.g., features/products/thunks.js or features/products/sagas.js, and import them into store configuration.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 28,
            "name": "What is Middleware in Redux",
            "question": "What is Middleware in Redux?",
            "answer": "Middleware is a way to extend Redux with custom behavior between dispatch and reducer: ({getState, dispatch}) => next => action.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 29,
            "name": "Why to use Middleware in Redux",
            "question": "Why to use Middleware in Redux?",
            "answer": "Middleware handles side-effects (async), logging, routing, analytics, and action transformations without polluting reducers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 30,
            "name": "When to use Middleware in Redux",
            "question": "When to use Middleware in Redux?",
            "answer": "Use middleware when dealing with async calls, logging, conditional dispatch, or cross-cutting concerns like retries or caching.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 31,
            "name": "In which scenarios Middlewares are required in Redux",
            "question": "In which scenarios Middlewares are required in Redux?",
            "answer": "Scenarios: async API calls, optimistic updates, logging, crash reporting, authentication token refresh, complex side-effect orchestration.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 32,
            "name": "What are the types of Middlewares in Redux",
            "question": "What are the types of Middlewares in Redux?",
            "answer": "Common types: logging, async (thunk), saga, observable, promise middleware, serializability checks, custom analytics middleware.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 33,
            "name": "What is Redux Logger Middleware",
            "question": "What is Redux Logger Middleware?",
            "answer": "Redux Logger logs actions and state before/after each dispatch, helping debug state transitions in development.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 34,
            "name": "What is Redux Thunk Middleware",
            "question": "What is Redux Thunk Middleware?",
            "answer": "Redux Thunk allows action creators to return functions (thunks) that receive dispatch/getState for async logic and conditional dispatching.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 35,
            "name": "What is Redux Saga Middleware",
            "question": "What is Redux Saga Middleware?",
            "answer": "Redux Saga middleware runs generator-based sagas to handle complex async flows using yield effects for clearer control flow and testability.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 36,
            "name": "What is Redux Observable Middleware",
            "question": "What is Redux Observable Middleware?",
            "answer": "Redux Observable integrates RxJS with Redux to express async flows as observable streams and operators, great for complex event handling.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 37,
            "name": "What is Redux Promise Middleware",
            "question": "What is Redux Promise Middleware?",
            "answer": "Promise middleware handles actions that carry promises by dispatching pending/fulfilled/rejected actions automatically.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 38,
            "name": "What is Redux Thunk",
            "question": "What is Redux Thunk?",
            "answer": "Redux Thunk is a simple middleware enabling async logic in action creators by returning functions instead of plain actions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 39,
            "name": "Why to use Redux Thunk",
            "question": "Why to use Redux Thunk?",
            "answer": "Use Thunk for straightforward async tasks like fetching data, simple control flow, and easy migration from synchronous action creators.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 40,
            "name": "How Redux Thunk works internally",
            "question": "How Redux Thunk works internally?",
            "answer": "Thunk checks if dispatched item is function: if so, calls it with dispatch and getState; otherwise passes action to next middleware/reducer.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 41,
            "name": "What is the syntax of Redux Thunk",
            "question": "What is the syntax of Redux Thunk?",
            "answer": "Basic thunk: const fetchData = () => async (dispatch, getState) => { dispatch(start()); const data = await api(); dispatch(success(data)); }",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 42,
            "name": "When to use Redux Thunk",
            "question": "When to use Redux Thunk?",
            "answer": "Use Redux when app state is shared by many components, when state changes are complex, or when you need predictable state transitions and tooling like DevTools.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 43,
            "name": "What are the use cases of Redux Thunk",
            "question": "What are the use cases of Redux Thunk?",
            "answer": "Use cases: fetching resources, conditional dispatching, simple retries, optimistic updates orchestrated in action creators.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 44,
            "name": "In which scenarios did you use Redux Thunk in your eCommerce",
            "question": "In which scenarios did you use Redux Thunk in your eCommerce project?",
            "answer": "Example: used Thunk to fetch product lists, cart operations, and handle auth flows where simple sequential async logic sufficed.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 45,
            "name": "What are the advantages of Redux Thunk",
            "question": "What are the advantages of Redux Thunk?",
            "answer": "Advantages: simple API, minimal boilerplate, easy to learn, compatible with existing action creators.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 46,
            "name": "What are the limitations of Redux Thunk",
            "question": "What are the limitations of Redux Thunk?",
            "answer": "Limitations: can lead to scattered async logic, harder to test complex flows, and becomes unwieldy for complex orchestrations.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 47,
            "name": "What is the main difference between Redux Thunk and Redux Sa",
            "question": "What is the main difference between Redux Thunk and Redux Saga?",
            "answer": "Thunk uses functions for simple async; Saga uses generator functions for declarative side-effect management and powerful control flows (cancellation, concurrency).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 48,
            "name": "If Redux Thunk exists why do we need Redux Saga",
            "question": "If Redux Thunk exists, why do we need Redux Saga?",
            "answer": "Short answer: If Redux Thunk exists, why do we need Redux Saga?",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 49,
            "name": "What is Redux Saga",
            "question": "What is Redux Saga?",
            "answer": "Redux Saga is middleware using ES6 generators to manage complex async flows as sagas with declarative effects.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 50,
            "name": "Why to use Redux Saga",
            "question": "Why to use Redux Saga?",
            "answer": "Use Saga for advanced side-effect handling, long-running processes, orchestrating multiple async tasks, and cancellation support.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 51,
            "name": "When to use Redux Saga",
            "question": "When to use Redux Saga?",
            "answer": "Use Redux when app state is shared by many components, when state changes are complex, or when you need predictable state transitions and tooling like DevTools.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 52,
            "name": "What are the topicsconcepts in Redux Saga",
            "question": "What are the topics/concepts in Redux Saga?",
            "answer": "Key concepts: sagas (watchers/workers), effects (call, put, take, fork, cancel), takeEvery/takeLatest, channels, and testing sagas.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 53,
            "name": "What are the advantages of Redux Saga over Redux Thunk",
            "question": "What are the advantages of Redux Saga over Redux Thunk?",
            "answer": "Saga advantages: declarative effects, better control over concurrency, cancellation, easier to test complex flows, improved composition.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 54,
            "name": "What are the use cases of Redux Saga",
            "question": "What are the use cases of Redux Saga?",
            "answer": "Use cases: payment flows, background sync, complex retries/backoff, websockets management, orchestrating multiple API calls.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 55,
            "name": "Where did you use Redux Saga in your eCommerce project",
            "question": "Where did you use Redux Saga in your eCommerce project?",
            "answer": "Example: used Saga for checkout flow orchestration, payment retries, and websocket order updates where complex orchestration was needed.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 56,
            "name": "What is the syntax of Redux Saga",
            "question": "What is the syntax of Redux Saga?",
            "answer": "Saga example: function* worker(action){ try{ const res = yield call(api, action.payload); yield put({type: \"SUCCESS\", payload: res}); } catch(e){ yield put({type:\"FAIL\", error: e}); } } function* watcher(){ yield takeEvery(\"REQUEST\", worker); }",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 57,
            "name": "How Redux Saga works internally",
            "question": "How Redux Saga works internally?",
            "answer": "Sagas yield effect objects to the middleware which interprets them (call, put, take) and runs corresponding async operations, enabling the generator to pause/resume.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 58,
            "name": "What is a Saga Watcher",
            "question": "What is a Saga Watcher?",
            "answer": "Watcher listens for dispatched actions (e.g., takeEvery/takeLatest) and spawns worker sagas to handle those actions.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 59,
            "name": "What is a Saga Worker",
            "question": "What is a Saga Worker?",
            "answer": "Worker is the saga that performs the actual side-effect (API call, dispatch actions) often invoked by a watcher.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 60,
            "name": "What are Effects in Redux Saga",
            "question": "What are Effects in Redux Saga?",
            "answer": "Effects are plain objects representing instructions (call, put, take, fork, cancel) that saga middleware interprets and executes.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 61,
            "name": "What is call put takeEvery takeLatest delay fork cancel",
            "question": "What is call(), put(), takeEvery(), takeLatest(), delay(), fork(), cancel()?",
            "answer": "call(fn,args): invoke function; put(action): dispatch action; takeEvery(pattern,worker): spawn worker for each action; takeLatest: cancel previous and keep latest; delay(ms): wait; fork: non-blocking task spawn; cancel: cancel forked task.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 62,
            "name": "What is the flow of implementing Redux Saga",
            "question": "What is the flow of implementing Redux Saga?",
            "answer": "Flow: write worker sagas, write watcher sagas, combine sagas in rootSaga, run saga middleware via sagaMiddleware.run(rootSaga) in store configuration.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 63,
            "name": "How to combine Redux Thunk and Redux Saga in the same app",
            "question": "How to combine Redux Thunk and Redux Saga in the same app?",
            "answer": "You can apply both middleware when creating store: applyMiddleware(thunk, sagaMiddleware). Use one for specific features; avoid conflicting responsibilities.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 64,
            "name": "What is Redux Toolkit RTK",
            "question": "What is Redux Toolkit (RTK)?",
            "answer": "Redux Toolkit (RTK) is the official, opinionated Redux toolset that simplifies store setup, reducers, and common patterns with createSlice, configureStore, and createAsyncThunk.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 65,
            "name": "Why to use Redux Toolkit",
            "question": "Why to use Redux Toolkit?",
            "answer": "Use RTK to reduce boilerplate, prevent common mistakes, include good defaults (Immer, DevTools), and speed up development.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 66,
            "name": "When to use Redux Toolkit",
            "question": "When to use Redux Toolkit?",
            "answer": "Use Redux when app state is shared by many components, when state changes are complex, or when you need predictable state transitions and tooling like DevTools.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 67,
            "name": "What problems does Redux Toolkit solve",
            "question": "What problems does Redux Toolkit solve?",
            "answer": "RTK solves boilerplate, encourages immutable updates via Immer, provides standardized patterns (slices, thunks), and integrates DevTools and middleware.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 68,
            "name": "What are the benefits of Redux Toolkit over normal Redux",
            "question": "What are the benefits of Redux Toolkit over normal Redux?",
            "answer": "Benefits: less boilerplate, built-in best practices, standardized APIs (createSlice, configureStore), built-in immutability via Immer, and RTK Query for data fetching.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 69,
            "name": "What is createSlice in Redux Toolkit",
            "question": "What is createSlice() in Redux Toolkit?",
            "answer": "createSlice simplifies reducer creation by defining initial state, reducers, and auto-generating action creators and types.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 70,
            "name": "What is configureStore in Redux Toolkit",
            "question": "What is configureStore() in Redux Toolkit?",
            "answer": "configureStore wraps createStore with good defaults: sets up thunk, immutable/serializable middleware, DevTools, and accepts reducers and enhancers.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 71,
            "name": "What is createAsyncThunk in Redux Toolkit",
            "question": "What is createAsyncThunk() in Redux Toolkit?",
            "answer": "createAsyncThunk simplifies async logic by auto-generating pending/fulfilled/rejected action types and handling dispatch lifecycle for async calls.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 72,
            "name": "What is RTK Query in Redux Toolkit",
            "question": "What is RTK Query in Redux Toolkit?",
            "answer": "RTK Query is a data fetching and caching solution built into RTK that simplifies fetching, caching, invalidation, and auto-generated hooks.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 73,
            "name": "What is the flow of implementing Redux Toolkit",
            "question": "What is the flow of implementing Redux Toolkit?",
            "answer": "Flow: define slices with createSlice, combine slices in configureStore, use createAsyncThunk for async operations or RTK Query, then use useSelector/useDispatch in components.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 74,
            "name": "What are realtime use cases of Redux Toolkit",
            "question": "What are real-time use cases of Redux Toolkit?",
            "answer": "Use RTK for CRUD apps, forms, caching API responses, optimistic updates, and replacing verbose reducer/action boilerplate.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 75,
            "name": "Where did you use Redux Toolkit in your eCommerce project",
            "question": "Where did you use Redux Toolkit in your eCommerce project?",
            "answer": "Example: used RTK to manage product slices, cart logic, and RTK Query for product list caching and auto refetch on focus.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 76,
            "name": "What is the difference between Reducer and Slice in RTK",
            "question": "What is the difference between Reducer and Slice in RTK?",
            "answer": "A slice bundles reducer logic + actions for a feature; reducer is the function alone. createSlice creates reducer plus action creators/types automatically.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 77,
            "name": "How does createSlice reduce boilerplate code",
            "question": "How does createSlice reduce boilerplate code?",
            "answer": "createSlice auto-generates action types and creators and lets you write mutable-looking code using Immer while producing immutable updates.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 78,
            "name": "How Redux Toolkit handles immutability using Immer",
            "question": "How Redux Toolkit handles immutability using Immer?",
            "answer": "Short answer: How Redux Toolkit handles immutability using Immer?",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 79,
            "name": "How to structure Redux Toolkit folder architecture in real p",
            "question": "How to structure Redux Toolkit folder architecture in real projects?",
            "answer": "Short answer: How to structure Redux Toolkit folder architecture in real projects?",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 80,
            "name": "How to integrate API calls in Redux Toolkit",
            "question": "How to integrate API calls in Redux Toolkit?",
            "answer": "Use createAsyncThunk for ad-hoc async flows or RTK Query for standardized, cache-first data fetching with auto-generated hooks and cache invalidation.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 81,
            "name": "What is the difference between Thunk and createAsyncThunk",
            "question": "What is the difference between Thunk and createAsyncThunk?",
            "answer": "createAsyncThunk standardizes async lifecycle and generates action types for pending/fulfilled/rejected; thunk is a general function pattern with more manual wiring.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 82,
            "name": "What are the benefits of createAsyncThunk",
            "question": "What are the benefits of createAsyncThunk?",
            "answer": "Benefits: less boilerplate, consistent action types, auto dispatch of lifecycle actions, built-in error serialization support and integration with RTK.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 83,
            "name": "How to write reducers for async lifecycle pending fulfilled ",
            "question": "How to write reducers for async lifecycle: pending, fulfilled, rejected?",
            "answer": "Handle createAsyncThunk lifecycle in extraReducers: builder.addCase(thunk.pending), .addCase(thunk.fulfilled), .addCase(thunk.rejected) to update state accordingly.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 84,
            "name": "Where to keep ThunksSagas in Redux Toolkit",
            "question": "Where to keep Thunks/Sagas in Redux Toolkit?",
            "answer": "Short answer: Where to keep Thunks/Sagas in Redux Toolkit?",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 85,
            "name": "How to connect Redux Toolkit store to React components",
            "question": "How to connect Redux Toolkit store to React components?",
            "answer": "Wrap app in <Provider store={store}> created with configureStore. Use useSelector/useDispatch or RTK Query generated hooks to access/modify state.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 86,
            "name": "How to fetch state using useSelector with RTK",
            "question": "How to fetch state using useSelector with RTK?",
            "answer": "useSelector(state => state.featureName.someValue) selects state slices; use memoized selectors (reselect) for performance.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 87,
            "name": "How to dispatch actions using useDispatch with RTK",
            "question": "How to dispatch actions using useDispatch with RTK?",
            "answer": "const dispatch = useDispatch(); dispatch(slice.actions.someAction(payload)) or dispatch(createAsyncThunkAction()).",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 88,
            "name": "How to optimize state updates in Redux Toolkit",
            "question": "How to optimize state updates in Redux Toolkit?",
            "answer": "Short answer: How to optimize state updates in Redux Toolkit?",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 89,
            "name": "What is the difference between RTK Query and Thunk",
            "question": "What is the difference between RTK Query and Thunk?",
            "answer": "RTK Query is a specialized data-fetching/cache layer with auto-hooks and caching; thunks are general-purpose async functions you write manually.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 90,
            "name": "What is the difference between RTK Query and Axios",
            "question": "What is the difference between RTK Query and Axios?",
            "answer": "Axios is an HTTP client; RTK Query builds on fetch/axios to add caching, invalidation, and auto-generated hooksâ€”it is higher-level than raw HTTP clients.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 91,
            "name": "What is Serializability Middleware in RTK",
            "question": "What is Serializability Middleware in RTK?",
            "answer": "Serializability middleware checks actions/state for non-serializable values to ensure actions/state can be persisted and DevTools work reliably.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 92,
            "name": "What is Immutable Check Middleware",
            "question": "What is Immutable Check Middleware?",
            "answer": "Immutable check middleware warns when state is mutated between dispatches, helping catch accidental mutations during development.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 93,
            "name": "What is DevTools Enhancer built into RTK",
            "question": "What is DevTools Enhancer built into RTK?",
            "answer": "RTK configures Redux DevTools enhancer by default for development to enable time-travel debugging and action/state inspection.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 94,
            "name": "How Redux Toolkit improves performance",
            "question": "How Redux Toolkit improves performance?",
            "answer": "RTK improves DX and reduces bugs; performance improvements come from recommended patterns, Immer optimizations, RTK Query caching, and encouraging normalized state.",
            "useCases": [],
            "realTimeUseCases": []
        },
        {
            "id": 95,
            "name": "What is the recommended Redux architecture by the Redux Team",
            "question": "What is the recommended Redux architecture by the Redux Team?",
            "answer": "Redux team recommends feature-folder structure (ducks pattern / features), use of RTK createSlice/configureStore, keeping async logic in thunks/RTK Query, and keeping UI state local.",
            "useCases": [],
            "realTimeUseCases": []
        }
    ],
    "Node JS": [
        {
            "id": 1,
            "name": "What is Node.js?",
            "question": "What is Node.js?",
            "answer": "Node.js is a JavaScript runtime built on Chrome's V8 engine that allows executing JavaScript on the server. It provides an event-driven, non-blocking I/O model that makes it lightweight and efficient for building scalable network applications and APIs.",
            "useCases": [
                "Server-side JavaScript",
                "APIs",
                "Real-time apps"
            ],
            "realTimeUseCases": [
                "REST APIs",
                "WebSocket servers",
                "CLI tools"
            ]
        },
        {
            "id": 2,
            "name": "Why use Node.js?",
            "question": "Why use Node.js?",
            "answer": "Use Node.js when you need high concurrency, low-latency I/O, and a single-language stack across client and server. Its non-blocking model and rich npm ecosystem speed up development for real-time applications, microservices, and streaming workloads.",
            "useCases": [
                "Real-time services",
                "Microservices",
                "Lightweight APIs"
            ],
            "realTimeUseCases": [
                "Chat apps",
                "Realtime dashboards",
                "Streaming servers"
            ]
        },
        {
            "id": 3,
            "name": "What are the features of Node.js?",
            "question": "What are the features of Node.js?",
            "answer": "Key features include the V8 engine for fast JS execution, an event-driven, non-blocking I/O model, a single-threaded event loop for concurrency, a built-in package manager (npm), and a rich standard library for network and filesystem operations.",
            "useCases": [
                "High-concurrency servers",
                "Streaming",
                "Tooling"
            ],
            "realTimeUseCases": [
                "File streaming",
                "Proxy servers",
                "API gateways"
            ]
        },
        {
            "id": 4,
            "name": "What is the V8 engine in Node.js?",
            "question": "What is the V8 engine in Node.js?",
            "answer": "V8 is Google's open-source JavaScript engine that compiles JS to native machine code. Node embeds V8 to execute JavaScript at high speed; V8 also provides optimizations like inline caching and JIT compilation.",
            "useCases": [
                "Fast JS execution",
                "JIT optimizations"
            ],
            "realTimeUseCases": [
                "Performance-critical code",
                "CPU-bound tasks with native addons"
            ]
        },
        {
            "id": 5,
            "name": "What is the Event Loop in Node.js?",
            "question": "What is the Event Loop in Node.js?",
            "answer": "The event loop is the core mechanism that handles asynchronous callbacks and I/O in Node. It repeatedly checks queues of pending tasks (timers, I/O callbacks, microtasks) and dispatches them, giving the appearance of concurrency on a single thread.",
            "useCases": [
                "Managing async work",
                "Coordinating callbacks/promises"
            ],
            "realTimeUseCases": [
                "Handling thousands of concurrent connections",
                "Non-blocking I/O"
            ]
        },
        {
            "id": 6,
            "name": "Explain Event-Driven Architecture in Node.js",
            "question": "Explain Event-Driven Architecture in Node.js.",
            "answer": "Event-driven architecture centers on emitting and reacting to events. In Node, modules (like EventEmitter) emit events when something happens, and listeners handle them; this decouples producers from consumers and fits well with I/O-driven server workflows.",
            "useCases": [
                "Decoupled services",
                "Reactive designs"
            ],
            "realTimeUseCases": [
                "WebSocket event handling",
                "Background job notifications"
            ]
        },
        {
            "id": 7,
            "name": "What is Non-Blocking I/O in Node.js?",
            "question": "What is Non-Blocking I/O in Node.js?",
            "answer": "Non-blocking I/O means I/O operations are initiated and callbacks are used when they complete, so the main thread isn't blocked waiting for results. This allows Node to handle many simultaneous operations efficiently.",
            "useCases": [
                "High throughput servers",
                "I/O-heavy tasks"
            ],
            "realTimeUseCases": [
                "File uploads",
                "Proxying requests"
            ]
        },
        {
            "id": 8,
            "name": "What are Callbacks in Node.js?",
            "question": "What are Callbacks in Node.js?",
            "answer": "Callbacks are functions passed as arguments and invoked when async operations finish. They were the primary async pattern in Node, but can lead to nested code (callback hell) and are often replaced by promises/async-await for clearer flow control.",
            "useCases": [
                "Handling async results",
                "Legacy APIs"
            ],
            "realTimeUseCases": [
                "fs.readFile callbacks",
                "network request callbacks"
            ]
        },
        {
            "id": 9,
            "name": "What are Promises in Node.js?",
            "question": "What are Promises in Node.js?",
            "answer": "Promises represent the eventual completion or failure of an async operation, providing .then/.catch chains for handling results and errors. They improve readability over callbacks and can be combined with Promise.all, race, and other helpers.",
            "useCases": [
                "Async control flow",
                "Composing parallel tasks"
            ],
            "realTimeUseCases": [
                "Multiple API calls aggregation",
                "Retry logic"
            ]
        },
        {
            "id": 10,
            "name": "What is async/await in Node.js?",
            "question": "What is async/await in Node.js?",
            "answer": "async/await builds on promises to express asynchronous code in a synchronous-like style. An async function returns a promise; await pauses execution until the promise resolves, making code easier to read and reason about.",
            "useCases": [
                "Cleaner async code",
                "Sequential async flows"
            ],
            "realTimeUseCases": [
                "Database access sequences",
                "Readable API handlers"
            ]
        },
        {
            "id": 11,
            "name": "Explain Microtask Queue vs Macrotask Queue",
            "question": "Explain Microtask Queue vs Macrotask Queue.",
            "answer": "Microtasks (promise callbacks, process.nextTick) run at the end of the current task before the event loop proceeds. Macrotasks (timers, I/O callbacks, setImmediate) are scheduled for later phases. Microtasks have higher priority, so they can starve macrotasks if abused.",
            "useCases": [
                "Promise scheduling",
                "Task prioritization"
            ],
            "realTimeUseCases": [
                "Ensuring immediate promise resolution before I/O callbacks"
            ]
        },
        {
            "id": 12,
            "name": "What is Synchronous vs Asynchronous communication?",
            "question": "What is Synchronous vs Asynchronous communication?",
            "answer": "Synchronous communication blocks until a response arrives (calling thread waits). Asynchronous communication initiates work and continues; results are delivered via callbacks/promises/events. Asynchronous approaches improve throughput and responsiveness in I/O-bound systems.",
            "useCases": [
                "API design",
                "Microservices communication"
            ],
            "realTimeUseCases": [
                "Blocking DB calls vs async queries",
                "Event-driven messaging"
            ]
        },
        {
            "id": 13,
            "name": "Difference between process.nextTick() and setImmediate()",
            "question": "What is the difference between process.nextTick() and setImmediate()?",
            "answer": "process.nextTick queues a callback to run immediately after the current operation completes (before I/O), while setImmediate schedules a callback to run on the next iteration of the event loop (after I/O callbacks). Use nextTick for truly immediate microtasks and setImmediate for deferring to the next loop turn.",
            "useCases": [
                "Microtask scheduling",
                "Avoiding recursion"
            ],
            "realTimeUseCases": [
                "Deferring heavy work",
                "Breaking up long synchronous loops"
            ]
        },
        {
            "id": 14,
            "name": "Difference between setTimeout, setInterval, setImmediate",
            "question": "What is the difference between setTimeout(), setInterval(), and setImmediate()?",
            "answer": "setTimeout schedules a callback after a minimum delay; setInterval repeats a callback at intervals; setImmediate executes a callback on the next event loop iteration. For repeated work, prefer setInterval or self-scheduling setTimeout; setImmediate is useful for deferring to the next cycle without a time delay.",
            "useCases": [
                "Timed operations",
                "Deferring tasks"
            ],
            "realTimeUseCases": [
                "Polling",
                "Debounced retries"
            ]
        },
        {
            "id": 15,
            "name": "Difference between CommonJS and ES Modules",
            "question": "What is the difference between CommonJS and ES Modules?",
            "answer": "CommonJS (require/module.exports) is Node's original module system with synchronous loading. ES Modules (import/export) is the standardized module system with static analysis and support for import/export syntax; ESM supports asynchronous loading and tree-shaking. Node supports both with different interop rules.",
            "useCases": [
                "Module design",
                "Tooling compatibility"
            ],
            "realTimeUseCases": [
                "Authoring libraries",
                "Using modern build tools"
            ]
        },
        {
            "id": 16,
            "name": "What is the require() function and how it works?",
            "question": "What is the require() function and how it works?",
            "answer": "require() loads modules using a path or package name, resolves module IDs, loads and executes the module code, and returns module.exports. Node caches loaded modules to avoid re-execution on subsequent requires.",
            "useCases": [
                "Loading local modules",
                "Using npm packages"
            ],
            "realTimeUseCases": [
                "App composition",
                "Plugin systems"
            ]
        },
        {
            "id": 17,
            "name": "What is Module Caching in Node.js?",
            "question": "What is Module Caching in Node.js?",
            "answer": "Node caches modules after first load in require.cache; subsequent require calls return the cached exports. This improves performance and preserves singleton behavior but requires care when you need fresh state (clear cache or use dynamic import).",
            "useCases": [
                "Performance",
                "Singletons"
            ],
            "realTimeUseCases": [
                "Database connection singletons",
                "Configuration modules"
            ]
        },
        {
            "id": 18,
            "name": "What is NPM?",
            "question": "What is NPM?",
            "answer": "npm is the default package manager for Node.js, providing a registry of packages, dependency resolution, and scripts defined in package.json. It simplifies package installation, versioning, and publishing.",
            "useCases": [
                "Dependency management",
                "Scripts automation"
            ],
            "realTimeUseCases": [
                "Installing libraries",
                "Running build/test scripts"
            ]
        },
        {
            "id": 19,
            "name": "What is package.json?",
            "question": "What is package.json?",
            "answer": "package.json is a manifest describing a Node project: metadata, dependencies, scripts, and configuration. It defines how to install, run, and publish the package.",
            "useCases": [
                "Project metadata",
                "Dependency list"
            ],
            "realTimeUseCases": [
                "npm install",
                "npm run scripts"
            ]
        },
        {
            "id": 20,
            "name": "What is package-lock.json?",
            "question": "What is package-lock.json?",
            "answer": "package-lock.json records exact versions of installed dependencies and their dependency tree, ensuring deterministic installs across environments. It's generated automatically and should be committed for reproducible builds.",
            "useCases": [
                "Reproducible installs",
                "CI consistency"
            ],
            "realTimeUseCases": [
                "Locking dependency tree in production"
            ]
        },
        {
            "id": 21,
            "name": "What are Node.js Streams?",
            "question": "What are Node.js Streams?",
            "answer": "Streams are abstractions for working with streaming data, allowing processing of data piece-by-piece rather than in a single buffer. They reduce memory usage and allow piping between sources and destinations (e.g., file read stream -> gzip -> HTTP response).",
            "useCases": [
                "Processing large data",
                "Piping transforms"
            ],
            "realTimeUseCases": [
                "File uploads/downloads",
                "Streaming video/audio"
            ]
        },
        {
            "id": 22,
            "name": "Types of Streams in Node.js",
            "question": "Types of Streams in Node.js.",
            "answer": "Four main types: Readable (read data), Writable (write data), Duplex (read and write), and Transform (a Duplex that modifies data). Each has an object-mode option and implements backpressure to avoid overwhelming consumers.",
            "useCases": [
                "Stream composition",
                "Transform pipelines"
            ],
            "realTimeUseCases": [
                "Compression pipelines",
                "ETL processes"
            ]
        },
        {
            "id": 23,
            "name": "What are Buffers in Node.js?",
            "question": "What are Buffers in Node.js?",
            "answer": "Buffers are raw binary data containers used to handle streams and binary protocols. They provide methods to read/write integers, strings with encodings, and slice without copying, which is useful for network and file I/O.",
            "useCases": [
                "Binary protocols",
                "Data parsing"
            ],
            "realTimeUseCases": [
                "TCP protocol handling",
                "Image processing"
            ]
        },
        {
            "id": 24,
            "name": "What is the File System (fs) module?",
            "question": "What is the File System (fs) module?",
            "answer": "The fs module provides APIs to interact with the file system: reading/writing files, watching changes, streaming file contents, and more. It offers both synchronous and asynchronous variants; prefer async to avoid blocking the event loop.",
            "useCases": [
                "File I/O",
                "Config management"
            ],
            "realTimeUseCases": [
                "Serving static files",
                "Log rotation"
            ]
        },
        {
            "id": 25,
            "name": "What is the Crypto module?",
            "question": "What is the Crypto module?",
            "answer": "Crypto provides cryptographic primitives: hashing, HMAC, cipher algorithms, key pair generation, and signing. Use it for secure operations like password hashing, data integrity verification, and TLS-related tasks.",
            "useCases": [
                "Hashing",
                "Encryption"
            ],
            "realTimeUseCases": [
                "Signing tokens",
                "Secure storage"
            ]
        },
        {
            "id": 26,
            "name": "What is JWT and how it works in Node.js?",
            "question": "What is JWT and how it works in Node.js?",
            "answer": "JWT (JSON Web Token) is a compact token format containing claims, signed (and optionally encrypted). In Node, servers create a JWT signed with a secret/private key and return it to clients; clients present it for authenticated requests and the server verifies signature and claims.",
            "useCases": [
                "Stateless auth",
                "APIs"
            ],
            "realTimeUseCases": [
                "Access tokens",
                "Single-page app auth"
            ]
        },
        {
            "id": 27,
            "name": "What is Middleware in Node.js?",
            "question": "What is Middleware in Node.js?",
            "answer": "Middleware is reusable code that sits between request and response (commonly in Express). It can modify requests/responses, handle authentication, logging, or perform validation, and is composed in a pipeline to build request-handling logic.",
            "useCases": [
                "Auth",
                "Logging",
                "Validation"
            ],
            "realTimeUseCases": [
                "JWT verification",
                "Request body parsing"
            ]
        },
        {
            "id": 28,
            "name": "What is Express.js?",
            "question": "What is Express.js?",
            "answer": "Express is a minimal, flexible web framework for Node providing routing, middleware support, and utilities to build APIs and server-side apps quickly. It's widely used for REST APIs and microservices.",
            "useCases": [
                "APIs",
                "Web servers"
            ],
            "realTimeUseCases": [
                "REST services",
                "Static servers"
            ]
        },
        {
            "id": 29,
            "name": "What are Express routers?",
            "question": "What are Express routers?",
            "answer": "Express Routers are modular route handlers that group related routes and middleware. They help organize application structure by mounting routers on path prefixes and isolating route logic.",
            "useCases": [
                "Modular routes",
                "Versioned APIs"
            ],
            "realTimeUseCases": [
                "User routes",
                "Admin routes"
            ]
        },
        {
            "id": 30,
            "name": "What is CORS?",
            "question": "What is CORS?",
            "answer": "CORS (Cross-Origin Resource Sharing) is a browser security mechanism controlling cross-origin requests. Servers return CORS headers to indicate allowed origins, methods, and headers. Proper CORS config enables APIs to be safely accessed from web apps on different domains.",
            "useCases": [
                "API security",
                "Cross-origin requests"
            ],
            "realTimeUseCases": [
                "Public APIs",
                "Microfrontends"
            ]
        },
        {
            "id": 31,
            "name": "What is Helmet?",
            "question": "What is Helmet?",
            "answer": "Helmet is Express middleware that sets various HTTP headers to improve security (e.g., Content-Security-Policy, X-Frame-Options). It reduces common web vulnerabilities by providing sensible defaults and configuration options.",
            "useCases": [
                "Hardening HTTP headers",
                "Security defaults"
            ],
            "realTimeUseCases": [
                "Protecting against clickjacking",
                "Content security policies"
            ]
        },
        {
            "id": 32,
            "name": "What is Rate Limiting in Node.js?",
            "question": "What is Rate Limiting in Node.js?",
            "answer": "Rate limiting restricts the number of requests a client can make in a time window to prevent abuse and DoS. Implementations use in-memory stores, Redis, or external API gateways to track and enforce limits.",
            "useCases": [
                "API protection",
                "Abuse prevention"
            ],
            "realTimeUseCases": [
                "Login throttling",
                "Public API quotas"
            ]
        },
        {
            "id": 33,
            "name": "What is Throttling in Node.js?",
            "question": "What is Throttling in Node.js?",
            "answer": "Throttling limits how often a function or endpoint executes over time to smooth load and avoid spikes. It's commonly applied to expensive operations or user actions to keep resource usage predictable.",
            "useCases": [
                "Rate control",
                "Smoothing spikes"
            ],
            "realTimeUseCases": [
                "Search queries",
                "Autosave operations"
            ]
        },
        {
            "id": 34,
            "name": "What is clustering in Node.js?",
            "question": "What is clustering in Node.js?",
            "answer": "Clustering runs multiple Node worker processes (usually one per CPU) sharing server ports to utilize multi-core CPUs. The cluster or worker_threads modules help scale CPU-bound workloads and improve availability.",
            "useCases": [
                "CPU scaling",
                "Resilience"
            ],
            "realTimeUseCases": [
                "High-traffic servers",
                "Parallel batch jobs"
            ]
        },
        {
            "id": 35,
            "name": "What is Load Balancing?",
            "question": "What is Load Balancing?",
            "answer": "Load balancing distributes incoming traffic across multiple instances to improve availability and throughput. It can be done by reverse proxies (NGINX), cloud load balancers, or API gateways with health checks and session strategies.",
            "useCases": [
                "Scalability",
                "High availability"
            ],
            "realTimeUseCases": [
                "Horizontal scaling behind NGINX",
                "Blue/green deployments"
            ]
        },
        {
            "id": 36,
            "name": "What is PM2 and why use it?",
            "question": "What is PM2 and why use it?",
            "answer": "PM2 is a process manager for Node.js that handles process monitoring, clustering, log management, and graceful restarts. It simplifies deployment and ensures apps stay running in production.",
            "useCases": [
                "Process management",
                "Zero-downtime restarts"
            ],
            "realTimeUseCases": [
                "Managing multiple services",
                "Auto-restarts on crash"
            ]
        },
        {
            "id": 37,
            "name": "What are environment variables?",
            "question": "What are environment variables?",
            "answer": "Environment variables are key/value pairs provided to processes by the OS to configure behavior (e.g., PORT, NODE_ENV). They enable separating configuration from code and are commonly used for secrets, endpoints, and flags.",
            "useCases": [
                "Config management",
                "Secrets handling"
            ],
            "realTimeUseCases": [
                "Setting DB URLs",
                "Feature flags"
            ]
        },
        {
            "id": 38,
            "name": "What is dotenv and why use it?",
            "question": "What is dotenv and why use it?",
            "answer": "dotenv is a utility that loads environment variables from a .env file into process.env during development. It simplifies local config while keeping secrets out of source code, but .env should not be committed to source control for sensitive values.",
            "useCases": [
                "Local configuration",
                "Developer convenience"
            ],
            "realTimeUseCases": [
                "Local DB credentials",
                "Dev feature toggles"
            ]
        },
        {
            "id": 39,
            "name": "What is REST API?",
            "question": "What is REST API?",
            "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications using stateless HTTP endpoints, resource-based URIs, and standard methods (GET, POST, PUT, DELETE). REST APIs are simple to implement and widely used for web services.",
            "useCases": [
                "Web services",
                "CRUD APIs"
            ],
            "realTimeUseCases": [
                "User management APIs",
                "Public service endpoints"
            ]
        },
        {
            "id": 40,
            "name": "What is gRPC?",
            "question": "What is gRPC?",
            "answer": "gRPC is a high-performance RPC framework using HTTP/2 and Protocol Buffers for schema-defined contracts. It supports streaming, bi-directional communication, and strong typing, making it suitable for microservices and low-latency services.",
            "useCases": [
                "Microservices communication",
                "Streaming RPC"
            ],
            "realTimeUseCases": [
                "Inter-service RPC",
                "Low-latency APIs"
            ]
        },
        {
            "id": 41,
            "name": "What are Microservices?",
            "question": "What are Microservices?",
            "answer": "Microservices are an architectural style where an application is composed of small, independently deployable services that communicate over lightweight protocols. They improve modularity and scalability but add complexity in deployment, observability, and data consistency.",
            "useCases": [
                "Domain-driven design",
                "Independent scaling"
            ],
            "realTimeUseCases": [
                "Payment service",
                "User service"
            ]
        },
        {
            "id": 42,
            "name": "What is API Gateway?",
            "question": "What is API Gateway?",
            "answer": "An API Gateway is a faÃ§ade that routes, secures, and aggregates calls to backend services. It can provide authentication, rate limiting, caching, and protocol translation, centralizing cross-cutting concerns for microservices.",
            "useCases": [
                "Centralized routing",
                "Security"
            ],
            "realTimeUseCases": [
                "Auth enforcement",
                "Request routing"
            ]
        },
        {
            "id": 43,
            "name": "What is Redis?",
            "question": "What is Redis?",
            "answer": "Redis is an in-memory key-value store used for caching, ephemeral storage, pub/sub, and simple data structures. It's extremely fast and useful for reducing DB load and sharing state among services.",
            "useCases": [
                "Caching",
                "Session store",
                "Pub/Sub"
            ],
            "realTimeUseCases": [
                "Token cache",
                "Leader election"
            ]
        },
        {
            "id": 44,
            "name": "What is Redis Caching?",
            "question": "What is Redis Caching?",
            "answer": "Redis caching stores frequently accessed data in memory to reduce latency and decrease backend load. Common patterns include read-through, write-through, and cache-aside, with eviction policies like LRU and TTL.",
            "useCases": [
                "Performance",
                "Scalability"
            ],
            "realTimeUseCases": [
                "Page caching",
                "Query result caching"
            ]
        },
        {
            "id": 45,
            "name": "What is Redis Pub/Sub?",
            "question": "What is Redis Pub/Sub?",
            "answer": "Redis Pub/Sub is a lightweight messaging mechanism where publishers send messages to channels and subscribers receive them in real-time. It's useful for simple notifications but lacks persistence and advanced messaging guarantees.",
            "useCases": [
                "Realtime notifications",
                "Event broadcast"
            ],
            "realTimeUseCases": [
                "Chat messages",
                "Cache invalidation"
            ]
        },
        {
            "id": 46,
            "name": "What is Message Queue (RabbitMQ/Kafka)?",
            "question": "What is Message Queue (RabbitMQ/Kafka)?",
            "answer": "Message queues decouple producers from consumers by buffering messages. RabbitMQ is a broker supporting complex routing and acknowledgments; Kafka is a distributed log optimized for high-throughput streaming and replayability. They enable resilient, asynchronous architectures.",
            "useCases": [
                "Decoupling",
                "Async processing"
            ],
            "realTimeUseCases": [
                "Order processing",
                "Event streaming"
            ]
        },
        {
            "id": 47,
            "name": "What is Bull Queue in Node.js?",
            "question": "What is Bull Queue in Node.js?",
            "answer": "Bull is a Redis-backed queue library for Node that supports job retries, scheduling, concurrency control, and rate limiting. It's commonly used for background jobs like sending emails, generating reports, or processing uploads.",
            "useCases": [
                "Background jobs",
                "Retryable tasks"
            ],
            "realTimeUseCases": [
                "Email sending",
                "Video transcoding"
            ]
        },
        {
            "id": 48,
            "name": "What is WebSocket?",
            "question": "What is WebSocket?",
            "answer": "WebSocket is a protocol providing full-duplex communication channels over a single TCP connection, enabling low-latency, bidirectional data exchange between client and server.",
            "useCases": [
                "Realtime apps",
                "Push updates"
            ],
            "realTimeUseCases": [
                "Chat apps",
                "Realtime dashboards"
            ]
        },
        {
            "id": 49,
            "name": "What is Socket.IO?",
            "question": "What is Socket.IO?",
            "answer": "Socket.IO is a library that provides real-time, bidirectional communication with fallback transports and additional features like rooms and reconnection handling. It builds on WebSocket where available and provides a higher-level API.",
            "useCases": [
                "Realtime collaboration",
                "Transport fallback"
            ],
            "realTimeUseCases": [
                "Live chat",
                "Collaborative editing"
            ]
        },
        {
            "id": 50,
            "name": "What is SSE (Server-Sent Events)?",
            "question": "What is SSE (Server-Sent Events)?",
            "answer": "SSE is a unidirectional streaming protocol where the server pushes text/event-stream data to the client over an HTTP connection. It's simpler than WebSocket for server-to-client updates and works well for streaming notifications.",
            "useCases": [
                "Server push",
                "Live updates"
            ],
            "realTimeUseCases": [
                "Stock tickers",
                "Live news feeds"
            ]
        },
        {
            "id": 51,
            "name": "Explain real-time communication in Node.js",
            "question": "Explain real-time communication in Node.js.",
            "answer": "Real-time communication in Node uses WebSocket, Socket.IO, or SSE to deliver low-latency messages. Node's event-driven model fits real-time workloads; proper scaling requires sticky sessions, shared pub/sub (e.g., Redis), or message brokers to distribute events across instances.",
            "useCases": [
                "Low-latency apps",
                "Collaborative tools"
            ],
            "realTimeUseCases": [
                "Chat",
                "Live collaboration"
            ]
        },
        {
            "id": 52,
            "name": "What is Horizontal Scaling?",
            "question": "What is Horizontal Scaling?",
            "answer": "Horizontal scaling adds more instances to handle increased load (scale out). It improves throughput and availability and is typically achieved with load balancers and stateless services.",
            "useCases": [
                "Scalability",
                "Fault tolerance"
            ],
            "realTimeUseCases": [
                "Autoscaling clusters",
                "Service farms"
            ]
        },
        {
            "id": 53,
            "name": "What is Vertical Scaling?",
            "question": "What is Vertical Scaling?",
            "answer": "Vertical scaling increases resources (CPU, RAM) of a single machine (scale up). It can be simpler but has limits and can be a single point of failure.",
            "useCases": [
                "Short-term scaling",
                "Resource heavy tasks"
            ],
            "realTimeUseCases": [
                "Upgrading DB server",
                "Memory-heavy processes"
            ]
        },
        {
            "id": 54,
            "name": "What is Horizontal Pod Autoscaling (Kubernetes)?",
            "question": "What is Horizontal Pod Autoscaling (Kubernetes)?",
            "answer": "HPA automatically scales the number of pod replicas based on CPU/memory or custom metrics, enabling applications to adapt to changing load within Kubernetes clusters.",
            "useCases": [
                "K8s autoscaling",
                "Resource optimization"
            ],
            "realTimeUseCases": [
                "Scaling API pods",
                "Handling traffic spikes"
            ]
        },
        {
            "id": 55,
            "name": "What is Docker?",
            "question": "What is Docker?",
            "answer": "Docker is a containerization platform that packages applications and dependencies into lightweight, portable containers, ensuring consistent behavior across environments.",
            "useCases": [
                "Isolation",
                "Portable deployments"
            ],
            "realTimeUseCases": [
                "Microservices",
                "CI builds"
            ]
        },
        {
            "id": 56,
            "name": "What is Dockerfile?",
            "question": "What is Dockerfile?",
            "answer": "A Dockerfile is a text file with instructions to build a Docker image, specifying base image, files to copy, environment variables, and commands to run during image creation.",
            "useCases": [
                "Image creation",
                "Repeatable builds"
            ],
            "realTimeUseCases": [
                "Containerizing apps",
                "Reproducible dev environments"
            ]
        },
        {
            "id": 57,
            "name": "What is docker-compose?",
            "question": "What is docker-compose?",
            "answer": "docker-compose is a tool to define and run multi-container Docker applications using a YAML file, orchestrating how services, networks, and volumes interact locally.",
            "useCases": [
                "Local orchestration",
                "Multi-service dev stacks"
            ],
            "realTimeUseCases": [
                "Local microservices",
                "DB + API stacks"
            ]
        },
        {
            "id": 58,
            "name": "What is Kubernetes?",
            "question": "What is Kubernetes?",
            "answer": "Kubernetes is a container orchestration system for automating deployment, scaling, and management of containerized applications across clusters.",
            "useCases": [
                "Orchestration",
                "Self-healing deployments"
            ],
            "realTimeUseCases": [
                "Running microservices in production",
                "Service discovery"
            ]
        },
        {
            "id": 59,
            "name": "What is a Pod, Deployment, and Service in K8s?",
            "question": "What is a Pod, Deployment, and Service in K8s?",
            "answer": "A Pod is the smallest deployable unit (one or more containers); a Deployment manages desired state and rolling updates; a Service exposes pods via stable endpoints and load-balances traffic.",
            "useCases": [
                "Container lifecycle",
                "Service exposure"
            ],
            "realTimeUseCases": [
                "Stateless app deployments",
                "Blue/green updates"
            ]
        },
        {
            "id": 60,
            "name": "What is CI/CD?",
            "question": "What is CI/CD?",
            "answer": "CI/CD is a set of practices (Continuous Integration/Continuous Delivery) that automate building, testing, and deploying code changes to improve release velocity and reliability.",
            "useCases": [
                "Pipeline automation",
                "Quality gates"
            ],
            "realTimeUseCases": [
                "Automated testing",
                "Production deployments"
            ]
        },
        {
            "id": 61,
            "name": "What is GitHub Actions/Jenkins in CI/CD?",
            "question": "What is GitHub Actions/Jenkins in CI/CD?",
            "answer": "GitHub Actions and Jenkins are CI/CD tools: GitHub Actions provides integrated pipelines in GitHub; Jenkins is a highly extensible automation server. Both run build/test/deploy pipelines and integrate with external services.",
            "useCases": [
                "Automated builds",
                "Testing pipelines"
            ],
            "realTimeUseCases": [
                "Run tests on PRs",
                "Deploy on merge"
            ]
        },
        {
            "id": 62,
            "name": "What is Unit Testing in Node.js?",
            "question": "What is Unit Testing in Node.js?",
            "answer": "Unit testing verifies individual units (functions/modules) in isolation using assertions and mocks. It ensures code correctness and enables safe refactoring.",
            "useCases": [
                "Regression prevention",
                "Design feedback"
            ],
            "realTimeUseCases": [
                "Testing utility functions",
                "Testing services"
            ]
        },
        {
            "id": 63,
            "name": "What is Integration Testing in Node.js?",
            "question": "What is Integration Testing in Node.js?",
            "answer": "Integration testing checks interactions between components (e.g., API + DB) to validate end-to-end behavior for specific workflows.",
            "useCases": [
                "Data layer testing",
                "API-contracts"
            ],
            "realTimeUseCases": [
                "Testing endpoints with test DB",
                "Third-party integrations"
            ]
        },
        {
            "id": 64,
            "name": "What is E2E Testing in Node.js?",
            "question": "What is E2E Testing in Node.js?",
            "answer": "End-to-end testing validates entire user flows through the system from UI to backend, often using tools like Playwright or Selenium to simulate real user interactions.",
            "useCases": [
                "User flow validation",
                "Regression checks"
            ],
            "realTimeUseCases": [
                "Checkout flow tests",
                "Multi-step forms"
            ]
        },
        {
            "id": 65,
            "name": "What is Mocha, Jest, Chai, Supertest?",
            "question": "What is Mocha, Jest, Chai, Supertest?",
            "answer": "Mocha and Jest are test runners; Jest includes assertion library and mocking utilities. Chai is an assertion library often used with Mocha. Supertest helps test HTTP endpoints. Together they provide a testing stack for Node apps.",
            "useCases": [
                "Unit & integration testing",
                "HTTP assertions"
            ],
            "realTimeUseCases": [
                "API tests",
                "Snapshot testing"
            ]
        },
        {
            "id": 66,
            "name": "What is Logging in Node.js?",
            "question": "What is Logging in Node.js?",
            "answer": "Logging records application behavior and errors. Structured logs with timestamps, levels, and request context are critical for debugging and observability.",
            "useCases": [
                "Debugging",
                "Auditing"
            ],
            "realTimeUseCases": [
                "Error tracking",
                "Request logs"
            ]
        },
        {
            "id": 67,
            "name": "What is Winston Logger?",
            "question": "What is Winston Logger?",
            "answer": "Winston is a flexible logging library supporting multiple transports, log levels, and formats. It's commonly used for production logging to files, consoles, and external systems.",
            "useCases": [
                "Production logging",
                "Multiple transports"
            ],
            "realTimeUseCases": [
                "Log files",
                "Remote log aggregation"
            ]
        },
        {
            "id": 68,
            "name": "What is Morgan Logger?",
            "question": "What is Morgan Logger?",
            "answer": "Morgan is an HTTP request logger middleware for Express that logs request/response metadata for development and basic production needs.",
            "useCases": [
                "Request logging",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Access logs",
                "Development diagnostics"
            ]
        },
        {
            "id": 69,
            "name": "What is Monitoring in Node.js?",
            "question": "What is Monitoring in Node.js?",
            "answer": "Monitoring collects metrics, logs, and traces to observe application health. It includes uptime checks, performance metrics, and alerting to detect and react to issues.",
            "useCases": [
                "Health checks",
                "Performance tracking"
            ],
            "realTimeUseCases": [
                "CPU/memory alerts",
                "Error rate monitoring"
            ]
        },
        {
            "id": 70,
            "name": "What is Prometheus?",
            "question": "What is Prometheus?",
            "answer": "Prometheus is an open-source monitoring system that scrapes metrics exposed over HTTP and stores time-series data; it's commonly used with Grafana for visualization.",
            "useCases": [
                "Metrics collection",
                "Alerting"
            ],
            "realTimeUseCases": [
                "Service metrics",
                "SLO monitoring"
            ]
        },
        {
            "id": 71,
            "name": "What is Grafana?",
            "question": "What is Grafana?",
            "answer": "Grafana is a dashboarding and visualization tool used to graph metrics and build operational dashboards from Prometheus and other data sources.",
            "useCases": [
                "Dashboards",
                "Visualization"
            ],
            "realTimeUseCases": [
                "Performance dashboards",
                "SLA reporting"
            ]
        },
        {
            "id": 72,
            "name": "What is OpenTelemetry?",
            "question": "What is OpenTelemetry?",
            "answer": "OpenTelemetry is a vendor-neutral observability framework for instrumenting code to produce traces, metrics, and logs; it standardizes telemetry collection and export.",
            "useCases": [
                "Distributed tracing",
                "Instrumentation"
            ],
            "realTimeUseCases": [
                "Tracing microservices",
                "Unified telemetry"
            ]
        },
        {
            "id": 73,
            "name": "What is Distributed Tracing?",
            "question": "What is Distributed Tracing?",
            "answer": "Distributed tracing tracks a request across service boundaries by propagating trace context and recording spans, enabling root-cause analysis and latency breakdowns across microservices.",
            "useCases": [
                "Performance debugging",
                "Latency analysis"
            ],
            "realTimeUseCases": [
                "Tracing slow requests",
                "Span correlations"
            ]
        },
        {
            "id": 74,
            "name": "What is NGINX reverse proxy?",
            "question": "What is NGINX reverse proxy?",
            "answer": "NGINX can act as a reverse proxy that routes requests to backend servers, performs TLS termination, caching, and load balancing, improving security and performance.",
            "useCases": [
                "TLS offloading",
                "Load balancing"
            ],
            "realTimeUseCases": [
                "Serving static assets",
                "API gateway proxying"
            ]
        },
        {
            "id": 75,
            "name": "What is HTTPS and TLS in Node.js?",
            "question": "What is HTTPS and TLS in Node.js?",
            "answer": "HTTPS secures HTTP with TLS encryption; Node supports HTTPS via the https module, requiring certificates and keys. TLS ensures confidentiality, integrity, and authentication for web traffic.",
            "useCases": [
                "Secure traffic",
                "Data privacy"
            ],
            "realTimeUseCases": [
                "Secure APIs",
                "Payment processing"
            ]
        },
        {
            "id": 76,
            "name": "What is CSRF?",
            "question": "What is CSRF?",
            "answer": "CSRF (Cross-Site Request Forgery) is an attack where a user's browser is tricked into submitting unintended requests. Mitigations include CSRF tokens, SameSite cookies, and checking Origin/Referer headers.",
            "useCases": [
                "Web security",
                "Form protection"
            ],
            "realTimeUseCases": [
                "Protecting state-changing endpoints",
                "Form submissions"
            ]
        },
        {
            "id": 77,
            "name": "What is XSS?",
            "question": "What is XSS?",
            "answer": "XSS (Cross-Site Scripting) allows attackers to inject client-side scripts into pages viewed by others. Prevent by escaping/untrusted content, using Content Security Policy, and sanitizing inputs.",
            "useCases": [
                "Frontend security",
                "Input validation"
            ],
            "realTimeUseCases": [
                "Sanitizing user comments",
                "CSP enforcement"
            ]
        },
        {
            "id": 78,
            "name": "What is SQL Injection?",
            "question": "What is SQL Injection?",
            "answer": "SQL injection occurs when untrusted input alters SQL queries; prevent it using parameterized queries/ORMs, input validation, and least privilege DB users.",
            "useCases": [
                "DB security",
                "Query safety"
            ],
            "realTimeUseCases": [
                "Prepared statements",
                "ORM parameter binding"
            ]
        },
        {
            "id": 79,
            "name": "What is Input Validation?",
            "question": "What is Input Validation?",
            "answer": "Input validation ensures incoming data meets expected formats and constraints. It prevents injection attacks, runtime errors, and data corruption by using schemas and validation libraries.",
            "useCases": [
                "Security",
                "Data integrity"
            ],
            "realTimeUseCases": [
                "Validating API payloads",
                "Form validation"
            ]
        },
        {
            "id": 80,
            "name": "What is Role-Based Access Control (RBAC)?",
            "question": "What is Role-Based Access Control (RBAC)?",
            "answer": "RBAC assigns permissions to roles which are then granted to users, simplifying permission management and enforcing least privilege across the system.",
            "useCases": [
                "Access management",
                "Permission modeling"
            ],
            "realTimeUseCases": [
                "Admin vs user roles",
                "Feature toggles"
            ]
        },
        {
            "id": 81,
            "name": "What are Access Tokens and Refresh Tokens?",
            "question": "What are Access Tokens and Refresh Tokens?",
            "answer": "Access tokens grant clients access to resources for a short period; refresh tokens are long-lived and used to obtain new access tokens without reauthenticating. This pattern balances security and usability.",
            "useCases": [
                "Token-based auth",
                "Session management"
            ],
            "realTimeUseCases": [
                "JWT access/refresh flows",
                "OAuth2 implementations"
            ]
        },
        {
            "id": 82,
            "name": "What is session-based authentication vs token-based authentication?",
            "question": "What is session-based authentication vs token-based authentication?",
            "answer": "Session-based auth stores session state on server (session id cookie), while token-based (e.g., JWT) stores auth claims on client; sessions simplify revocation, tokens enable stateless scaling and cross-domain usage.",
            "useCases": [
                "Auth strategies",
                "Scalability considerations"
            ],
            "realTimeUseCases": [
                "Web apps with server sessions",
                "SPAs using JWT"
            ]
        },
        {
            "id": 83,
            "name": "Difference between Express.js and NestJS",
            "question": "What is the difference between Express.js and NestJS?",
            "answer": "Express is minimal and unopinionated; NestJS is a framework built on top of Express (or Fastify) that uses TypeScript, dependency injection, and modular architecture for enterprise-grade apps.",
            "useCases": [
                "Lightweight apps",
                "Structured enterprise apps"
            ],
            "realTimeUseCases": [
                "Small APIs with Express",
                "Large apps with NestJS"
            ]
        },
        {
            "id": 84,
            "name": "What is Koa.js?",
            "question": "What is Koa.js?",
            "answer": "Koa is a lightweight, modern web framework from the Express team that uses async functions and a middleware stack to create smaller, more expressive servers.",
            "useCases": [
                "Minimal middleware",
                "Modern patterns"
            ],
            "realTimeUseCases": [
                "Microservices",
                "Custom middleware stacks"
            ]
        },
        {
            "id": 85,
            "name": "What is Hapi.js?",
            "question": "What is Hapi.js?",
            "answer": "Hapi is a rich framework focused on configuration and extensibility, offering plugins, validation, and built-in patterns for building robust APIs.",
            "useCases": [
                "Enterprise APIs",
                "Plugin ecosystems"
            ],
            "realTimeUseCases": [
                "Policy-driven APIs",
                "Secure services"
            ]
        },
        {
            "id": 86,
            "name": "What is EventEmitter in Node.js?",
            "question": "What is EventEmitter in Node.js?",
            "answer": "EventEmitter is the core pub/sub utility in Node that allows objects to emit events and register listeners. It's widely used in core modules and userland code for building evented APIs.",
            "useCases": [
                "Event pub/sub",
                "Custom event APIs"
            ],
            "realTimeUseCases": [
                "Stream events",
                "Custom hooks"
            ]
        },
        {
            "id": 87,
            "name": "What is process object in Node.js?",
            "question": "What is process object in Node.js?",
            "answer": "process is a global object that provides info and control over the Node process (argv, env, exit, stdout/stderr), enabling interaction with the runtime environment.",
            "useCases": [
                "Process control",
                "Accessing env vars"
            ],
            "realTimeUseCases": [
                "Graceful shutdown",
                "Reading CLI args"
            ]
        },
        {
            "id": 88,
            "name": "What are child processes?",
            "question": "What are child processes?",
            "answer": "Child processes allow Node to spawn external processes (spawn, exec, fork) to run commands or parallelize work outside the event loop, useful for CPU-bound tasks or integrating native tools.",
            "useCases": [
                "Parallel work",
                "Running external tools"
            ],
            "realTimeUseCases": [
                "Image processing with native binaries",
                "Running build tools"
            ]
        },
        {
            "id": 89,
            "name": "What is spawn(), exec(), and fork()?",
            "question": "What is spawn(), exec(), and fork()?",
            "answer": "spawn launches a process with a stream-based interface, exec runs a command and buffers output (good for small outputs), and fork spawns a new Node process with IPC channel for communication. Choose based on streaming needs and IPC requirements.",
            "useCases": [
                "Process control",
                "IPC"
            ],
            "realTimeUseCases": [
                "Streaming child outputs",
                "Worker processes"
            ]
        },
        {
            "id": 90,
            "name": "What is the OS module?",
            "question": "What is the OS module?",
            "answer": "The OS module provides utilities to query system information (CPU, memory, platform) and interacts with OS-level details to make runtime decisions.",
            "useCases": [
                "Telemetry",
                "Adaptive configuration"
            ],
            "realTimeUseCases": [
                "Choosing worker counts",
                "Health checks"
            ]
        },
        {
            "id": 91,
            "name": "What is the Cluster module?",
            "question": "What is the Cluster module?",
            "answer": "The Cluster module enables launching worker processes that share server ports, providing a simple way to scale across CPU cores with a master/worker model.",
            "useCases": [
                "Vertical scaling",
                "Worker supervision"
            ],
            "realTimeUseCases": [
                "Multi-core servers",
                "Crash isolation"
            ]
        },
        {
            "id": 92,
            "name": "What is the Net module?",
            "question": "What is the Net module?",
            "answer": "The Net module provides low-level TCP/IPC networking primitives for building custom protocol servers and clients.",
            "useCases": [
                "TCP servers",
                "Custom protocols"
            ],
            "realTimeUseCases": [
                "Proxy servers",
                "Custom protocol handlers"
            ]
        },
        {
            "id": 93,
            "name": "What is the DNS module?",
            "question": "What is the DNS module?",
            "answer": "The DNS module provides name resolution APIs (lookup, resolve) to resolve hostnames to IPs and query DNS records from Node code.",
            "useCases": [
                "Service discovery",
                "Custom resolution"
            ],
            "realTimeUseCases": [
                "Dynamic host lookup",
                "Custom DNS queries"
            ]
        },
        {
            "id": 94,
            "name": "What is the HTTP module?",
            "question": "What is the HTTP module?",
            "answer": "The HTTP module implements core HTTP server/client functionality. Frameworks like Express build on top of it; using it directly gives maximum control and minimal overhead.",
            "useCases": [
                "Lightweight servers",
                "Custom handling"
            ],
            "realTimeUseCases": [
                "Proxy servers",
                "Custom header handling"
            ]
        },
        {
            "id": 95,
            "name": "What is the HTTPS module?",
            "question": "What is the HTTPS module?",
            "answer": "The HTTPS module wraps HTTP with TLS, enabling secure servers and clients when provided with certificates and keys.",
            "useCases": [
                "Secure servers",
                "TLS termination"
            ],
            "realTimeUseCases": [
                "Secure APIs",
                "Mutual TLS"
            ]
        },
        {
            "id": 96,
            "name": "What is middleware chaining in Express?",
            "question": "What is middleware chaining in Express?",
            "answer": "Middleware chaining composes multiple middleware functions that call next() to pass control to the next handler, enabling layered concerns like auth, validation, and logging.",
            "useCases": [
                "Composability",
                "Separation of concerns"
            ],
            "realTimeUseCases": [
                "Auth pipelines",
                "Request validation"
            ]
        },
        {
            "id": 97,
            "name": "What are Guards (in NestJS)?",
            "question": "What are Guards (in NestJS)?",
            "answer": "Guards are NestJS constructs that determine whether a request should be handled, similar to middleware but integrated with NestJS's DI and metadata system for role checks and auth.",
            "useCases": [
                "Authorization",
                "Pre-route checks"
            ],
            "realTimeUseCases": [
                "Role checks",
                "Permission gating"
            ]
        },
        {
            "id": 98,
            "name": "Difference between PUT and PATCH",
            "question": "What is the difference between PUT and PATCH?",
            "answer": "PUT replaces a resource with the provided payload (idempotent), while PATCH applies partial modifications (non-replacing), making PATCH suitable for partial updates.",
            "useCases": [
                "API design",
                "Idempotency"
            ],
            "realTimeUseCases": [
                "Update user profile",
                "Partial resource edits"
            ]
        },
        {
            "id": 99,
            "name": "Difference between 400, 401, 403, 404, 500 HTTP status codes",
            "question": "What is the difference between 400, 401, 403, 404, 500 HTTP status codes?",
            "answer": "400 = Bad Request (invalid input), 401 = Unauthorized (authentication required/invalid), 403 = Forbidden (no permissions), 404 = Not Found (resource missing), 500 = Internal Server Error (server-side failure). Use correct codes to aid clients and observability.",
            "useCases": [
                "API error handling",
                "Client guidance"
            ],
            "realTimeUseCases": [
                "Validation errors",
                "Auth failures"
            ]
        },
        {
            "id": 100,
            "name": "What is API versioning?",
            "question": "What is API versioning?",
            "answer": "API versioning manages changes to an API contract using URL/version header negotiation, or content negotiation, enabling backward compatibility while evolving endpoints.",
            "useCases": [
                "Backward compatibility",
                "Safe evolution"
            ],
            "realTimeUseCases": [
                "v1/v2 endpoints",
                "Header-based versions"
            ]
        },
        {
            "id": 101,
            "name": "What is reverse proxying?",
            "question": "What is reverse proxying?",
            "answer": "Reverse proxying routes requests from clients to backend servers, providing TLS termination, caching, and load balancing, and hiding internal topology.",
            "useCases": [
                "Security",
                "Performance"
            ],
            "realTimeUseCases": [
                "NGINX in front of Node",
                "CDN origins"
            ]
        },
        {
            "id": 102,
            "name": "What is Backpressure in Streams?",
            "question": "What is Backpressure in Streams?",
            "answer": "Backpressure is a flow-control mechanism where readable streams respect the consumer's ability to process data; writable streams signal when to pause/resume, preventing memory overflow and ensuring stable throughput.",
            "useCases": [
                "Flow control",
                "Reliability"
            ],
            "realTimeUseCases": [
                "Throttling fast producers",
                "Stable pipeline processing"
            ]
        },
        {
            "id": 103,
            "name": "What is Chunked Transfer Encoding?",
            "question": "What is Chunked Transfer Encoding?",
            "answer": "Chunked transfer encoding sends HTTP responses in pieces (chunks) without a predefined Content-Length, allowing streaming of dynamically generated content.",
            "useCases": [
                "Streaming responses",
                "Progressive rendering"
            ],
            "realTimeUseCases": [
                "Large file streaming",
                "Server push"
            ]
        },
        {
            "id": 104,
            "name": "What is Caching Strategy: TTL, LRU?",
            "question": "What is Caching Strategy: TTL, LRU?",
            "answer": "TTL (Time-To-Live) expires entries after a period; LRU (Least Recently Used) evicts least-accessed entries when full. Choose strategies based on data volatility and access patterns.",
            "useCases": [
                "Cache eviction",
                "Freshness control"
            ],
            "realTimeUseCases": [
                "Session caches",
                "Query result caching"
            ]
        },
        {
            "id": 105,
            "name": "What is the difference between Monolith and Microservices?",
            "question": "What is the difference between Monolith and Microservices?",
            "answer": "A monolith bundles functionality in a single deployable unit; microservices split functionality into smaller, independent services. Microservices improve modularity and scaling but increase operational complexity.",
            "useCases": [
                "Architecture decisions",
                "Scaling strategies"
            ],
            "realTimeUseCases": [
                "Legacy monolith migration",
                "Domain decomposition"
            ]
        },
        {
            "id": 106,
            "name": "What is Database Sharding?",
            "question": "What is Database Sharding?",
            "answer": "Sharding splits a database horizontally across multiple servers so each shard holds a subset of data, improving write scalability and reducing single-node load.",
            "useCases": [
                "Scaling writes",
                "Horizontal partitioning"
            ],
            "realTimeUseCases": [
                "User-based sharding",
                "Geo-based shards"
            ]
        },
        {
            "id": 107,
            "name": "What is Read Replicas?",
            "question": "What is Read Replicas?",
            "answer": "Read replicas are copies of a primary database used to serve read-heavy traffic, offloading queries from the master and improving read scalability.",
            "useCases": [
                "Scaling reads",
                "Reporting"
            ],
            "realTimeUseCases": [
                "Analytics queries",
                "Reporting endpoints"
            ]
        },
        {
            "id": 108,
            "name": "What is Connection Pooling in Node.js?",
            "question": "What is Connection Pooling in Node.js?",
            "answer": "Connection pooling reuses database connections from a pool to reduce overhead of creating new connections, improving performance and resource usage.",
            "useCases": [
                "DB efficiency",
                "Resource management"
            ],
            "realTimeUseCases": [
                "High-concurrency DB access",
                "API backends"
            ]
        },
        {
            "id": 109,
            "name": "What is server-side rendering (SSR) with Node.js?",
            "question": "What is server-side rendering (SSR) with Node.js?",
            "answer": "SSR renders HTML on the server before sending it to clients, improving initial load performance and SEO; Node can render apps (e.g., React) server-side and stream content progressively.",
            "useCases": [
                "SEO",
                "Faster first paint"
            ],
            "realTimeUseCases": [
                "Universal React apps",
                "Landing pages"
            ]
        },
        {
            "id": 110,
            "name": "What is JWT signature verification?",
            "question": "What is JWT signature verification?",
            "answer": "JWT signature verification checks the token's signature using a secret or public key to ensure integrity and authenticity of claims before trusting the token data.",
            "useCases": [
                "Auth security",
                "Claim validation"
            ],
            "realTimeUseCases": [
                "Token validation middleware",
                "API auth"
            ]
        },
        {
            "id": 111,
            "name": "What is Bcrypt hashing?",
            "question": "What is Bcrypt hashing?",
            "answer": "Bcrypt is a password hashing function that uses adaptive work factors and salt to make brute-force attacks computationally expensive; use it to store passwords securely.",
            "useCases": [
                "Password storage",
                "Credential protection"
            ],
            "realTimeUseCases": [
                "User account storage",
                "Auth services"
            ]
        },
        {
            "id": 112,
            "name": "What is ETag and caching headers?",
            "question": "What is ETag and caching headers?",
            "answer": "ETag is a response identifier used to validate caches; caching headers (Cache-Control, Expires) control client and intermediary caching behavior to reduce bandwidth and improve performance.",
            "useCases": [
                "Cache validation",
                "Bandwidth optimization"
            ],
            "realTimeUseCases": [
                "Conditional requests",
                "CDN caching"
            ]
        },
        {
            "id": 113,
            "name": "What is Circuit Breaker Pattern?",
            "question": "What is Circuit Breaker Pattern?",
            "answer": "Circuit Breaker prevents cascading failures by stopping calls to failing services after a threshold, allowing systems to recover and fall back gracefully.",
            "useCases": [
                "Resilience",
                "Fault tolerance"
            ],
            "realTimeUseCases": [
                "Protecting downstream APIs",
                "Retry throttling"
            ]
        },
        {
            "id": 114,
            "name": "What is Retry Pattern?",
            "question": "What is Retry Pattern?",
            "answer": "Retry pattern retries transient failures with backoff (exponential jitter) to improve robustness; combine with idempotency and circuit breakers to avoid overload.",
            "useCases": [
                "Transient fault handling",
                "Robustness"
            ],
            "realTimeUseCases": [
                "Retrying HTTP calls",
                "DB transient errors"
            ]
        },
        {
            "id": 115,
            "name": "What is Debouncing and Throttling in Node.js?",
            "question": "What is Debouncing and Throttling in Node.js?",
            "answer": "Debouncing delays a function until a quiet period ends, while throttling ensures a function runs at most once per interval. Both control event frequency to improve performance.",
            "useCases": [
                "Event handling",
                "Rate control"
            ],
            "realTimeUseCases": [
                "Search input",
                "Resize events"
            ]
        },
        {
            "id": 116,
            "name": "What is Load Testing?",
            "question": "What is Load Testing?",
            "answer": "Load testing measures system behavior under expected and peak traffic to find bottlenecks, using tools to simulate concurrent users and measure latency, throughput, and errors.",
            "useCases": [
                "Capacity planning",
                "Performance validation"
            ],
            "realTimeUseCases": [
                "Pre-release stress tests",
                "SLA verification"
            ]
        },
        {
            "id": 117,
            "name": "Tools for Load Testing (k6, JMeter, Artillery)",
            "question": "Tools for Load Testing (k6, JMeter, Artillery).",
            "answer": "k6 is a modern JS-based load tool, JMeter is a mature Java-based tool, and Artillery is lightweight and easy to use with Node; choose based on scale, scripting needs, and CI integration.",
            "useCases": [
                "Performance tools",
                "CI integration"
            ],
            "realTimeUseCases": [
                "CI load checks",
                "Stress testing"
            ]
        },
        {
            "id": 118,
            "name": "What is GraphQL with Node.js?",
            "question": "What is GraphQL with Node.js?",
            "answer": "GraphQL is a query language and runtime for APIs allowing clients to request exactly the data they need. Using Node with libraries like Apollo Server or graphql-js enables building typed, efficient APIs with single endpoint and schema-driven contracts.",
            "useCases": [
                "Flexible APIs",
                "Single endpoint"
            ],
            "realTimeUseCases": [
                "Mobile-optimized queries",
                "Schema evolution"
            ]
        },
        {
            "id": 119,
            "name": "What is Prisma ORM?",
            "question": "What is Prisma ORM?",
            "answer": "Prisma is a modern ORM providing a type-safe query API and schema-based migrations; it improves developer ergonomics and integrates well with TypeScript.",
            "useCases": [
                "Typed DB access",
                "Migrations"
            ],
            "realTimeUseCases": [
                "Type-safe queries",
                "Auto-generated clients"
            ]
        },
        {
            "id": 120,
            "name": "What is Sequelize ORM?",
            "question": "What is Sequelize ORM?",
            "answer": "Sequelize is a promise-based Node ORM for SQL databases offering model definitions, relations, and migrations; it's mature and widely used for relational DBs.",
            "useCases": [
                "SQL ORM",
                "Model mapping"
            ],
            "realTimeUseCases": [
                "CRUD services",
                "Legacy projects"
            ]
        },
        {
            "id": 121,
            "name": "What is Mongoose?",
            "question": "What is Mongoose?",
            "answer": "Mongoose is an ODM for MongoDB providing schema, validation, and middleware hooks to model MongoDB documents in Node applications.",
            "useCases": [
                "MongoDB modeling",
                "Validation"
            ],
            "realTimeUseCases": [
                "User profiles",
                "Document stores"
            ]
        },
        {
            "id": 122,
            "name": "What is ACID in databases?",
            "question": "What is ACID in databases?",
            "answer": "ACID stands for Atomicity, Consistency, Isolation, Durabilityâ€”properties that guarantee reliable transaction processing in relational databases.",
            "useCases": [
                "Transactional integrity",
                "Financial systems"
            ],
            "realTimeUseCases": [
                "Banking transactions",
                "Order processing"
            ]
        },
        {
            "id": 123,
            "name": "What is CAP theorem?",
            "question": "What is CAP theorem?",
            "answer": "CAP theorem states a distributed system can guarantee at most two of Consistency, Availability, and Partition tolerance; trade-offs guide design depending on application priorities.",
            "useCases": [
                "Distributed design",
                "Consistency models"
            ],
            "realTimeUseCases": [
                "Eventual consistency choices",
                "Partition-tolerant services"
            ]
        },
        {
            "id": 124,
            "name": "What is Event Sourcing Architecture?",
            "question": "What is Event Sourcing Architecture?",
            "answer": "Event Sourcing persists state changes as an immutable sequence of events; the current state is derived by replaying events. It enables auditability, temporal queries, and easier reasoning about state changes.",
            "useCases": [
                "Audit logs",
                "Temporal queries"
            ],
            "realTimeUseCases": [
                "Financial ledgers",
                "Audit trails"
            ]
        },
        {
            "id": 125,
            "name": "What is CQRS pattern?",
            "question": "What is CQRS pattern?",
            "answer": "CQRS separates read and write models: commands mutate state while queries read optimized projections. It allows independent scaling and optimization of reads and writes.",
            "useCases": [
                "Scaling reads/writes",
                "Complex domains"
            ],
            "realTimeUseCases": [
                "High-read services",
                "Reporting projections"
            ]
        },
        {
            "id": 126,
            "name": "What is Zero Downtime Deployment?",
            "question": "What is Zero Downtime Deployment?",
            "answer": "Zero-downtime deploys update services without interrupting traffic using strategies like rolling updates, blue/green, or canary releases with health checks and load balancer orchestration.",
            "useCases": [
                "High availability",
                "Safe releases"
            ],
            "realTimeUseCases": [
                "Rolling updates in Kubernetes",
                "Canary deployments"
            ]
        },
        {
            "id": 127,
            "name": "What is graceful shutdown in Node.js?",
            "question": "What is graceful shutdown in Node.js?",
            "answer": "Graceful shutdown lets servers finish inflight requests, close resources, and exit cleanly on signals (SIGINT/SIGTERM), preventing data loss and improving reliability during restarts.",
            "useCases": [
                "Deployment safety",
                "Resource cleanup"
            ],
            "realTimeUseCases": [
                "Handling SIGTERM in containers",
                "Draining connections"
            ]
        },
        {
            "id": 128,
            "name": "What is Heap Memory in Node.js?",
            "question": "What is Heap Memory in Node.js?",
            "answer": "Heap memory is where JS objects are allocated in V8; monitoring heap usage helps detect memory leaks and tune V8 flags for performance.",
            "useCases": [
                "Memory profiling",
                "Leak detection"
            ],
            "realTimeUseCases": [
                "Heap snapshots",
                "Memory thresholds"
            ]
        },
        {
            "id": 129,
            "name": "What is Garbage Collection in V8?",
            "question": "What is Garbage Collection in V8?",
            "answer": "V8 performs automatic garbage collection to reclaim unused memory via generational collectors and compaction; tuning flags can influence GC behavior and pause times.",
            "useCases": [
                "Memory management",
                "Performance tuning"
            ],
            "realTimeUseCases": [
                "Reducing GC pauses",
                "Optimizing long-running services"
            ]
        },
        {
            "id": 130,
            "name": "What is Memory Leak in Node.js?",
            "question": "What is Memory Leak in Node.js?",
            "answer": "A memory leak occurs when objects are unintentionally retained, preventing GC from freeing memory; common causes include global references, unbounded caches, and event listener leaks.",
            "useCases": [
                "Debugging",
                "Stability"
            ],
            "realTimeUseCases": [
                "Fixing long-running service leaks",
                "Identifying retained closures"
            ]
        },
        {
            "id": 131,
            "name": "What is Hot Reloading (Nodemon)?",
            "question": "What is Hot Reloading (Nodemon)?",
            "answer": "Nodemon watches files and restarts the Node process on changes, speeding developer feedback loops; hot module replacement is a more advanced technique to swap modules without full restarts.",
            "useCases": [
                "Developer productivity",
                "Rapid iteration"
            ],
            "realTimeUseCases": [
                "Auto-restart dev servers",
                "Faster local testing"
            ]
        },
        {
            "id": 132,
            "name": "What is Cold Start?",
            "question": "What is Cold Start?",
            "answer": "Cold start is the initial startup latency when a serverless function or process boots and initializes dependencies; minimizing cold start improves responsiveness for rarely-invoked functions.",
            "useCases": [
                "Serverless optimization",
                "Latency reduction"
            ],
            "realTimeUseCases": [
                "AWS Lambda warmers",
                "Provisioned concurrency"
            ]
        },
        {
            "id": 133,
            "name": "What is Serverless with Node.js?",
            "question": "What is Serverless with Node.js?",
            "answer": "Serverless runs functions on-demand without infrastructure management; Node is a popular runtime for serverless functions offering fast startup and concise handlers for APIs and event processing.",
            "useCases": [
                "Event-driven processing",
                "Cost-effective scaling"
            ],
            "realTimeUseCases": [
                "AWS Lambda APIs",
                "Event-driven jobs"
            ]
        },
        {
            "id": 134,
            "name": "What are AWS Lambda, API Gateway, DynamoDB integrations with Node.js?",
            "question": "What are AWS Lambda, API Gateway, DynamoDB integrations with Node.js?",
            "answer": "These AWS services combine to build serverless APIs: API Gateway routes HTTP traffic to Lambda functions written in Node; Lambda handles logic; DynamoDB stores data in a scalable NoSQL table.",
            "useCases": [
                "Serverless APIs",
                "Event-driven apps"
            ],
            "realTimeUseCases": [
                "Webhook handlers",
                "Serverless backends"
            ]
        },
        {
            "id": 135,
            "name": "What is message acknowledgment in queues?",
            "question": "What is message acknowledgment in queues?",
            "answer": "Message acknowledgment confirms successful processing to the broker, allowing it to remove messages; lack of ack often triggers redelivery and helps ensure at-least-once or exactly-once semantics depending on broker and design.",
            "useCases": [
                "Reliable processing",
                "Exactly-once patterns"
            ],
            "realTimeUseCases": [
                "Order processing",
                "Retry handling"
            ]
        },
        {
            "id": 136,
            "name": "What is Cron Job in Node.js?",
            "question": "What is Cron Job in Node.js?",
            "answer": "Cron jobs schedule recurring tasks; libraries like node-cron allow defining cron expressions to run jobs at intervals for maintenance, reporting, or cleanup.",
            "useCases": [
                "Scheduled tasks",
                "Maintenance"
            ],
            "realTimeUseCases": [
                "Daily reports",
                "Cache cleanup"
            ]
        },
        {
            "id": 137,
            "name": "What is node-cron?",
            "question": "What is node-cron?",
            "answer": "node-cron is a lightweight scheduler for running cron-style jobs in Node; it's useful for local scheduled tasks but not a replacement for distributed schedulers in production.",
            "useCases": [
                "Local scheduling",
                "Dev tools"
            ],
            "realTimeUseCases": [
                "Periodic reports",
                "Housekeeping"
            ]
        },
        {
            "id": 138,
            "name": "What is Webhook?",
            "question": "What is Webhook?",
            "answer": "A webhook is an HTTP callback where a service posts events to a configured URL; webhooks enable event-driven integrations between systems.",
            "useCases": [
                "Event integrations",
                "Callbacks"
            ],
            "realTimeUseCases": [
                "Payment notifications",
                "Third-party integrations"
            ]
        },
        {
            "id": 139,
            "name": "What is OAuth2 authorization?",
            "question": "What is OAuth2 authorization?",
            "answer": "OAuth2 is an authorization framework allowing third-party applications to obtain limited access on behalf of users via tokens and defined flows (authorization code, client credentials). It standardizes delegated authorization.",
            "useCases": [
                "Third-party access",
                "APIs auth"
            ],
            "realTimeUseCases": [
                "Login with Google",
                "Service-to-service tokens"
            ]
        },
        {
            "id": 140,
            "name": "What is SSO (Single Sign-On)?",
            "question": "What is SSO (Single Sign-On)?",
            "answer": "SSO allows users to authenticate once and access multiple services without reauthenticating by sharing trust via tokens or federated identity protocols (SAML, OAuth/OIDC).",
            "useCases": [
                "Unified auth",
                "User convenience"
            ],
            "realTimeUseCases": [
                "Enterprise portals",
                "Integrated apps"
            ]
        }
    ],
    "Express JS": [
        {
            "id": 1,
            "name": "What is Express.js?",
            "question": "What is Express.js?",
            "answer": "Express.js is a minimal, unopinionated web framework for Node.js that provides routing, middleware support, and utilities to build REST APIs and server-side applications quickly. It's the industry standard for Node backend development.",
            "useCases": [
                "REST APIs",
                "Web servers"
            ],
            "realTimeUseCases": [
                "eCommerce backends",
                "Microservices"
            ]
        },
        {
            "id": 2,
            "name": "Why do we use Express.js in Node applications?",
            "question": "Why do we use Express.js in Node applications?",
            "answer": "Express provides a lightweight abstraction over Node's HTTP module, simplifying routing, middleware management, and request/response handling. It reduces boilerplate code and enables rapid development of scalable APIs.",
            "useCases": [
                "Fast API development",
                "Code organization"
            ],
            "realTimeUseCases": [
                "Startup MVPs",
                "Enterprise APIs"
            ]
        },
        {
            "id": 3,
            "name": "What are middleware functions in Express.js?",
            "question": "What are middleware functions in Express.js?",
            "answer": "Middleware functions are reusable code that sits between request and response. They can modify requests/responses, handle authentication, logging, validation, or perform business logic. Middleware is chained using next() to pass control to the next handler.",
            "useCases": [
                "Auth checks",
                "Request logging",
                "Data validation"
            ],
            "realTimeUseCases": [
                "JWT verification",
                "Request body parsing"
            ]
        },
        {
            "id": 4,
            "name": "What is the role of app.use() in Express?",
            "question": "What is the role of app.use() in Express?",
            "answer": "app.use() mounts middleware or routers at a specified path. It applies middleware globally to all routes or conditionally to specific path prefixes. Example: app.use('/api', apiRouter) mounts the apiRouter for all /api/* routes.",
            "useCases": [
                "Mounting routers",
                "Global middleware"
            ],
            "realTimeUseCases": [
                "API versioning",
                "/api/v1 routing"
            ]
        },
        {
            "id": 5,
            "name": "What is the difference between app.get() and app.post()?",
            "question": "What is the difference between app.get() and app.post()?",
            "answer": "app.get() handles HTTP GET requests (fetch data without side effects), while app.post() handles POST requests (send data with side effects). GET requests should be idempotent; POST requests create/modify resources.",
            "useCases": [
                "Fetching data",
                "Creating resources"
            ],
            "realTimeUseCases": [
                "Product listing",
                "User registration"
            ]
        },
        {
            "id": 6,
            "name": "What is Express Router and why is it used?",
            "question": "What is Express Router and why is it used?",
            "answer": "Express Router is a mini Express application that handles routing independently. It allows modular route organization by grouping related routes (e.g., user routes, product routes) and mounting them on the main app, improving code maintainability and scalability.",
            "useCases": [
                "Modular routing",
                "Namespace isolation"
            ],
            "realTimeUseCases": [
                "User routes (/users)",
                "Product routes (/products)"
            ]
        },
        {
            "id": 7,
            "name": "How do you create modular routes in Express.js?",
            "question": "How do you create modular routes in Express.js?",
            "answer": "Create separate router files using express.Router(), define routes within them, then mount them on the main app using app.use(). Example: const userRouter = express.Router(); userRouter.get('/:id'); app.use('/users', userRouter);",
            "useCases": [
                "Scalable architecture",
                "Code reuse"
            ],
            "realTimeUseCases": [
                "Large eCommerce projects",
                "Multi-domain apps"
            ]
        },
        {
            "id": 8,
            "name": "What is the requestâ€“response cycle in Express?",
            "question": "What is the requestâ€“response cycle in Express?",
            "answer": "The cycle flows: Request â†’ Express receives â†’ Routing â†’ Middleware chain (each calls next()) â†’ Route handler â†’ Response sent. Once res.send/json/end is called, the cycle completes. Calling next() after send causes error.",
            "useCases": [
                "Understanding flow",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Middleware chaining",
                "Error handling"
            ]
        },
        {
            "id": 9,
            "name": "What is the purpose of next() in middleware?",
            "question": "What is the purpose of next() in middleware?",
            "answer": "next() passes control to the next middleware or route handler in the chain. If not called, the request hangs. Calling next(error) skips to error-handling middleware. Each middleware must call next() or send a response.",
            "useCases": [
                "Middleware chaining",
                "Flow control"
            ],
            "realTimeUseCases": [
                "Auth checks",
                "Logging before handlers"
            ]
        },
        {
            "id": 10,
            "name": "What is error-handling middleware in Express.js?",
            "question": "What is error-handling middleware in Express.js?",
            "answer": "Error-handling middleware has 4 parameters (err, req, res, next) instead of 3. It catches errors thrown in route handlers or other middleware. Must be mounted AFTER all other app.use/routes. Called via next(error).",
            "useCases": [
                "Global error handling",
                "Centralized logging"
            ],
            "realTimeUseCases": [
                "Catching 404s",
                "Validating input errors"
            ]
        },
        {
            "id": 11,
            "name": "What is the difference between application-level and router-level middleware?",
            "question": "What is the difference between application-level and router-level middleware?",
            "answer": "Application-level middleware applies globally using app.use(); router-level middleware applies only to specific routers using router.use(). Router-level middleware provides isolation and namespace control for modular applications.",
            "useCases": [
                "Global vs scoped middleware"
            ],
            "realTimeUseCases": [
                "CORS for all vs specific routes"
            ]
        },
        {
            "id": 12,
            "name": "How do you handle CORS in Express.js?",
            "question": "How do you handle CORS in Express.js?",
            "answer": "Use the cors package: npm install cors, then app.use(cors()) for all origins or app.use(cors({origin: 'https://example.com'})) for specific origins. Set allowed methods, headers, and credentials to control cross-origin requests.",
            "useCases": [
                "Frontend-backend communication",
                "Public APIs"
            ],
            "realTimeUseCases": [
                "React frontend on different port",
                "Third-party integrations"
            ]
        },
        {
            "id": 13,
            "name": "How do you serve static files in Express.js?",
            "question": "How do you serve static files in Express.js?",
            "answer": "Use app.use(express.static('public')) to serve files from the 'public' directory. Files are accessible at http://localhost:3000/filename. Configure multiple dirs: app.use(express.static('public')); app.use(express.static('uploads'));",
            "useCases": [
                "Serving images, CSS, JS"
            ],
            "realTimeUseCases": [
                "Product images",
                "PDFs, CSVs"
            ]
        },
        {
            "id": 14,
            "name": "What are the different ways to handle authentication in Express?",
            "question": "What are the different ways to handle authentication in Express?",
            "answer": "Session-based (req.session), JWT (Bearer tokens), API keys, OAuth2, Basic Auth. JWT is stateless and scalable; sessions require server memory. Each has trade-offs in security, scalability, and complexity.",
            "useCases": [
                "User authentication"
            ],
            "realTimeUseCases": [
                "Login endpoints",
                "Protected routes"
            ]
        },
        {
            "id": 15,
            "name": "How do you secure Express apps using Helmet.js?",
            "question": "How do you secure Express apps using Helmet.js?",
            "answer": "Install Helmet: npm install helmet, then app.use(helmet()). It sets security HTTP headers (X-Frame-Options, CSP, HSTS, etc.) to prevent clickjacking, XSS, MIME sniffing, and other attacks.",
            "useCases": [
                "Security hardening"
            ],
            "realTimeUseCases": [
                "Production APIs"
            ]
        },
        {
            "id": 16,
            "name": "What is the difference between res.send() and res.json()?",
            "question": "What is the difference between res.send() and res.json()?",
            "answer": "res.send() sends a string or HTML; res.json() sends JSON with Content-Type: application/json header and automatically stringifies objects. Use res.json() for APIs; res.send() for mixed content.",
            "useCases": [
                "API responses",
                "Mixed content"
            ],
            "realTimeUseCases": [
                "REST endpoints",
                "HTML templates"
            ]
        },
        {
            "id": 17,
            "name": "How do you implement JWT authentication in Express.js?",
            "question": "How do you implement JWT authentication in Express.js?",
            "answer": "Create tokens with jwt.sign(payload, secret) on login; verify with jwt.verify() in middleware. Store secret in env vars. Tokens sent as Bearer in Authorization header. Middleware extracts & verifies before handler execution.",
            "useCases": [
                "Stateless auth",
                "Microservices"
            ],
            "realTimeUseCases": [
                "Login/logout flows",
                "Protected routes"
            ]
        },
        {
            "id": 18,
            "name": "How do you protect routes using middleware in Express?",
            "question": "How do you protect routes using middleware in Express?",
            "answer": "Create auth middleware: const auth = (req, res, next) => { verify JWT; if valid next(); else res.status(401).json(...) }. Mount on routes: router.get('/admin', auth, handler). Middleware blocks unauthorized access.",
            "useCases": [
                "Route protection"
            ],
            "realTimeUseCases": [
                "Admin routes",
                "User profiles"
            ]
        },
        {
            "id": 19,
            "name": "What is the purpose of express.json() and express.urlencoded()?",
            "question": "What is the purpose of express.json() and express.urlencoded()?",
            "answer": "express.json() parses JSON request bodies; express.urlencoded() parses form data. Both are middleware: app.use(express.json()); app.use(express.urlencoded({extended:true})). Required to access req.body in handlers.",
            "useCases": [
                "Request parsing"
            ],
            "realTimeUseCases": [
                "POST/PUT endpoints"
            ]
        },
        {
            "id": 20,
            "name": "How do you handle file uploads in Express.js?",
            "question": "How do you handle file uploads in Express.js?",
            "answer": "Use Multer middleware: const upload = multer({dest: 'uploads/'}); app.post('/upload', upload.single('file'), handler). Multer parses multipart/form-data, stores files, and populates req.file with metadata.",
            "useCases": [
                "File handling",
                "Image uploads"
            ],
            "realTimeUseCases": [
                "Product images",
                "User avatars"
            ]
        },
        {
            "id": 21,
            "name": "What is Multer and why is it used?",
            "question": "What is Multer and why is it used?",
            "answer": "Multer is Node.js middleware for handling file uploads. It parses multipart/form-data, stores files to disk or memory, and provides file metadata (name, size, MIME type). Essential for eCommerce product images and documents.",
            "useCases": [
                "File uploads",
                "Image storage"
            ],
            "realTimeUseCases": [
                "Bulk product imports",
                "User profile pictures"
            ]
        },
        {
            "id": 22,
            "name": "What is the meaning of 'Cannot set headers after they are sent'?",
            "question": "What is the meaning of 'Cannot set headers after they are sent'?",
            "answer": "This error occurs when code tries to set headers (res.setHeader, res.status, res.redirect) AFTER res.send/json/end is called. Once response headers are sent, they cannot be modified. Fix by ensuring only one response method per request.",
            "useCases": [
                "Debugging"
            ],
            "realTimeUseCases": [
                "Error handling"
            ]
        },
        {
            "id": 23,
            "name": "How do you implement API versioning in Express?",
            "question": "How do you implement API versioning in Express?",
            "answer": "URL versioning: app.use('/api/v1', v1Routes); app.use('/api/v2', v2Routes). Header versioning: check req.header('api-version'). URL is preferred for clarity and caching. Allows backward compatibility during API evolution.",
            "useCases": [
                "Backward compatibility"
            ],
            "realTimeUseCases": [
                "Multiple API versions"
            ]
        },
        {
            "id": 24,
            "name": "What are best practices for structuring an Express.js application?",
            "question": "What are best practices for structuring an Express.js application?",
            "answer": "Use MVC: models/, controllers/, routes/, services/. Separate concerns: business logic in services, database in models, request handling in controllers. Use routers for modular routes. Env-based config. Clear error handling. Follow DRY principle.",
            "useCases": [
                "Scalable architecture"
            ],
            "realTimeUseCases": [
                "Large projects"
            ]
        },
        {
            "id": 25,
            "name": "How do you connect Express.js to a database (MongoDB/SQL)?",
            "question": "How do you connect Express.js to a database (MongoDB/SQL)?",
            "answer": "For MongoDB: mongoose.connect(uri). For SQL: create connection pool using mysql2, pg, or oracle client. Store connection string in env vars. Wrap in try-catch for error handling. Use DAOs/models to abstract database logic.",
            "useCases": [
                "Database integration"
            ],
            "realTimeUseCases": [
                "eCommerce backends"
            ]
        },
        {
            "id": 26,
            "name": "What is the difference between synchronous and asynchronous middleware?",
            "question": "What is the difference between synchronous and asynchronous middleware?",
            "answer": "Sync middleware executes immediately; async middleware uses async/await or promises. Async: async (req, res, next) => { await dbCall(); next(); }. Error in async caught by error handler if next(error) called. Always use async for I/O.",
            "useCases": [
                "Async operations"
            ],
            "realTimeUseCases": [
                "Database queries"
            ]
        },
        {
            "id": 27,
            "name": "How do you handle global exceptions in Express.js?",
            "question": "How do you handle global exceptions in Express.js?",
            "answer": "Use error-handling middleware (4 params) mounted LAST: app.use((err, req, res, next) => { res.status(err.status || 500).json({error: err.message}) }). Wrap route handlers in try-catch; call next(error) to trigger error handler.",
            "useCases": [
                "Centralized error handling"
            ],
            "realTimeUseCases": [
                "Production logging"
            ]
        },
        {
            "id": 28,
            "name": "How do you implement rate limiting in Express.js?",
            "question": "How do you implement rate limiting in Express.js?",
            "answer": "Use express-rate-limit: const limiter = rateLimit({windowMs: 15*60*1000, max: 100}); app.use(limiter). Tracks IP and limits requests per window. Configure store (memory, Redis) for distributed systems. Protect /login, /api endpoints.",
            "useCases": [
                "DDoS protection",
                "Abuse prevention"
            ],
            "realTimeUseCases": [
                "Login throttling",
                "API quotas"
            ]
        },
        {
            "id": 29,
            "name": "How do you use Morgan for logging in Express?",
            "question": "How do you use Morgan for logging in Express?",
            "answer": "npm install morgan; app.use(morgan('combined')). Logs HTTP requests with method, URL, status, response time. Use 'dev' for development (colored), 'combined' for production. Pipe logs to files for persistence.",
            "useCases": [
                "Request logging"
            ],
            "realTimeUseCases": [
                "Debugging",
                "Analytics"
            ]
        },
        {
            "id": 30,
            "name": "What is clustering in Node.js and how does Express support it?",
            "question": "What is clustering in Node.js and how does Express support it?",
            "answer": "Clustering spawns multiple Express processes (workers) across CPU cores, sharing a server port via a master process. Use Node cluster module or PM2. Improves throughput by handling requests in parallel on multi-core machines.",
            "useCases": [
                "Scaling",
                "High-concurrency"
            ],
            "realTimeUseCases": [
                "Production servers"
            ]
        },
        {
            "id": 31,
            "name": "How do you design RESTful APIs using Express.js in a scalable microservices architecture?",
            "question": "How do you design RESTful APIs using Express.js in a scalable microservices architecture?",
            "answer": "Each microservice is an Express app with clear responsibility (users, orders, payments). Use HTTP + JSON for communication. API Gateway routes client requests to services. Implement service discovery, load balancing. Use JWT for inter-service auth.",
            "useCases": [
                "Microservices design"
            ],
            "realTimeUseCases": [
                "eCommerce platform"
            ]
        },
        {
            "id": 32,
            "name": "How do you structure controllers, services, and routes for large Express.js projects?",
            "question": "How do you structure controllers, services, and routes for large Express.js projects?",
            "answer": "Routes: define endpoints (GET /users). Controllers: handle req/res, call services. Services: business logic, database calls, external APIs. Models: database schemas. This separation enables testing, scalability, and code reuse.",
            "useCases": [
                "Clean architecture"
            ],
            "realTimeUseCases": [
                "Enterprise apps"
            ]
        },
        {
            "id": 33,
            "name": "How do you implement global error handling in Express for REST APIs?",
            "question": "How do you implement global error handling in Express for REST APIs?",
            "answer": "Create custom error classes (ValidationError, NotFoundError). Throw in handlers; catch in middleware. Error middleware logs, formats response with HTTP status and message. Ensures consistent error responses across all endpoints.",
            "useCases": [
                "Error standardization"
            ],
            "realTimeUseCases": [
                "API consistency"
            ]
        },
        {
            "id": 34,
            "name": "How do you implement versioning in Express REST APIs for backward compatibility?",
            "question": "How do you implement versioning in Express REST APIs for backward compatibility?",
            "answer": "URL versioning: /api/v1/users, /api/v2/users. Header versioning: API-Version header. Maintain old versions alongside new. Update clients gradually. New version can coexist with old; ensures no breaking changes.",
            "useCases": [
                "API evolution"
            ],
            "realTimeUseCases": [
                "Client migration"
            ]
        },
        {
            "id": 35,
            "name": "How do you secure REST APIs in Express using middleware and JWT?",
            "question": "How do you secure REST APIs in Express using middleware and JWT?",
            "answer": "Auth middleware: extract token from Authorization header, verify JWT using secret, attach user to req. Protect routes: app.post('/orders', auth, createOrder). Validate scopes/roles for authorization. Use HTTPS in production.",
            "useCases": [
                "API security"
            ],
            "realTimeUseCases": [
                "Protected endpoints"
            ]
        },
        {
            "id": 36,
            "name": "How do you validate incoming API request payloads in Express.js?",
            "question": "How do you validate incoming API request payloads in Express.js?",
            "answer": "Use Joi, Zod, or express-validator. Define schemas: const schema = Joi.object({email, password}). Validate: const {error, value} = schema.validate(req.body). Return 400 if invalid. Prevents malformed data and SQL injection.",
            "useCases": [
                "Input validation"
            ],
            "realTimeUseCases": [
                "User registration"
            ]
        },
        {
            "id": 37,
            "name": "How do you optimize Express.js API performance under high traffic?",
            "question": "How do you optimize Express.js API performance under high traffic?",
            "answer": "Use caching (Redis), pagination for large datasets, index databases, compress responses (gzip), use CDN for static files, implement rate limiting, async processing (queues). Monitor with APM tools. Horizontal scaling with load balancers.",
            "useCases": [
                "Performance tuning"
            ],
            "realTimeUseCases": [
                "Black Friday sales"
            ]
        },
        {
            "id": 38,
            "name": "How do you handle rate limiting and throttling in Express.js APIs?",
            "question": "How do you handle rate limiting and throttling in Express.js APIs?",
            "answer": "Rate limiting: limit requests per IP per time window (express-rate-limit). Throttling: delay/defer requests to smooth load. Combine both: limit first, then throttle for burst handling. Use Redis for distributed rate limiting.",
            "useCases": [
                "Traffic control"
            ],
            "realTimeUseCases": [
                "Flash sales"
            ]
        },
        {
            "id": 39,
            "name": "How do you implement pagination, filtering, and sorting in REST APIs?",
            "question": "How do you implement pagination, filtering, and sorting in REST APIs?",
            "answer": "Pagination: skip, limit query params. Filtering: match on fields (req.query.status). Sorting: sort param (asc/desc). Query: db.find({status}).skip(skip).limit(limit).sort({createdAt: -1}). Reduces response size and improves performance.",
            "useCases": [
                "Data handling"
            ],
            "realTimeUseCases": [
                "Product listing"
            ]
        },
        {
            "id": 40,
            "name": "How do you perform schema validation for REST requests using JOI/Zod?",
            "question": "How do you perform schema validation for REST requests using JOI/Zod?",
            "answer": "Joi: const schema = Joi.object({email: Joi.string().email()}). Zod: const schema = z.object({email: z.string().email()}). Validate: schema.validate(data). Use as middleware. Provides type safety and detailed error messages.",
            "useCases": [
                "Schema validation"
            ],
            "realTimeUseCases": [
                "Type safety"
            ]
        },
        {
            "id": 41,
            "name": "How do you implement JWT authentication in Express.js?",
            "question": "How do you implement JWT authentication in Express.js?",
            "answer": "On login: create token with jwt.sign({userId, role}, SECRET, {expiresIn: '1h'}). Return token to client. On request: extract from Authorization header; verify with jwt.verify(token, SECRET). Decode for userId/role. Error if expired or invalid.",
            "useCases": [
                "Auth flow"
            ],
            "realTimeUseCases": [
                "Login/protected routes"
            ]
        },
        {
            "id": 42,
            "name": "How do you design a refresh token flow in Express for long-lived sessions?",
            "question": "How do you design a refresh token flow in Express for long-lived sessions?",
            "answer": "Issue short-lived access token (1h) and long-lived refresh token (7d). Store refresh token in db/cookie. On expiry: client sends refresh token; server validates, issues new access token. Logout: invalidate refresh token in db.",
            "useCases": [
                "Session management"
            ],
            "realTimeUseCases": [
                "Mobile apps"
            ]
        },
        {
            "id": 43,
            "name": "How do you implement role-based access control (RBAC) using JWT claims?",
            "question": "How do you implement role-based access control (RBAC) using JWT claims?",
            "answer": "Encode role in JWT: jwt.sign({userId, role: 'admin'}, SECRET). Middleware checks role: if(req.user.role !== 'admin') return 401. Protect routes by role. Combine with db checks for dynamic permissions.",
            "useCases": [
                "Authorization"
            ],
            "realTimeUseCases": [
                "Admin vs customer routes"
            ]
        },
        {
            "id": 44,
            "name": "How do you secure JWT storage on the frontend using Axios?",
            "question": "How do you secure JWT storage on the frontend using Axios?",
            "answer": "Store token in httpOnly cookie (secure, sameSite) set by server. Avoid localStorage (XSS risk). Axios interceptor auto-includes cookie. Alternative: sessionStorage + manual header injection if using custom storage. Always use HTTPS.",
            "useCases": [
                "Frontend security"
            ],
            "realTimeUseCases": [
                "React apps"
            ]
        },
        {
            "id": 45,
            "name": "How do you handle JWT expiry and silent token refresh in React + Axios?",
            "question": "How do you handle JWT expiry and silent token refresh in React + Axios?",
            "answer": "Axios interceptor detects 401. Call refresh endpoint to get new token. Retry original request. Store tokens securely. Handle refresh failures by redirecting to login. Implement exponential backoff to avoid infinite loops.",
            "useCases": [
                "Token management"
            ],
            "realTimeUseCases": [
                "Seamless UX"
            ]
        },
        {
            "id": 46,
            "name": "How do you invalidate JWT tokens during logout in a microservices setup?",
            "question": "How do you invalidate JWT tokens during logout in a microservices setup?",
            "answer": "JWTs are stateless; invalidation requires a blacklist (db/Redis) or token revocation endpoint. Store token jti in blacklist on logout. Middleware checks blacklist. Alternative: short expiry + refresh token rotation; invalidate refresh on logout.",
            "useCases": [
                "Logout security"
            ],
            "realTimeUseCases": [
                "Immediate logout"
            ]
        },
        {
            "id": 47,
            "name": "How do you manage permissions for CUSTOMER vs ADMIN roles in your eCommerce project?",
            "question": "How do you manage permissions for CUSTOMER vs ADMIN roles in your eCommerce project?",
            "answer": "Encode role in JWT. Customers: view products, place orders, view orders. Admins: manage products, orders, users, promotions. Use role-based middleware on routes. DB checks for additional permission validation. Log privileged actions.",
            "useCases": [
                "Role management"
            ],
            "realTimeUseCases": [
                "Portal separation"
            ]
        },
        {
            "id": 48,
            "name": "How do you protect internal microservice-to-microservice communication with JWT?",
            "question": "How do you protect internal microservice-to-microservice communication with JWT?",
            "answer": "Each service has a service account with JWT credentials. Services verify tokens from other services using shared secret or public key. Implement rate limiting between services. Use service discovery for endpoint resolution.",
            "useCases": [
                "Microservice auth"
            ],
            "realTimeUseCases": [
                "Service calls"
            ]
        },
        {
            "id": 49,
            "name": "How do you configure Axios interceptors for JWT injection in React apps?",
            "question": "How do you configure Axios interceptors for JWT injection in React apps?",
            "answer": "axios.interceptors.request.use((config) => { config.headers.Authorization = 'Bearer ' + token; return config; }). Response interceptor handles 401 by refreshing token. Error interceptor logs/notifies user. Centralize in axiosInstance.",
            "useCases": [
                "Token injection"
            ],
            "realTimeUseCases": [
                "API auth"
            ]
        },
        {
            "id": 50,
            "name": "How do you handle global error handling for API failures using Axios?",
            "question": "How do you handle global error handling for API failures using Axios?",
            "answer": "Response interceptor catches all errors: (error) => { if (error.response.status === 401) logout(); else toast(error.message); }. Request interceptor retries on network errors. Handle network failures vs API errors differently.",
            "useCases": [
                "Error handling"
            ],
            "realTimeUseCases": [
                "User feedback"
            ]
        },
        {
            "id": 51,
            "name": "How do you implement API retries and exponential backoff using Axios?",
            "question": "How do you implement API retries and exponential backoff using Axios?",
            "answer": "Interceptor retries on 5xx/network errors. Exponential backoff: delay = base * (2 ^ retryCount). Stop after max retries. Libraries: axios-retry. Prevents cascading failures; improves reliability.",
            "useCases": [
                "Resilience"
            ],
            "realTimeUseCases": [
                "Transient failures"
            ]
        },
        {
            "id": 52,
            "name": "How do you design Axios-based service-layer architecture to communicate with multiple microservices?",
            "question": "How do you design Axios-based service-layer architecture to communicate with multiple microservices?",
            "answer": "Create API clients per service: userService.get(id), orderService.create(). Each client configures endpoint + auth. Centralize interceptors (auth, errors, retries). Abstract HTTP layer from components. Enables easy service endpoint changes.",
            "useCases": [
                "Service communication"
            ],
            "realTimeUseCases": [
                "eCommerce app"
            ]
        },
        {
            "id": 53,
            "name": "How do you secure Axios requests against XSS and CSRF attacks?",
            "question": "How do you secure Axios requests against XSS and CSRF attacks?",
            "answer": "XSS: sanitize inputs, use Content Security Policy. CSRF: backend sends CSRF token; Axios auto-includes in header. Use sameSite cookies. Store tokens securely (httpOnly). Never eval() or innerHTML with user data.",
            "useCases": [
                "Security"
            ],
            "realTimeUseCases": [
                "Production apps"
            ]
        },
        {
            "id": 54,
            "name": "How do you implement Redis caching for frequently accessed eCommerce APIs?",
            "question": "How do you implement Redis caching for frequently accessed eCommerce APIs?",
            "answer": "On product GET: check Redis; if hit, return. If miss, query DB, cache with TTL (15min), return. On product update: invalidate cache. Use cache patterns: cache-aside, write-through. Reduces DB load, improves response time.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Product pages"
            ]
        },
        {
            "id": 55,
            "name": "What caching strategy do you use for product details and category listing?",
            "question": "What caching strategy do you use for product details and category listing?",
            "answer": "Cache-aside for product details: check Redis > DB > cache result. TTL: 1 hour. Invalidate on update. Category listing: cache longer (24h) as less volatile. Use tags/patterns for batch invalidation. Monitor cache hit ratio.",
            "useCases": [
                "Caching strategy"
            ],
            "realTimeUseCases": [
                "eCommerce"
            ]
        },
        {
            "id": 56,
            "name": "How do you design cache invalidation strategies in a microservices ecosystem?",
            "question": "How do you design cache invalidation strategies in a microservices ecosystem?",
            "answer": "Event-driven: when order service updates, publish event. Cache service listens, invalidates related caches. TTL-based: expire entries periodically. Dependency tracking: cache interdependencies. Prevents stale data across services.",
            "useCases": [
                "Consistency"
            ],
            "realTimeUseCases": [
                "Multiple services"
            ]
        },
        {
            "id": 57,
            "name": "How do you implement in-memory caching vs distributed caching in Express.js?",
            "question": "How do you implement in-memory caching vs distributed caching in Express.js?",
            "answer": "In-memory: Map/object, fast, single instance only. Distributed: Redis/Memcached, shared across instances, slower but consistent. Single instance: in-memory. Multiple instances: Redis. Hybrid: in-memory for local, Redis for shared.",
            "useCases": [
                "Caching design"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 58,
            "name": "How do you reduce database calls in high-traffic eCommerce APIs using caching layers?",
            "question": "How do you reduce database calls in high-traffic eCommerce APIs using caching layers?",
            "answer": "Multi-layer: browser cache > CDN > app cache (Redis) > db. Cache products, categories, user profiles. Invalidate on updates. Monitor cache effectiveness. Combine with pagination, indexing, denormalization for optimal performance.",
            "useCases": [
                "Performance optimization"
            ],
            "realTimeUseCases": [
                "Peak traffic"
            ]
        },
        {
            "id": 59,
            "name": "How do you optimize bulk reads/writes in Express.js using caching layers?",
            "question": "How do you optimize bulk reads/writes in Express.js using caching layers?",
            "answer": "Batch reads: use IN queries. Cache aggregated results. Batch writes: bulk insert to DB, then update cache. Use write-through cache (write to DB, then cache). Message queue for async bulk operations.",
            "useCases": [
                "Bulk operations"
            ],
            "realTimeUseCases": [
                "Batch imports"
            ]
        },
        {
            "id": 60,
            "name": "How do you identify and fix bottlenecks in Express using profiling tools?",
            "question": "How do you identify and fix bottlenecks in Express using profiling tools?",
            "answer": "Use clinic.js, autocannon for load testing. Profile CPU: node --prof. Identify hot functions. Monitor memory leaks. Check database query performance (EXPLAIN plans). Use APM (New Relic, DataDog). Optimize or cache slow paths.",
            "useCases": [
                "Performance debugging"
            ],
            "realTimeUseCases": [
                "Optimization"
            ]
        },
        {
            "id": 61,
            "name": "How do you establish and manage SQL (Oracle/PostgreSQL/MySQL) DB connections from Express?",
            "question": "How do you establish and manage SQL (Oracle/PostgreSQL/MySQL) DB connections from Express?",
            "answer": "Create connection pool: const pool = mysql.createPool({connectionLimit, host, user}). On route: pool.getConnection((err, conn) => { conn.query(sql, (err, rows) => { conn.release(); }); }). Reuse connections; avoid recreating.",
            "useCases": [
                "Database connectivity"
            ],
            "realTimeUseCases": [
                "SQL integration"
            ]
        },
        {
            "id": 62,
            "name": "How do you implement connection pooling for SQL databases in Node.js?",
            "question": "How do you implement connection pooling for SQL databases in Node.js?",
            "answer": "Connection pool: mysql.createPool({connectionLimit: 10, host, user, password, database}). Maintains 10 persistent connections. On query, lease from pool; return after use. Reduces connection overhead, enables concurrent queries.",
            "useCases": [
                "Connection management"
            ],
            "realTimeUseCases": [
                "High concurrency"
            ]
        },
        {
            "id": 63,
            "name": "How do you avoid SQL injection attacks in Express.js applications?",
            "question": "How do you avoid SQL injection attacks in Express.js applications?",
            "answer": "Use parameterized queries: pool.query('SELECT * FROM users WHERE id = ?', [userId]). Never concatenate user input. Use ORMs (Sequelize, Prisma) which auto-escape. Validate/sanitize inputs on backend.",
            "useCases": [
                "Security"
            ],
            "realTimeUseCases": [
                "Database queries"
            ]
        },
        {
            "id": 64,
            "name": "How do you write optimized SQL queries for high-volume order/order-item transactions?",
            "question": "How do you write optimized SQL queries for high-volume order/order-item transactions?",
            "answer": "Use indexes on foreign keys, timestamps. Batch inserts: INSERT INTO orders VALUES (...), (...) for bulk. Join order + order_items efficiently. Use EXPLAIN to analyze. Denormalize for reads. Archive old orders.",
            "useCases": [
                "Query optimization"
            ],
            "realTimeUseCases": [
                "Black Friday"
            ]
        },
        {
            "id": 65,
            "name": "How do you handle transactions (commit & rollback) in Node.js SQL clients?",
            "question": "How do you handle transactions (commit & rollback) in Node.js SQL clients?",
            "answer": "conn.beginTransaction(); do work; if success conn.commit(); else conn.rollback(). Ensures atomicity: all or nothing. Use for order + payment: if payment fails, rollback entire order creation. Essential for data consistency.",
            "useCases": [
                "Data integrity"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 66,
            "name": "How do you model relational data (Users, Orders, Payments) in Oracle SQL for eCommerce?",
            "question": "How do you model relational data (Users, Orders, Payments) in Oracle SQL for eCommerce?",
            "answer": "Users table: id, email, password. Orders table: id, userId (FK), total, status. OrderItems table: id, orderId (FK), productId, quantity. Payments table: id, orderId (FK), amount, status. Normalize to reduce redundancy; use FKs for integrity.",
            "useCases": [
                "Schema design"
            ],
            "realTimeUseCases": [
                "eCommerce DB"
            ]
        },
        {
            "id": 67,
            "name": "How do you implement stored procedures for performance optimization?",
            "question": "How do you implement stored procedures for performance optimization?",
            "answer": "Stored procedure: CREATE PROCEDURE getOrderDetails(orderId IN NUMBER) AS SELECT * FROM orders WHERE id = orderId. Call from Express: conn.execute('BEGIN getOrderDetails(:1); END;', [id]). Reduces network round-trips.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Complex logic"
            ]
        },
        {
            "id": 68,
            "name": "When do you choose MongoDB over SQL in an eCommerce architecture?",
            "question": "When do you choose MongoDB over SQL in an eCommerce architecture?",
            "answer": "MongoDB: flexible schema (variants, attributes), rapid prototyping, unstructured data (reviews, ratings). SQL: relational data (users, orders, payments), transactions, ACID. Hybrid: MongoDB for catalog, SQL for orders/payments.",
            "useCases": [
                "Database selection"
            ],
            "realTimeUseCases": [
                "eCommerce design"
            ]
        },
        {
            "id": 69,
            "name": "How do you manage connections and pool settings for MongoDB in Express?",
            "question": "How do you manage connections and pool settings for MongoDB in Express?",
            "answer": "mongoose.connect(uri, {maxPoolSize: 10, minPoolSize: 5}). Connection pool auto-managed. Reuse connection; don't create per request. Monitor pool stats. Set serverSelectionTimeoutMS for failover.",
            "useCases": [
                "MongoDB connections"
            ],
            "realTimeUseCases": [
                "Production"
            ]
        },
        {
            "id": 70,
            "name": "How do you design flexible product or catalog schema using MongoDB?",
            "question": "How do you design flexible product or catalog schema using MongoDB?",
            "answer": "Product doc: {id, name, category, price, specs: {color, size} (array)}. Variants as sub-documents. Flexible: add fields without migration. Indexing: category, price for queries. Trade-off: flexibility vs query complexity.",
            "useCases": [
                "Schema design"
            ],
            "realTimeUseCases": [
                "Product catalog"
            ]
        },
        {
            "id": 71,
            "name": "How do you handle complex aggregations using MongoDB aggregation pipelines?",
            "question": "How do you handle complex aggregations using MongoDB aggregation pipelines?",
            "answer": "$match â†’ filter, $group â†’ aggregate (sum, count), $sort â†’ order, $limit â†’ paginate. Example: db.orders.aggregate([{$match: {status: 'completed'}}, {$group: {_id: '$userId', total: {$sum: '$amount'}}}]).",
            "useCases": [
                "Analytics"
            ],
            "realTimeUseCases": [
                "Reports"
            ]
        },
        {
            "id": 72,
            "name": "How do you index MongoDB collections for high read/write performance?",
            "question": "How do you index MongoDB collections for high read/write performance?",
            "answer": "Create indexes: db.products.createIndex({name: 1}), compound: {category: 1, price: 1}. Monitor slow queries. Remove unused indexes. Indexing speeds reads but slows writes. Balance for use case.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Query optimization"
            ]
        },
        {
            "id": 73,
            "name": "How do you prevent performance degradation due to unbounded document growth?",
            "question": "How do you prevent performance degradation due to unbounded document growth?",
            "answer": "Use arrays with limits: reviews: [{...}].slice(-100) keep last 100. Archive old data to separate collection. Denormalize summary fields. Monitor document size. Cap collections limit growth.",
            "useCases": [
                "Document management"
            ],
            "realTimeUseCases": [
                "Growing data"
            ]
        },
        {
            "id": 74,
            "name": "How do you model cart, wishlist, or product variants using MongoDB?",
            "question": "How do you model cart, wishlist, or product variants using MongoDB?",
            "answer": "Cart: {userId, items: [{productId, variant: {color, size}, qty}]}. Wishlist: {userId, products: [productId]}. Variants: stored in product doc or separate collection. Denormalize for performance; invalidate cache on changes.",
            "useCases": [
                "Data modeling"
            ],
            "realTimeUseCases": [
                "eCommerce"
            ]
        },
        {
            "id": 75,
            "name": "How do you split an eCommerce monolith into Express microservices?",
            "question": "How do you split an eCommerce monolith into Express microservices?",
            "answer": "Extract by domain: User Service, Product Service, Order Service, Payment Service. Each service: independent codebase, DB, Express app. API Gateway routes /users to User Service, /products to Product Service. Communicate via HTTP/events.",
            "useCases": [
                "Architecture evolution"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 76,
            "name": "How do microservices authenticate requests using JWT tokens?",
            "question": "How do microservices authenticate requests using JWT tokens?",
            "answer": "Auth Service issues JWT. API Gateway verifies and injects user into req. Other services verify using shared secret. JWT includes userId, role. Services trust JWT; don't re-validate. Symmetric (secret) or asymmetric (public key) signing.",
            "useCases": [
                "Microservice auth"
            ],
            "realTimeUseCases": [
                "Service communication"
            ]
        },
        {
            "id": 77,
            "name": "How do you design API Gateway + BFF architecture for React clients?",
            "question": "How do you design API Gateway + BFF architecture for React clients?",
            "answer": "API Gateway: single entry point, routes to microservices, handles auth, rate limiting, logging. BFF (Backend-for-Frontend): aggregates data from multiple services for React. Reduces client-side logic, improves performance.",
            "useCases": [
                "Architecture pattern"
            ],
            "realTimeUseCases": [
                "Client-server"
            ]
        },
        {
            "id": 78,
            "name": "How do you handle inter-service communication in Express microservices?",
            "question": "How do you handle inter-service communication in Express microservices?",
            "answer": "Synchronous: HTTP REST or gRPC. Service A calls Service B. Order Service calls Payment Service. Asynchronous: message queues (Kafka, RabbitMQ). Service publishes event; other services consume. Async preferred for loose coupling.",
            "useCases": [
                "Service communication"
            ],
            "realTimeUseCases": [
                "Order flow"
            ]
        },
        {
            "id": 79,
            "name": "How do you prevent duplicated logic across services (DRY pattern)?",
            "question": "How do you prevent duplicated logic across services (DRY pattern)?",
            "answer": "Shared library: npm package with utils, validators, constants. Auth logic in shared lib. Services import and use. Reduces duplication. Version carefully; semver versioning. Alternatively, shared service (Auth Service) for cross-cutting concerns.",
            "useCases": [
                "Code reuse"
            ],
            "realTimeUseCases": [
                "Consistency"
            ]
        },
        {
            "id": 80,
            "name": "How do you handle distributed logging and tracing in microservices?",
            "question": "How do you handle distributed logging and tracing in microservices?",
            "answer": "Log aggregation: ELK (Elasticsearch, Logstash, Kibana) or Splunk. Distributed tracing: Jaeger, Zipkin. Inject trace ID into all logs. Correlate logs across services via trace ID. Monitor latency end-to-end.",
            "useCases": [
                "Observability"
            ],
            "realTimeUseCases": [
                "Debugging"
            ]
        },
        {
            "id": 81,
            "name": "How do you ensure eventual consistency across microservices?",
            "question": "How do you ensure eventual consistency across microservices?",
            "answer": "Event-driven: order created â†’ publish event. Inventory Service consumes, updates stock eventually. If Inventory Service fails, event replayed later. Saga pattern: chain service calls; compensate on failure (refund if inventory insufficient).",
            "useCases": [
                "Consistency"
            ],
            "realTimeUseCases": [
                "Distributed transactions"
            ]
        },
        {
            "id": 82,
            "name": "How do you version independent microservices without breaking clients?",
            "question": "How do you version independent microservices without breaking clients?",
            "answer": "API versioning: /v1/products, /v2/products. Support multiple versions simultaneously. Clients migrate gradually. Deprecate old versions after notice period. Backward-compatible changes don't need versioning.",
            "useCases": [
                "API evolution"
            ],
            "realTimeUseCases": [
                "Updates"
            ]
        },
        {
            "id": 83,
            "name": "How do you handle failures gracefully using circuit breakers or retries?",
            "question": "How do you handle failures gracefully using circuit breakers or retries?",
            "answer": "Circuit Breaker: after N failures, open circuit; fail fast, prevent cascades. Retry: exponential backoff, max retries. Libraries: node-resilience, axios-retry. Fallback: return cached data or default response if service down.",
            "useCases": [
                "Resilience"
            ],
            "realTimeUseCases": [
                "High availability"
            ]
        },
        {
            "id": 84,
            "name": "How do you integrate Express.js microservices with Kafka?",
            "question": "How do you integrate Express.js microservices with Kafka?",
            "answer": "npm install kafkajs. Producer: send order event to topic 'orders'. Consumer: listen to topic, process in background. Express app: produce to Kafka from routes, consume in worker. Enables async, decoupled communication.",
            "useCases": [
                "Event streaming"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 85,
            "name": "How do you design event-driven flows for Orders, Payments, and Inventory?",
            "question": "How do you design event-driven flows for Orders, Payments, and Inventory?",
            "answer": "Order Service emits 'order.created'. Payment Service consumes, processes. On success, emits 'payment.completed'. Inventory Service consumes, decrements stock. Each service independent; loosely coupled. Enables scaling per domain.",
            "useCases": [
                "Event architecture"
            ],
            "realTimeUseCases": [
                "eCommerce"
            ]
        },
        {
            "id": 86,
            "name": "What topics and partitions do you use for high-volume eCommerce events?",
            "question": "What topics and partitions do you use for high-volume eCommerce events?",
            "answer": "Topics: orders, payments, inventory, notifications. Partitions: scale by order ID (partition order to same partition) for ordering, or scale by volume. Typically 3-10 partitions. Monitor lag.",
            "useCases": [
                "Kafka design"
            ],
            "realTimeUseCases": [
                "High throughput"
            ]
        },
        {
            "id": 87,
            "name": "How do you guarantee message delivery (at-least-once, exactly-once)?",
            "question": "How do you guarantee message delivery (at-least-once, exactly-once)?",
            "answer": "At-least-once: enable retries, acks='all'. May duplicate; handle idempotency (idempotency key). Exactly-once: complex, requires transactions + idempotency. Most systems use at-least-once + idempotent handlers.",
            "useCases": [
                "Reliability"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 88,
            "name": "How do you handle consumer lag and scaling Kafka consumers?",
            "question": "How do you handle consumer lag and scaling Kafka consumers?",
            "answer": "Monitor consumer lag: Kafka metrics. Increase consumers (up to partition count) to parallelize. Reduce processing time. Auto-scaling: scale up if lag > threshold. Consumer groups balance partitions.",
            "useCases": [
                "Kafka scaling"
            ],
            "realTimeUseCases": [
                "Performance"
            ]
        },
        {
            "id": 89,
            "name": "How do you implement event sourcing for order lifecycle management?",
            "question": "How do you implement event sourcing for order lifecycle management?",
            "answer": "Store all order events (created, paid, shipped, delivered) in event log. Rebuild state by replaying. Benefits: audit trail, temporal queries, recovery. Libraries: eventstore, EventStoreDB. Complex but powerful for order systems.",
            "useCases": [
                "Audit",
                "Time travel"
            ],
            "realTimeUseCases": [
                "Order history"
            ]
        },
        {
            "id": 90,
            "name": "How do you handle distributed transactions across Kafka and SQL?",
            "question": "How do you handle distributed transactions across Kafka and SQL?",
            "answer": "Saga pattern: order transaction spans multiple services. Choreography: services react to events (loose coupling). Orchestration: central coordinator. For Payment + Inventory: if inventory update fails, publish 'payment.refund' event. Compensate failures.",
            "useCases": [
                "Distributed transactions"
            ],
            "realTimeUseCases": [
                "Order flow"
            ]
        },
        {
            "id": 91,
            "name": "How is authentication handled between Customer Portal and Admin Portal?",
            "question": "How is authentication handled between Customer Portal and Admin Portal?",
            "answer": "Single Auth Service issues JWT with role (customer/admin). Both portals send JWT in Authorization header. Backend verifies role for protected routes. Customers see /portal/products; admins see /admin/products.",
            "useCases": [
                "Portal separation"
            ],
            "realTimeUseCases": [
                "NMG eCommerce"
            ]
        },
        {
            "id": 92,
            "name": "How do you manage product catalog caching for faster load times?",
            "question": "How do you manage product catalog caching for faster load times?",
            "answer": "Cache products in Redis (category, search terms). TTL: 1 hour for volatile, 24h for stable. On product update: invalidate related cache entries. Serve static catalog from CDN. Reduces DB calls 90%+.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Product pages"
            ]
        },
        {
            "id": 93,
            "name": "How do you synchronize inventory updates across SQL + MongoDB + Kafka?",
            "question": "How do you synchronize inventory updates across SQL + MongoDB + Kafka?",
            "answer": "Inventory Service source-of-truth in SQL. On update: emit 'inventory.updated' event to Kafka. Product Service (MongoDB) consumes, updates cache. Both services eventually consistent. Kafka ensures delivery.",
            "useCases": [
                "Data sync"
            ],
            "realTimeUseCases": [
                "Multi-DB"
            ]
        },
        {
            "id": 94,
            "name": "How do you manage multi-device login and JWT refresh for customers?",
            "question": "How do you manage multi-device login and JWT refresh for customers?",
            "answer": "Issue access token (1h) + refresh token (7d) on login. Store refresh token in db with device ID. Client stores tokens securely (httpOnly cookie). On expiry: client sends refresh token; server validates device, issues new access token.",
            "useCases": [
                "Session management"
            ],
            "realTimeUseCases": [
                "Mobile + web"
            ]
        },
        {
            "id": 95,
            "name": "How do you optimize checkout APIs during a flash sale?",
            "question": "How do you optimize checkout APIs during a flash sale?",
            "answer": "Cache product prices, apply coupon rules in-memory. Use connection pooling for DB. Implement rate limiting to prevent abuse. Queue checkout requests (Bull). Scale horizontally with load balancer. Async inventory decrement.",
            "useCases": [
                "Optimization"
            ],
            "realTimeUseCases": [
                "Flash sales"
            ]
        },
        {
            "id": 96,
            "name": "How do you secure high-traffic endpoints like Add-to-Cart and Checkout?",
            "question": "How do you secure high-traffic endpoints like Add-to-Cart and Checkout?",
            "answer": "Auth middleware: verify JWT. Rate limiting: 10 reqs/min per user. Input validation: product ID, quantity. HTTPS only. Helmet headers. Monitor for fraudulent activity (velocity checks).",
            "useCases": [
                "Security"
            ],
            "realTimeUseCases": [
                "Cart/checkout"
            ]
        },
        {
            "id": 97,
            "name": "How do you prevent duplicate orders using idempotency keys?",
            "question": "How do you prevent duplicate orders using idempotency keys?",
            "answer": "Client generates UUID; includes in request header. Server checks: if exists, return cached response. If new, process, cache result, return. Prevents double-charging on retry. Store in db with 24h TTL.",
            "useCases": [
                "Idempotency"
            ],
            "realTimeUseCases": [
                "Payment safety"
            ]
        },
        {
            "id": 98,
            "name": "How do you build scalable microservices for product search, offers, and recommendations?",
            "question": "How do you build scalable microservices for product search, offers, and recommendations?",
            "answer": "Search Service: Elasticsearch for fast full-text search, faceted filters. Offers Service: Kafka listens to orders, applies rules in-memory. Recommendations: collaborative filtering or content-based, cached. Each scales independently.",
            "useCases": [
                "Scalable services"
            ],
            "realTimeUseCases": [
                "eCommerce features"
            ]
        },
        {
            "id": 99,
            "name": "How do you maintain data consistency between Orders Service and Payments Service?",
            "question": "How do you maintain data consistency between Orders Service and Payments Service?",
            "answer": "Order Service creates order (status: pending). Calls Payment Service (async via Kafka). Payment succeeds â†’ emits 'payment.completed'. Order Service consumes, updates status. If payment fails, order cancels. Event-driven ensures consistency.",
            "useCases": [
                "Consistency"
            ],
            "realTimeUseCases": [
                "Order-payment"
            ]
        },
        {
            "id": 100,
            "name": "How do you handle asynchronous order confirmation using Kafka events?",
            "question": "How do you handle asynchronous order confirmation using Kafka events?",
            "answer": "Order Service creates order, emits 'order.created' to Kafka. Notification Service consumes, sends confirmation email. Payment Service processes. Inventory Service decrements stock. Each service acts independently; eventual consistency.",
            "useCases": [
                "Async processing"
            ],
            "realTimeUseCases": [
                "Order lifecycle"
            ]
        }
    ],
    "RESTful API": [
        {
            "id": 1,
            "name": "REST vs SOAP",
            "question": "What is the difference between REST and SOAP?",
            "answer": "REST is an architectural style that uses HTTP verbs and typically JSON over HTTP for lightweight, stateless communication. SOAP is a protocol that uses XML envelopes and has stricter standards (WSDL, WS-*). REST is simpler, cacheable, and preferred for web APIs; SOAP offers built-in WS-security, transactions, and strict contracts, suiting enterprise integrations.",
            "useCases": [
                "Web APIs",
                "Lightweight integrations"
            ],
            "realTimeUseCases": [
                "Public JSON APIs",
                "Enterprise payment integrations with SOAP"
            ]
        },
        {
            "id": 2,
            "name": "REST Principles",
            "question": "Explain the key principles or constraints of a RESTful architecture.",
            "answer": "Key constraints: 1) Client-Server separation, 2) Stateless interactions (no server-side session), 3) Cacheable responses, 4) Uniform interface (resources identified by URIs, use of HTTP methods), 5) Layered system (intermediate proxies, gateways), 6) Code on demand (optional). Following these improves scalability, evolvability, and simplicity.",
            "useCases": [
                "Scalable APIs",
                "Separation of concerns"
            ],
            "realTimeUseCases": [
                "Public REST endpoints",
                "Microservice HTTP APIs"
            ]
        },
        {
            "id": 3,
            "name": "API Endpoint",
            "question": "What is an API endpoint?",
            "answer": "An endpoint is a specific URL (URI) exposed by the API that represents a resource or action (for example /api/products or /api/orders/{id}). Endpoints accept HTTP methods (GET, POST, etc.) and return responses. They are the interface clients call to interact with the system.",
            "useCases": [
                "Resource access",
                "Routing design"
            ],
            "realTimeUseCases": [
                "GET /products, POST /orders"
            ]
        },
        {
            "id": 4,
            "name": "CRUD and HTTP",
            "question": "What does CRUD stand for and how does it relate to HTTP methods?",
            "answer": "CRUD = Create, Read, Update, Delete. Common HTTP mappings: Create -> POST, Read -> GET, Update -> PUT or PATCH, Delete -> DELETE. These conventions map resource lifecycle operations to standard HTTP verbs for predictable APIs.",
            "useCases": [
                "Resource lifecycles",
                "API design"
            ],
            "realTimeUseCases": [
                "POST /users, GET /users/1, PATCH /users/1, DELETE /users/1"
            ]
        },
        {
            "id": 5,
            "name": "Resource Definition",
            "question": "What is a resource in the context of REST?",
            "answer": "A resource is a conceptual mapping to an entity or collection (user, order, product). Resources are identified by URIs and represented in a format like JSON. The API exposes operations on resources via HTTP methods rather than RPC-style actions.",
            "useCases": [
                "Modeling APIs",
                "URL design"
            ],
            "realTimeUseCases": [
                "/products maps to product collection, /products/{id} to single product"
            ]
        },
        {
            "id": 6,
            "name": "Resource Representation",
            "question": "How do you represent a resource in a RESTful system?",
            "answer": "Resources are represented as payloads, typically JSON objects (or XML). Representations include attributes and optionally hypermedia links (HATEOAS) to related resources. Include metadata, links, and careful versioning of fields for backward compatibility.",
            "useCases": [
                "Response design",
                "HATEOAS"
            ],
            "realTimeUseCases": [
                "JSON product representation with id, name, price, links"
            ]
        },
        {
            "id": 7,
            "name": "Idempotence",
            "question": "What is idempotence, and which HTTP methods are idempotent?",
            "answer": "An idempotent operation can be applied multiple times without changing the result after the first application. Safe idempotent HTTP methods: GET, PUT, DELETE, HEAD, OPTIONS (GET/DELETE/PUT are idempotent; POST is not idempotent by default). Design APIs so retries of idempotent methods are safe.",
            "useCases": [
                "Retries",
                "Fault tolerance"
            ],
            "realTimeUseCases": [
                "PUT /orders/123 to set order state repeatedly is safe"
            ]
        },
        {
            "id": 8,
            "name": "OPTIONS Method",
            "question": "What is the purpose of the OPTIONS HTTP method?",
            "answer": "OPTIONS lets a client discover communication options for a resource (allowed methods, CORS preflight responses). Browsers issue OPTIONS preflight requests to check allowed methods and headers for cross-origin requests. Servers should respond with appropriate Allow and CORS headers.",
            "useCases": [
                "CORS handling",
                "API discovery"
            ],
            "realTimeUseCases": [
                "Browser preflight before POST with custom headers"
            ]
        },
        {
            "id": 9,
            "name": "Statefulness",
            "question": "Can a REST API be stateful? Explain your reasoning.",
            "answer": "By REST constraints, APIs should be stateless (each request contains all required context) to enable scalability and easier load balancing. Stateful APIs store session on server, which violates statelessness and reduces horizontal scalability. In practice, some systems maintain session for convenience, but to be RESTful one should design stateless interactions (e.g., include authentication token in each request).",
            "useCases": [
                "Scalability considerations",
                "Session design"
            ],
            "realTimeUseCases": [
                "Token-based auth for stateless APIs"
            ]
        },
        {
            "id": 10,
            "name": "POST PUT PATCH Usage",
            "question": "Describe the appropriate use cases for POST, PUT, and PATCH.",
            "answer": "POST: create a new subordinate resource (e.g., POST /orders). Non-idempotent. PUT: full replace of a resource at a known URI; idempotent (PUT /users/1 with full object). PATCH: partial update of a resource; semantic partial changes (PATCH /users/1 {\"email\":...}). Use PUT when client sends full representation; PATCH for partial updates to avoid sending the entire payload.",
            "useCases": [
                "Create vs update patterns",
                "Idempotency"
            ],
            "realTimeUseCases": [
                "POST /products, PUT /products/1, PATCH /products/1/price"
            ]
        },
        {
            "id": 11,
            "name": "401 vs 403",
            "question": "What is the difference between an HTTP status code 401 and 403?",
            "answer": "401 Unauthorized: request lacks valid authentication credentials (user not authenticated or token expired). 403 Forbidden: authenticated but not authorized to access the resource (permission denied). Use 401 to prompt authentication, 403 to indicate access is denied despite authentication.",
            "useCases": [
                "Error semantics",
                "Auth handling"
            ],
            "realTimeUseCases": [
                "401 for missing token, 403 for insufficient role"
            ]
        },
        {
            "id": 12,
            "name": "201 vs 200",
            "question": "When would you use a 201 status code versus a 200 status code?",
            "answer": "201 Created: used when a request successfully creates a resource (usually include Location header with URI of new resource). 200 OK: general success response for retrieval or successful operation that does not create a new resource. Use 201 for POST resource creation, 200 for successful GET or idempotent updates returning content.",
            "useCases": [
                "Response conventions",
                "Creation responses"
            ],
            "realTimeUseCases": [
                "POST /orders -> 201 with Location: /orders/123"
            ]
        },
        {
            "id": 13,
            "name": "3xx Codes",
            "question": "What do the 3xx status codes represent in a REST context?",
            "answer": "3xx codes indicate redirection. Examples: 301 Moved Permanently, 302 Found (temp redirect), 304 Not Modified (used with caching/conditional requests). In REST APIs, 3xx can be used for resource relocation or for clients to use cache validations (304). For APIs, prefer returning updated resource URIs rather than frequently redirecting.",
            "useCases": [
                "Redirection",
                "Caching"
            ],
            "realTimeUseCases": [
                "304 when If-None-Match matches ETag"
            ]
        },
        {
            "id": 14,
            "name": "400 vs 422",
            "question": "What is the difference between a 400 Bad Request and a 422 Unprocessable Entity?",
            "answer": "400 Bad Request: the request is malformed (invalid JSON, missing required syntax). 422 Unprocessable Entity: request well-formed syntactically but semantically invalid (validation errors, business rule violations). Use 422 to return field-level validation errors, 400 for parse/format errors.",
            "useCases": [
                "Validation vs parsing errors"
            ],
            "realTimeUseCases": [
                "400 for malformed JSON, 422 for invalid field values"
            ]
        },
        {
            "id": 15,
            "name": "410 Gone",
            "question": "Which HTTP status code should be used if a resource is permanently removed?",
            "answer": "Use 410 Gone to indicate a resource has been permanently removed and is no longer available. 404 Not Found indicates resource not present but may reappear. 410 explicitly signals permanent removal and can help clients stop requesting or cache the removal.",
            "useCases": [
                "Resource lifecycle",
                "Deprecation"
            ],
            "realTimeUseCases": [
                "Deprecated API endpoints permanently removed -> 410"
            ]
        },
        {
            "id": 16,
            "name": "API Versioning Importance",
            "question": "What is API versioning and why is it important?",
            "answer": "API versioning allows evolving APIs without breaking existing clients. It provides compatibility guarantees, enables gradual migrations, and helps deprecate old behavior safely. Without versioning, changes to field names or semantics can break consumers.",
            "useCases": [
                "Backward compatibility",
                "Evolution"
            ],
            "realTimeUseCases": [
                "/v1/users vs /v2/users during migration"
            ]
        },
        {
            "id": 17,
            "name": "Versioning Strategies",
            "question": "What are different strategies for versioning a REST API and which is preferred?",
            "answer": "Common strategies: 1) URL path (/v1/resource) â€“ explicit and cache-friendly. 2) Query parameter (?version=1) â€“ less visible. 3) Custom header (Accept: application/vnd.myapp.v1+json) â€“ cleaner URIs but harder for browsers and caching. Preferred: URL path for public APIs (simplicity), headers for content negotiation in advanced cases. Choose consistently and document it.",
            "useCases": [
                "Version migration",
                "Client compatibility"
            ],
            "realTimeUseCases": [
                "/api/v1/products remains while /api/v2/products added"
            ]
        },
        {
            "id": 18,
            "name": "Path vs Query",
            "question": "Should you use query parameters or path variables for uniquely identifying a resource?",
            "answer": "Use path variables for resource identity (e.g., /orders/{id}). Use query parameters for filtering, searching, or optional modifiers (e.g., /products?category=shirts&page=2). Keep canonical resource URIs in the path and use query params for non-identifying parameters.",
            "useCases": [
                "URI design",
                "Resource identification"
            ],
            "realTimeUseCases": [
                "/users/123 vs /users?email=joe@example.com"
            ]
        },
        {
            "id": 19,
            "name": "Nested Resources",
            "question": "How do you handle nested resources (e.g., retrieving all comments for a specific post)?",
            "answer": "Use nested paths to express relationships: GET /posts/{postId}/comments to fetch comments for a post. For large collections, support pagination and possibly a top-level resource /comments?postId={postId} to enable cross-collection queries. Keep nesting shallow to avoid overly deep URIs.",
            "useCases": [
                "Relationship modeling",
                "API ergonomics"
            ],
            "realTimeUseCases": [
                "GET /posts/42/comments?page=2"
            ]
        },
        {
            "id": 20,
            "name": "Filtering Sorting Pagination",
            "question": "How do you handle filtering, sorting, and pagination in a REST API?",
            "answer": "Expose query parameters: filtering (e.g., ?status=active), sorting (e.g., ?sort=-createdAt or sort=price,asc), and pagination (limit/offset or cursor-based: ?page=2&per_page=20 or ?cursor=abc). Prefer cursor pagination for high-scale APIs to avoid offset slowness; use consistent defaults and include metadata (total, next cursor) in responses.",
            "useCases": [
                "Large collections",
                "Performance"
            ],
            "realTimeUseCases": [
                "/products?category=shoes&sort=price&limit=20"
            ]
        },
        {
            "id": 21,
            "name": "Data Formats JSON vs XML",
            "question": "What are some common data formats used in REST APIs? What are the pros and cons of JSON and XML?",
            "answer": "JSON: lightweight, native to JavaScript, compact, easily parsed, preferred for web APIs. XML: verbose, supports schemas (XSD), namespaces, and more robust validation and transformation (XSLT). Use JSON for typical REST APIs; use XML when strict schema, legacy systems, or SOAP integration is required.",
            "useCases": [
                "Format selection",
                "Interoperability"
            ],
            "realTimeUseCases": [
                "Public JSON APIs, enterprise XML integrations"
            ]
        },
        {
            "id": 22,
            "name": "API Security",
            "question": "How would you secure a RESTful API?",
            "answer": "Use HTTPS/TLS, authenticate requests (OAuth2/JWT/API keys), authorize at resource level (RBAC), validate and sanitize inputs, enforce rate limiting, use CORS correctly, log and monitor, store secrets in a secrets manager, and rotate credentials. Use defense-in-depth: API Gateway, WAF, and service-level checks.",
            "useCases": [
                "API hardening",
                "Compliance"
            ],
            "realTimeUseCases": [
                "HTTPS + JWT auth + rate limiting in production"
            ]
        },
        {
            "id": 23,
            "name": "Auth vs AuthZ",
            "question": "Explain the difference between authentication and authorization.",
            "answer": "Authentication verifies identity (who you are). Authorization determines actions the authenticated identity can perform (what you can do). Both are required: first authenticate the client/user, then check permissions for the requested resource/action.",
            "useCases": [
                "Security concepts",
                "Access control"
            ],
            "realTimeUseCases": [
                "Login -> authentication, then role check for admin endpoints"
            ]
        },
        {
            "id": 24,
            "name": "Auth Mechanisms",
            "question": "What are some common authentication mechanisms used in REST APIs (e.g., Basic Auth, API Keys, OAuth 2.0, JWT)?",
            "answer": "Common mechanisms: Basic Auth (username/password over TLS) for simple use; API Keys for service-to-service or low security needs; OAuth2 for delegated authorization flows (authorization code, client credentials); JWT for stateless token-based auth. Choose based on use case: OAuth2 for third-party access, JWT for stateless microservices.",
            "useCases": [
                "Auth selection",
                "Delegation"
            ],
            "realTimeUseCases": [
                "OAuth2 for social login, JWT for internal APIs"
            ]
        },
        {
            "id": 25,
            "name": "CORS",
            "question": "What is Cross-Origin Resource Sharing (CORS) and how does it work?",
            "answer": "CORS is a browser mechanism that controls cross-origin requests. Server responds with Access-Control-Allow-Origin, Access-Control-Allow-Methods, and Access-Control-Allow-Headers. Browsers issue preflight OPTIONS requests for certain cross-origin requests. Properly configure CORS to allow trusted origins and credentials when needed.",
            "useCases": [
                "Browser APIs",
                "Cross-origin calls"
            ],
            "realTimeUseCases": [
                "Frontend calling API on different domain requires CORS headers"
            ]
        },
        {
            "id": 26,
            "name": "Caching Strategies",
            "question": "How can you implement caching in a REST API?",
            "answer": "Use HTTP caching headers (Cache-Control, Expires) for client/CDN caching; use ETag/Last-Modified for conditional requests; server-side caches (Redis, CDN) for frequently requested data. Choose cache-control directives carefully for data freshness. Invalidate caches on data change or use short TTLs for volatile data.",
            "useCases": [
                "Performance",
                "Scalability"
            ],
            "realTimeUseCases": [
                "Cache product catalog in CDN with short TTLs for updates"
            ]
        },
        {
            "id": 27,
            "name": "ETag and If-None-Match",
            "question": "What are ETag and If-None-Match headers used for?",
            "answer": "ETag is a response header representing a resource version (hash). Clients send If-None-Match with ETag to ask server to return 304 Not Modified if resource unchanged. This saves bandwidth and improves perceived performance by allowing clients to reuse cached representations.",
            "useCases": [
                "Conditional requests",
                "Bandwidth optimization"
            ],
            "realTimeUseCases": [
                "Return 304 when cached product unchanged"
            ]
        },
        {
            "id": 28,
            "name": "Rate Limiting",
            "question": "What is rate limiting and why is it necessary?",
            "answer": "Rate limiting restricts number of requests a client can make in a time window to protect APIs from abuse, DoS, and to ensure fair usage. Implement via token bucket, leaky bucket, or fixed window algorithms using Redis for distributed limits. Provide useful headers (X-RateLimit-Limit, X-RateLimit-Remaining) to clients.",
            "useCases": [
                "Abuse protection",
                "Stability"
            ],
            "realTimeUseCases": [
                "Limit 100 req/min per API key"
            ]
        },
        {
            "id": 29,
            "name": "Error Response Structure",
            "question": "How would you structure a consistent error response for your API?",
            "answer": "Return JSON with consistent fields: {\"error\": {\"code\": \"INVALID_INPUT\", \"message\": \"Validation failed\", \"details\": [{\"field\":\"email\",\"message\":\"invalid\"}] , \"timestamp\":\"...\"}}. Use machine-readable error codes and include human-friendly messages and optional field-level details for clients to program against.",
            "useCases": [
                "Client integration",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Return structured validation errors for forms"
            ]
        },
        {
            "id": 30,
            "name": "5xx Status Codes",
            "question": "Which HTTP status codes are used for server-side errors?",
            "answer": "5xx codes indicate server errors. Common ones: 500 Internal Server Error (generic), 502 Bad Gateway (upstream failure), 503 Service Unavailable (maintenance or overload), 504 Gateway Timeout (upstream timeout). Use appropriate code to signal the nature of the server problem.",
            "useCases": [
                "Error signaling",
                "Monitoring"
            ],
            "realTimeUseCases": [
                "Return 503 during maintenance windows"
            ]
        },
        {
            "id": 31,
            "name": "API Testing Tools",
            "question": "What tools do you use to test REST APIs?",
            "answer": "Tools: Postman for interactive testing, Newman for CI runs, curl for quick checks, automated tests via supertest (Node), pytest + requests, Pact for contract testing, and load testing tools (k6, JMeter). Use integration tests, contract tests, and end-to-end tests in CI.",
            "useCases": [
                "Testing",
                "CI"
            ],
            "realTimeUseCases": [
                "Postman collections for QA, Newman in CI pipeline"
            ]
        },
        {
            "id": 32,
            "name": "API Contract",
            "question": "What constitutes a good API contract or documentation?",
            "answer": "A good contract includes: clear endpoint list, request/response schemas (JSON Schema or OpenAPI), status codes, error formats, authentication/authorization details, examples, rate limits, versioning policy, and change/deprecation notices. Provide OpenAPI/Swagger spec for machine-readable docs and client generation.",
            "useCases": [
                "Client integration",
                "Automation"
            ],
            "realTimeUseCases": [
                "OpenAPI spec for SDK generation and QA"
            ]
        },
        {
            "id": 33,
            "name": "Backward Compatibility",
            "question": "How do you ensure backward compatibility when modifying an existing API?",
            "answer": "Strategies: additive changes only (add new fields but keep old ones), deprecate fields with warnings, version the API for breaking changes, use feature flags, provide grace periods and migration guides, support both old and new contracts concurrently, and run contract tests against consumers.",
            "useCases": [
                "Safe evolution",
                "Client stability"
            ],
            "realTimeUseCases": [
                "Maintain /v1 while rolling out /v2 and slowly migrate clients"
            ]
        }
    ],
    "Microservices": [
        {
            "id": 1,
            "name": "What is Microservices Architecture?",
            "question": "What is Microservices Architecture?",
            "answer": "Microservices is an architectural pattern where applications are built as loosely coupled, independently deployable services. Each service: handles specific business capability, runs in own process, communicates via APIs/messaging. Benefits: scalability, flexibility, fault isolation. Example: eCommerce = User Service, Product Service, Order Service.",
            "useCases": [
                "Large applications",
                "Scaling specific features"
            ],
            "realTimeUseCases": [
                "Netflix",
                "Amazon"
            ]
        },
        {
            "id": 2,
            "name": "What are the key characteristics of microservices?",
            "question": "What are the key characteristics of microservices?",
            "answer": "1) Single Responsibility: each service owns one business domain. 2) Independent Deployment: deploy without affecting others. 3) Loose Coupling: minimal dependencies. 4) Communication: REST/gRPC/Kafka. 5) Scalability: scale individual services. 6) Technology Diversity: use different stacks per service. 7) Resilience: failure isolation. 8) Observability: distributed tracing/logging.",
            "useCases": [
                "Architecture principles"
            ],
            "realTimeUseCases": [
                "Design decisions"
            ]
        },
        {
            "id": 3,
            "name": "What problems does microservices architecture solve?",
            "question": "What problems does microservices architecture solve?",
            "answer": "1) Scalability: scale only services under load (Products vs Payments). 2) Flexibility: different teams own services, deploy independently. 3) Technology Freedom: use Node.js for User Service, Go for Order Service. 4) Resilience: one service failure doesn't crash entire app. 5) Development Speed: teams work parallel. 6) Continuous Deployment: release without system-wide testing.",
            "useCases": [
                "Problem solving"
            ],
            "realTimeUseCases": [
                "System design"
            ]
        },
        {
            "id": 4,
            "name": "What are the disadvantages of microservices?",
            "question": "What are the disadvantages of microservices?",
            "answer": "1) Complexity: network latency, distributed transactions. 2) Operational Overhead: need monitoring, logging, tracing per service. 3) Data Consistency: eventual consistency challenges. 4) Testing: harder to test across services (integration tests). 5) Debugging: request spans multiple services, hard to trace. 6) Network Failures: partial failures, cascading issues. 7) Initial Investment: infrastructure overhead (Kubernetes, Kafka).",
            "useCases": [
                "Risk assessment"
            ],
            "realTimeUseCases": [
                "Architecture tradeoffs"
            ]
        },
        {
            "id": 5,
            "name": "Monolithic vs Microservices: key differences?",
            "question": "Monolithic vs Microservices: key differences?",
            "answer": "Monolithic: single codebase, single database, shared memory. Deployment: all or nothing. Scaling: scale entire app. Monolith wins: simplicity, consistency, easier testing. Microservices: multiple codebases, multiple databases, network calls. Deployment: independent. Scaling: per-service. Microservices wins: scalability, flexibility. Choice: start monolith, migrate to microservices as scale grows.",
            "useCases": [
                "Architecture comparison"
            ],
            "realTimeUseCases": [
                "Initial design"
            ]
        },
        {
            "id": 6,
            "name": "What are the building blocks of microservices architecture?",
            "question": "What are the building blocks of microservices architecture?",
            "answer": "1) Services: independent components (User, Order, Payment). 2) API Gateway: single entry point, routes requests. 3) Service Discovery: finds service locations. 4) Load Balancer: distributes traffic. 5) Message Broker: async communication (Kafka, RabbitMQ). 6) Configuration Server: centralized config. 7) Monitoring/Logging: ELK stack, Prometheus. 8) Container Orchestration: Kubernetes.",
            "useCases": [
                "Architecture components"
            ],
            "realTimeUseCases": [
                "System design"
            ]
        },
        {
            "id": 7,
            "name": "What is the request flow in microservices architecture?",
            "question": "What is the request flow in microservices architecture?",
            "answer": "1) Client sends request to API Gateway. 2) Gateway authenticates (JWT verification). 3) Gateway routes to target microservice. 4) Service receives request, business logic execution. 5) Service calls dependent services (Order Service â†’ Inventory Service). 6) Service returns response to Gateway. 7) Gateway returns to client. 8) Logging/tracing at each step via correlation ID.",
            "useCases": [
                "Request handling"
            ],
            "realTimeUseCases": [
                "API flow"
            ]
        },
        {
            "id": 8,
            "name": "What communication methods are used between microservices?",
            "question": "What communication methods are used between microservices?",
            "answer": "1) Synchronous: REST HTTP calls, gRPC. Order Service calls Payment Service, waits for response. 2) Asynchronous: Message queues (Kafka, RabbitMQ). Order Service publishes 'order.created' event; other services consume. 3) Hybrid: use sync for critical paths, async for notifications. Sync faster but tight coupling; async looser coupling but eventual consistency.",
            "useCases": [
                "Inter-service communication"
            ],
            "realTimeUseCases": [
                "Integration patterns"
            ]
        },
        {
            "id": 9,
            "name": "Synchronous vs Asynchronous communication in microservices?",
            "question": "Synchronous vs Asynchronous communication in microservices?",
            "answer": "Synchronous: caller waits for response. REST API call: immediate feedback. Pros: simple, immediate consistency. Cons: tight coupling, cascading failures. Asynchronous: caller doesn't wait. Message queue: caller publishes, continues. Pros: loose coupling, resilience. Cons: eventual consistency, harder to debug. Best: use sync for critical flows (payment), async for notifications (email, analytics).",
            "useCases": [
                "Communication pattern"
            ],
            "realTimeUseCases": [
                "Design choice"
            ]
        },
        {
            "id": 10,
            "name": "What is an API Gateway and why is it essential?",
            "question": "What is an API Gateway and why is it essential?",
            "answer": "API Gateway: single entry point for all client requests. Functions: 1) Routing: direct to appropriate service. 2) Authentication: verify JWT, prevent unauthorized access. 3) Rate Limiting: prevent abuse. 4) Logging: centralized request logs. 5) Response Aggregation: combine multiple service responses. 6) Load Balancing: distribute traffic. Examples: Kong, AWS API Gateway, Netflix Zuul.",
            "useCases": [
                "Client-service bridge"
            ],
            "realTimeUseCases": [
                "REST APIs"
            ]
        },
        {
            "id": 11,
            "name": "How does API Gateway work internally?",
            "question": "How does API Gateway work internally?",
            "answer": "1) Client sends request to Gateway (URL, headers, body). 2) Gateway checks routing rules: /products â†’ Product Service, /orders â†’ Order Service. 3) Middleware chain: auth â†’ rate limit â†’ logging. 4) Forward request to target service. 5) Service processes, returns response. 6) Gateway may transform response (formatting, data aggregation). 7) Return to client. Decouples clients from backend services; can change service endpoints without client impact.",
            "useCases": [
                "Gateway mechanism"
            ],
            "realTimeUseCases": [
                "Request routing"
            ]
        },
        {
            "id": 12,
            "name": "What problems does API Gateway solve?",
            "question": "What problems does API Gateway solve?",
            "answer": "1) Centralized Authentication: single place to verify JWT (not in each service). 2) Cross-cutting Concerns: logging, rate limiting in one place. 3) Service Discovery Abstraction: clients don't need to know service IPs. 4) Load Balancing: distribute traffic evenly. 5) Response Transformation: aggregate data from multiple services. 6) Security: SSL termination, DDoS protection. 7) Versioning: route /v1/ and /v2/ to different services.",
            "useCases": [
                "Problem solving"
            ],
            "realTimeUseCases": [
                "Architecture benefits"
            ]
        },
        {
            "id": 13,
            "name": "What are Gateway Filters in microservices?",
            "question": "What are Gateway Filters in microservices?",
            "answer": "Filters: interceptors in request/response pipeline. Pre-filters (before forwarding): JWT validation, rate limiting, logging. Post-filters (after response): transform response, add headers. Examples: Spring Cloud Gateway, Kong. Usage: order by priority. Example: auth-filter (pre) â†’ rate-limit-filter (pre) â†’ forward â†’ log-filter (post).",
            "useCases": [
                "Gateway customization"
            ],
            "realTimeUseCases": [
                "Request/response handling"
            ]
        },
        {
            "id": 14,
            "name": "How do you integrate Service Discovery with API Gateway?",
            "question": "How do you integrate Service Discovery with API Gateway?",
            "answer": "Service Registry: stores service locations (hostname, port). Service Discovery: queries registry to find service IP. Integration: Gateway queries registry to get service endpoint. On service startup: register in registry (Consul, Eureka). On shutdown: deregister. Gateway caches endpoints for performance. Monitors health; removes unhealthy instances.",
            "useCases": [
                "Dynamic routing"
            ],
            "realTimeUseCases": [
                "Service discovery"
            ]
        },
        {
            "id": 15,
            "name": "What is the request flow through API Gateway in detail?",
            "question": "What is the request flow through API Gateway in detail?",
            "answer": "1) Client â†’ Gateway: GET /api/orders/123 + JWT. 2) Gateway Pre-filters: auth-filter validates JWT, adds user to context. 3) Gateway Pre-filters: rate-limit checks quota. 4) Gateway Routes: /orders â†’ Order Service. 5) Order Service: processes request. 6) Order Service â†’ Response: order JSON. 7) Gateway Post-filters: add headers, logging. 8) Gateway â†’ Client: response. Complete flow includes error handling, retries, circuit breaking.",
            "useCases": [
                "Flow understanding"
            ],
            "realTimeUseCases": [
                "Debugging"
            ]
        },
        {
            "id": 16,
            "name": "How do you design error handling and retry logic in API Gateway?",
            "question": "How do you design error handling and retry logic in API Gateway?",
            "answer": "1) Timeout: if service doesn't respond in 5s, timeout. 2) Retry: retry failed requests (idempotent only). 3) Circuit Breaker: if service fails 5x, stop sending requests (open circuit). 4) Fallback: return cached data or default response. 5) Logging: log all errors for debugging. Example: GET /orders â†’ timeout â†’ retry 2x â†’ circuit open â†’ return cached â†’ client gets response within 10s instead of hanging.",
            "useCases": [
                "Resilience"
            ],
            "realTimeUseCases": [
                "Failure handling"
            ]
        },
        {
            "id": 17,
            "name": "What is Service Discovery and why is it needed?",
            "question": "What is Service Discovery and why is it needed?",
            "answer": "Service Discovery: mechanism to find service instances dynamically. Needed because: microservice instances scale up/down, IP addresses change, hardcoding IPs won't work. Two patterns: 1) Client-side: client queries registry to find service. 2) Server-side: load balancer queries registry. Registry: Consul, Eureka, etcd. Health checks ensure only healthy instances listed.",
            "useCases": [
                "Dynamic configuration"
            ],
            "realTimeUseCases": [
                "Scaling infrastructure"
            ]
        },
        {
            "id": 18,
            "name": "What is the difference between Service Registry and Service Discovery?",
            "question": "What is the difference between Service Registry and Service Discovery?",
            "answer": "Service Registry: database storing service metadata (name, IP, port, health). Service Discovery: process of finding service from registry. Registry is storage; Discovery is the query mechanism. Analogy: Registry = phone book; Discovery = looking up a number. Both needed: services register themselves (registry); clients/gateways discover (discovery).",
            "useCases": [
                "Terminology clarity"
            ],
            "realTimeUseCases": [
                "Architecture understanding"
            ]
        },
        {
            "id": 19,
            "name": "What are the types of Service Discovery?",
            "question": "What are the types of Service Discovery?",
            "answer": "1) Client-side Discovery: client queries registry (Consul, Eureka), gets list, picks one, calls directly. Pros: simple. Cons: logic in client. 2) Server-side Discovery: client calls load balancer; balancer queries registry, routes. Pros: client simple, centralized. Cons: extra hop. 3) DNS-based: use DNS for service lookup. Each type has tradeoffs; server-side preferred for simplicity.",
            "useCases": [
                "Discovery patterns"
            ],
            "realTimeUseCases": [
                "Architecture choice"
            ]
        },
        {
            "id": 20,
            "name": "What is Client-side vs Server-side Load Balancing?",
            "question": "What is Client-side vs Server-side Load Balancing?",
            "answer": "Client-side: client queries service registry, gets list of instances, picks one (round-robin), calls directly. Pros: no extra hop. Cons: client logic complexity. Server-side: client calls load balancer; balancer routes to instances. Pros: simple client. Cons: extra network hop. Microservices typically use both: client-side from gateway to services (performance), server-side within service clusters (simplicity).",
            "useCases": [
                "Load balancing strategy"
            ],
            "realTimeUseCases": [
                "Scaling design"
            ]
        },
        {
            "id": 21,
            "name": "How does inter-service communication work in microservices?",
            "question": "How does inter-service communication work in microservices?",
            "answer": "1) Service A needs data from Service B. 2) Service A queries Service Discovery: 'find Service B'. 3) Gets list of B instances (e.g., 3 IPs). 4) Service A calls one instance via HTTP/gRPC. 5) Service B processes, returns response. 6) Service A caches/processes response. On failure: retry another instance, apply circuit breaker, fallback.",
            "useCases": [
                "Service interaction"
            ],
            "realTimeUseCases": [
                "Communication patterns"
            ]
        },
        {
            "id": 22,
            "name": "What is the microservices communication architecture?",
            "question": "What is the microservices communication architecture?",
            "answer": "Architecture: Client â†’ API Gateway (entry point) â†’ microservices (Product, Order, Payment) â†’ external services. Sync communication: REST within services. Async: Kafka for events. Service Discovery enables dynamic routing. Load Balancing distributes traffic. Circuit Breaker handles failures. Result: scalable, resilient system where services communicate independently.",
            "useCases": [
                "System architecture"
            ],
            "realTimeUseCases": [
                "Design pattern"
            ]
        },
        {
            "id": 23,
            "name": "What is Load Balancing in microservices?",
            "question": "What is Load Balancing in microservices?",
            "answer": "Load Balancing: distributing incoming traffic across multiple instances. Purpose: 1) Even distribution prevents overload. 2) Fault tolerance if one instance fails. 3) Horizontal scaling (add more instances). Algorithms: Round-robin (in order), Least Connections, IP Hash. Placement: within services (Pod level), at gateway (external traffic). Essential for high availability.",
            "useCases": [
                "Traffic distribution"
            ],
            "realTimeUseCases": [
                "High availability"
            ]
        },
        {
            "id": 24,
            "name": "Why is Load Balancing necessary and how does it work with Service Discovery?",
            "question": "Why is Load Balancing necessary and how does it work with Service Discovery?",
            "answer": "Necessary: multiple instances, need to distribute traffic evenly. Without: all requests go to first instance (overload), others idle. With: traffic spread across instances. Integration: Service Discovery lists instances (e.g., Product Service has 3 instances). Load Balancer picks one via algorithm (round-robin). On instance failure: removed from registry, load balancer skips it. Ensures availability and performance.",
            "useCases": [
                "Availability and performance"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 25,
            "name": "What is the Circuit Breaker pattern?",
            "question": "What is the Circuit Breaker pattern?",
            "answer": "Circuit Breaker: prevents cascading failures by stopping calls to failing services. States: 1) CLOSED (normal): requests pass through. 2) OPEN (failure): requests fail fast without attempting. 3) HALF_OPEN (recovery): try request, if success close; if fail, reopen. Example: Order Service calls Payment Service 5x fails â†’ circuit opens â†’ requests fail immediately (prevent hanging) â†’ after 30s try again.",
            "useCases": [
                "Failure prevention"
            ],
            "realTimeUseCases": [
                "Resilience"
            ]
        },
        {
            "id": 26,
            "name": "What are the states of Circuit Breaker?",
            "question": "What are the states of Circuit Breaker?",
            "answer": "1) CLOSED: normal operation, requests pass. 2) OPEN: service failing, requests blocked (fail fast). 3) HALF_OPEN: testing recovery, allow limited requests. Transitions: CLOSED â†’ OPEN (after N failures or timeout). OPEN â†’ HALF_OPEN (after timeout, e.g., 30s). HALF_OPEN â†’ CLOSED (success) or OPEN (failure). Prevents system cascade failures, allows recovery time.",
            "useCases": [
                "State management"
            ],
            "realTimeUseCases": [
                "Error handling"
            ]
        },
        {
            "id": 27,
            "name": "What are the types of Circuit Breaker patterns?",
            "question": "What are the types of Circuit Breaker patterns?",
            "answer": "1) Count-based: after N failures, open circuit. 2) Time-based: fail rate > threshold in time window, open. 3) Exception-based: specific exceptions trigger open. 4) Custom: combine multiple conditions. Implementation: hystrix (Java), opossum (Node.js), sentinel. Example: Order Service â†’ if Payment Service fails 5x in 1min, open circuit.",
            "useCases": [
                "Pattern variations"
            ],
            "realTimeUseCases": [
                "Implementation"
            ]
        },
        {
            "id": 28,
            "name": "What is the Retry Pattern in microservices?",
            "question": "What is the Retry Pattern in microservices?",
            "answer": "Retry: automatically resend failed requests. Useful for transient failures (network hiccup). Strategy: 1) Immediate retry: no wait. 2) Fixed backoff: wait 1s, retry. 3) Exponential backoff: wait 1s, 2s, 4s. 4) Jitter: add randomness to prevent thundering herd. Max retries: typically 3. Idempotent operations only: retrying PUT/POST must be safe. Example: call fails â†’ wait 100ms â†’ retry â†’ success.",
            "useCases": [
                "Transient failure handling"
            ],
            "realTimeUseCases": [
                "Resilience"
            ]
        },
        {
            "id": 29,
            "name": "What is the Timeout Pattern?",
            "question": "What is the Timeout Pattern?",
            "answer": "Timeout: maximum time to wait for response. If service takes > timeout, fail request. Purpose: prevent hanging forever, fail fast. Examples: 5s for API calls, 30s for batch jobs. Too short: false failures. Too long: slow user experience. Implementation: setTimeout in Node.js, @Transactional(timeout) in Spring. Combine with retries: fail fast, retry another instance.",
            "useCases": [
                "Failure prevention"
            ],
            "realTimeUseCases": [
                "Performance"
            ]
        },
        {
            "id": 30,
            "name": "What is the Bulkhead Pattern?",
            "question": "What is the Bulkhead Pattern?",
            "answer": "Bulkhead: isolate resources (threads, connections) per operation. Purpose: failure in one operation doesn't exhaust shared resources. Example: Order Service has 10 threads. 5 for external calls, 5 for internal. If external call hangs, only 5 threads blocked, 5 still available for internal. Prevents system-wide resource exhaustion. Similar to ship compartments (if one floods, others isolated).",
            "useCases": [
                "Resource isolation"
            ],
            "realTimeUseCases": [
                "Resilience"
            ]
        },
        {
            "id": 31,
            "name": "What is the Fallback Pattern?",
            "question": "What is the Fallback Pattern?",
            "answer": "Fallback: provide degraded response if service fails. Instead of error, return cached data or default. Example: Product Service down â†’ return cached products (stale data). Order Service down â†’ queue order locally, process later. Improves user experience: partial functionality vs complete failure. Implementation: catch exception, return fallback.",
            "useCases": [
                "Graceful degradation"
            ],
            "realTimeUseCases": [
                "User experience"
            ]
        },
        {
            "id": 32,
            "name": "What is the Saga Pattern and why is it used?",
            "question": "What is the Saga Pattern and why is it used?",
            "answer": "Saga: manages distributed transactions without ACID. Coordinates multiple services: Order (create) â†’ Payment (charge) â†’ Inventory (decrement). If Payment fails: compensate by canceling order. Two types: 1) Choreography: services react to events (loose coupling). 2) Orchestration: central coordinator directs flow. Saga ensures eventual consistency across services.",
            "useCases": [
                "Distributed transactions"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 33,
            "name": "What are the types of Saga Pattern?",
            "question": "What are the types of Saga Pattern?",
            "answer": "1) Choreography Saga: services listen to events, react independently. Order Service emits 'order.created' â†’ Payment Service listens, charges. Pros: loose coupling. Cons: hard to follow flow. 2) Orchestration Saga: coordinator controls flow. Saga Orchestrator: 'Create Order' â†’ 'Process Payment' â†’ 'Update Inventory'. Pros: clear flow. Cons: central point of failure. Choice: choreography for simple flows, orchestration for complex.",
            "useCases": [
                "Saga types"
            ],
            "realTimeUseCases": [
                "Design decision"
            ]
        },
        {
            "id": 34,
            "name": "What are Compensating Transactions in Saga Pattern?",
            "question": "What are Compensating Transactions in Saga Pattern?",
            "answer": "Compensating Transaction: undo operation on failure. Example: Order Saga: 1) Create Order (success). 2) Charge Payment (fails). 3) Compensate: cancel order (rollback). Each step has corresponding undo. Ensures consistency: if any step fails, entire saga compensates. Different from DB rollback: each service independently compensates.",
            "useCases": [
                "Failure handling"
            ],
            "realTimeUseCases": [
                "Data consistency"
            ]
        },
        {
            "id": 35,
            "name": "What mechanisms ensure consistency in distributed transactions?",
            "question": "What mechanisms ensure consistency in distributed transactions?",
            "answer": "1) Saga Pattern: compensate on failure. 2) Event Sourcing: store all events, rebuild state. 3) Distributed Transactions: 2PC (complex, slow). 4) Eventual Consistency: accept temporary inconsistency, converge over time. 5) Consensus Algorithms: Raft, Paxos (complex). Best: Saga + Event Sourcing + eventual consistency model. Full ACID impossible; aim for BASE (Basically Available, Soft state, Eventual consistency).",
            "useCases": [
                "Consistency strategies"
            ],
            "realTimeUseCases": [
                "Architecture"
            ]
        },
        {
            "id": 36,
            "name": "What is CQRS (Command Query Responsibility Segregation)?",
            "question": "What is CQRS (Command Query Responsibility Segregation)?",
            "answer": "CQRS: separate read and write models. Writes go to write database (normalized), reads from read database (denormalized). Benefits: 1) Optimize each model for its use case. 2) Independent scaling. 3) Complex queries on read model easy. 4) Event sourcing fits naturally. Trade-off: eventual consistency (read model lags behind writes). Example: Order placed â†’ write DB â†’ event â†’ update read cache (eventual).",
            "useCases": [
                "Scalability",
                "Query optimization"
            ],
            "realTimeUseCases": [
                "High-load systems"
            ]
        },
        {
            "id": 37,
            "name": "What is Event Sourcing?",
            "question": "What is Event Sourcing?",
            "answer": "Event Sourcing: store all state changes as events (immutable log). Current state = replay all events. Benefits: 1) Complete audit trail. 2) Temporal queries (state at any point). 3) Recovery: replay events. 4) Debugging: see exact sequence. Trade-off: complexity, eventual consistency. Example: Order events = 'OrderCreated' â†’ 'PaymentProcessed' â†’ 'OrderShipped'. Current state derived by replaying.",
            "useCases": [
                "Audit trail",
                "Recovery"
            ],
            "realTimeUseCases": [
                "Finance systems"
            ]
        },
        {
            "id": 38,
            "name": "How do you integrate Event Sourcing with CQRS?",
            "question": "How do you integrate Event Sourcing with CQRS?",
            "answer": "Write model: Command (CreateOrder) â†’ Event (OrderCreated) stored in event store. Event triggers projection: Read model updated (async). Query from read model (fast, denormalized). Benefits: 1) Write optimized (appending events). 2) Read optimized (denormalized projection). 3) Complete audit trail. 4) Scalable independently. Drawback: eventual consistency, complex setup.",
            "useCases": [
                "Advanced architecture"
            ],
            "realTimeUseCases": [
                "Enterprise systems"
            ]
        },
        {
            "id": 39,
            "name": "When should you NOT use CQRS and Event Sourcing?",
            "question": "When should you NOT use CQRS and Event Sourcing?",
            "answer": "Don't use for: 1) Simple CRUD apps (over-engineering). 2) Real-time consistency required. 3) Small scale (complexity not justified). 4) Team lacks expertise. 5) Tight deadline (learning curve steep). Use if: large systems, complex domain, audit requirements, scalability critical. Sweet spot: financial systems, eCommerce orders, user activity logs.",
            "useCases": [
                "Decision criteria"
            ],
            "realTimeUseCases": [
                "Project assessment"
            ]
        },
        {
            "id": 40,
            "name": "What is Security in Microservices and why is it challenging?",
            "question": "What is Security in Microservices and why is it challenging?",
            "answer": "Challenges: 1) Multiple entry points (multiple services). 2) Inter-service communication (network). 3) Token expiry across services. 4) Complex auth policies. 5) Cascading trust issues. Solutions: 1) API Gateway auth. 2) JWT for inter-service. 3) HTTPS only. 4) Secrets management (Vault). 5) Service-to-service authentication. 6) Rate limiting. 7) Input validation.",
            "useCases": [
                "Security overview"
            ],
            "realTimeUseCases": [
                "Risk mitigation"
            ]
        },
        {
            "id": 41,
            "name": "What types of Security are needed in microservices?",
            "question": "What types of Security are needed in microservices?",
            "answer": "1) Authentication: verify user identity (JWT, OAuth). 2) Authorization: verify permissions (RBAC). 3) Encryption: data in transit (HTTPS, TLS). 4) Secrets management: API keys, DB passwords. 5) API Gateway security: rate limiting, DDoS. 6) Network security: firewalls, service mesh. 7) Audit logging: track actions. 8) Input validation: prevent injection attacks.",
            "useCases": [
                "Security types"
            ],
            "realTimeUseCases": [
                "Implementation checklist"
            ]
        },
        {
            "id": 42,
            "name": "How do you use JWT for inter-service communication?",
            "question": "How do you use JWT for inter-service communication?",
            "answer": "Service A â†’ Service B: include JWT in request header. Service B verifies JWT signature using shared secret. If valid, trust Service A. Benefits: stateless, no session lookup. Challenge: token expiry. Solution: short-lived tokens, refresh mechanism. Symmetric (HS256, shared secret) for internal, asymmetric (RS256, public key) for multi-org.",
            "useCases": [
                "Service auth"
            ],
            "realTimeUseCases": [
                "API calls"
            ]
        },
        {
            "id": 43,
            "name": "What is the difference between Authentication and Authorization?",
            "question": "What is the difference between Authentication and Authorization?",
            "answer": "Authentication: verify WHO you are (login with credentials). Question: 'Are you John?' Answer: yes/no. Authorization: verify WHAT you can do (permissions). Question: 'Can John delete users?' Answer: only if admin role. Both needed: authenticate first (prove identity), then authorize (check permissions). JWT contains both: identity (sub: userId) + permissions (role: admin).",
            "useCases": [
                "Security concepts"
            ],
            "realTimeUseCases": [
                "Implementation"
            ]
        },
        {
            "id": 44,
            "name": "How do you secure inter-microservice communication?",
            "question": "How do you secure inter-microservice communication?",
            "answer": "1) mTLS: mutual TLS, certificate-based. Both services verify each other. 2) JWT: token-based. Service A sends JWT to Service B. 3) Service Mesh (Istio): handles auth automatically. 4) API Key: simple but less secure. 5) OAuth2: for external services. Best: mTLS + JWT for defense in depth. Encrypt all inter-service traffic.",
            "useCases": [
                "Communication security"
            ],
            "realTimeUseCases": [
                "Trust"
            ]
        },
        {
            "id": 45,
            "name": "How do you secure API Gateway endpoints?",
            "question": "How do you secure API Gateway endpoints?",
            "answer": "1) HTTPS only (TLS). 2) JWT validation: reject invalid tokens. 3) Rate limiting: prevent brute force. 4) Input validation: prevent injection. 5) WAF (Web Application Firewall): block malicious requests. 6) DDoS protection. 7) Secrets management: store keys safely. 8) Audit logging: log all requests. 9) CORS: allow only trusted origins.",
            "useCases": [
                "Gateway security"
            ],
            "realTimeUseCases": [
                "Protection"
            ]
        },
        {
            "id": 46,
            "name": "What is Apache Kafka and why is it used?",
            "question": "What is Apache Kafka and why is it used?",
            "answer": "Kafka: distributed event streaming platform. Purpose: 1) Async communication between services. 2) Event logging. 3) Stream processing. 4) Real-time analytics. Why microservices: 1) Decouples services (loose coupling). 2) Resilience: if consumer down, events buffered. 3) Scalability: process events in parallel. 4) Durability: persists events. Example: Order Service publishes to 'orders' topic; Payment, Inventory consume.",
            "useCases": [
                "Event streaming",
                "Async messaging"
            ],
            "realTimeUseCases": [
                "eCommerce"
            ]
        },
        {
            "id": 47,
            "name": "What are Kafka Topics and Partitions?",
            "question": "What are Kafka Topics and Partitions?",
            "answer": "Topic: logical channel for events (e.g., 'orders'). Partition: physical subdivision of topic (e.g., 'orders' has 3 partitions). Benefits: 1) Parallel processing (each partition processed independently). 2) Ordering: events in partition ordered. 3) Replication: each partition replicated across brokers. Partitioning strategy: by order ID ensures all events for order in same partition (ordering).",
            "useCases": [
                "Kafka architecture"
            ],
            "realTimeUseCases": [
                "Topic design"
            ]
        },
        {
            "id": 48,
            "name": "What is a Kafka Consumer Group?",
            "question": "What is a Kafka Consumer Group?",
            "answer": "Consumer Group: multiple consumers reading from same topic. Kafka distributes partitions among consumers: 3 partitions, 3 consumers â†’ each gets 1. Benefits: 1) Parallel processing. 2) Load balancing. 3) High availability: if consumer fails, others rebalance. If 2 consumers: 1 gets 2 partitions, 1 gets 1. Consumer group tracks offset (position in partition).",
            "useCases": [
                "Parallel processing"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 49,
            "name": "What is Consumer Lag in Kafka?",
            "question": "What is Consumer Lag in Kafka?",
            "answer": "Consumer Lag: difference between latest offset (newest event) and consumer offset (where consumer is). Example: topic has 1000 events, consumer at 950 â†’ lag = 50. Indicates: lag = 0 means consumer caught up. High lag means consumer slow, events piling up. Monitor: if lag increasing, consumer hanging. Solution: scale consumers (add more to group, rebalance), optimize processing.",
            "useCases": [
                "Performance monitoring"
            ],
            "realTimeUseCases": [
                "Debugging"
            ]
        },
        {
            "id": 50,
            "name": "What is exactly-once semantics in Kafka?",
            "question": "What is exactly-once semantics in Kafka?",
            "answer": "Exactly-once: event processed EXACTLY once, not 0, not 2+. Challenges: if consumer crashes after processing but before committing offset, event reprocessed (at-least-once). If consumer crashes after committing but before side-effect, event not processed. Solution: idempotent consumer (idempotency key), distributed transactions (complex). Most systems: at-least-once + idempotent handlers.",
            "useCases": [
                "Reliability guarantees"
            ],
            "realTimeUseCases": [
                "Critical systems"
            ]
        },
        {
            "id": 51,
            "name": "What is Idempotency in Kafka and why is it important?",
            "question": "What is Idempotency in Kafka and why is it important?",
            "answer": "Idempotency: processing same event multiple times has same effect as once. Important: Kafka doesn't guarantee exactly-once (can reprocess). Solution: track processed events (idempotency key). Example: Order event id=123 â†’ if already processed, skip. Stored in DB: processed_events table (event_id unique). Ensures correctness even with retries/failures.",
            "useCases": [
                "Fault tolerance"
            ],
            "realTimeUseCases": [
                "Financial transactions"
            ]
        },
        {
            "id": 52,
            "name": "What is Log Compaction in Kafka?",
            "question": "What is Log Compaction in Kafka?",
            "answer": "Log Compaction: retain only latest value per key. Example: user topic with events: (user_id=1, name='John'), (user_id=1, name='Jane') â†’ compacted keeps only latest (user_id=1, name='Jane'). Benefits: 1) Space efficient. 2) Fast snapshot (latest state per key). 3) Enables state restoration. Use case: configuration events, user profile changes.",
            "useCases": [
                "Storage optimization"
            ],
            "realTimeUseCases": [
                "Long-running topics"
            ]
        },
        {
            "id": 53,
            "name": "What is event-driven architecture and how does it benefit microservices?",
            "question": "What is event-driven architecture and how does it benefit microservices?",
            "answer": "Event-driven: services communicate via events (not direct calls). Example: Order created â†’ emit 'order.created' event. Email Service, Inventory Service listen and react. Benefits: 1) Loose coupling (services don't know each other). 2) Scalability (consumers scale independently). 3) Resilience (if email down, event buffered). 4) Async processing (non-blocking). Challenges: eventual consistency.",
            "useCases": [
                "Async architecture"
            ],
            "realTimeUseCases": [
                "Scalable systems"
            ]
        },
        {
            "id": 54,
            "name": "What are the benefits of using event-driven architecture?",
            "question": "What are the benefits of using event-driven architecture?",
            "answer": "1) Decoupling: services independent (loose coupling). 2) Scalability: consumers scale per domain. 3) Resilience: failures isolated. 4) Latency: async processing faster. 5) Extensibility: add new consumers without changing producer. 6) Audit: all events logged. 7) Debugging: complete event history. Suitable for: eCommerce, IoT, real-time analytics.",
            "useCases": [
                "Architecture benefits"
            ],
            "realTimeUseCases": [
                "Design advantages"
            ]
        },
        {
            "id": 55,
            "name": "What is Database-per-Service pattern?",
            "question": "What is Database-per-Service pattern?",
            "answer": "Database-per-Service: each microservice owns its database. Benefits: 1) Technology freedom (use MongoDB, PostgreSQL per service). 2) Independent scaling. 3) Loose coupling (DB schema changes not global). 4) Polyglot persistence. Challenge: distributed transactions, data consistency. Solution: Saga pattern, event-driven, eventual consistency. Example: User Service (PostgreSQL), Order Service (MongoDB).",
            "useCases": [
                "Data architecture"
            ],
            "realTimeUseCases": [
                "Microservices design"
            ]
        },
        {
            "id": 56,
            "name": "How do you achieve data consistency across services?",
            "question": "How do you achieve data consistency across services?",
            "answer": "1) Saga Pattern: coordinate transactions across services. 2) Event Sourcing: event log as source of truth. 3) Eventual Consistency: accept lag, converge eventually. 4) Synchronous Calls: call other service directly (tight coupling). 5) Caching: cache external data locally. Trade-off: strong vs eventual consistency. Most systems: eventual consistency + Saga for critical flows.",
            "useCases": [
                "Consistency strategies"
            ],
            "realTimeUseCases": [
                "Design"
            ]
        },
        {
            "id": 57,
            "name": "What is the Distributed Transaction problem?",
            "question": "What is the Distributed Transaction problem?",
            "answer": "Distributed Transaction: single transaction spans multiple services. Challenge: traditional ACID transactions only within single DB. Across DBs: 1) 2PC (Two-Phase Commit): complex, slow, blocks. 2) Saga: eventual consistency. 3) Compensating transactions: undo on failure. Example: Order + Payment: order created, but payment fails â†’ must rollback order. Solution: Saga (recommended).",
            "useCases": [
                "Transaction management"
            ],
            "realTimeUseCases": [
                "Consistency"
            ]
        },
        {
            "id": 58,
            "name": "What is Eventual Consistency?",
            "question": "What is Eventual Consistency?",
            "answer": "Eventual Consistency: data not immediately consistent across services, but converges eventually. Example: Order placed â†’ order status updated in Order Service â†’ event published â†’ Inventory Service consumes â†’ inventory updated (lag = few ms). Acceptable for non-critical data. Unacceptable for payments (must be instant). Achievable via: events, caching, sync checks.",
            "useCases": [
                "Consistency model"
            ],
            "realTimeUseCases": [
                "Modern systems"
            ]
        },
        {
            "id": 59,
            "name": "What are Read Replicas and how do they help?",
            "question": "What are Read Replicas and how do they help?",
            "answer": "Read Replica: copy of database for read operations. Master handles writes; replicas handle reads. Benefits: 1) Scale reads (multiple replicas). 2) Reduce master load. 3) High availability (if master fails, promote replica). 4) Geographic distribution (replicas in different regions). Challenges: replication lag (replica may be slightly stale). SQL: native, MongoDB: sharding.",
            "useCases": [
                "Read scaling"
            ],
            "realTimeUseCases": [
                "High-load systems"
            ]
        },
        {
            "id": 60,
            "name": "How do you handle schema changes in microservices?",
            "question": "How do you handle schema changes in microservices?",
            "answer": "Challenge: schema change affects all services. Solution: 1) Backward compatibility: add new optional fields, don't remove. 2) API versioning: /v1 old schema, /v2 new. 3) Migration: gradual rollout (canary deployment). 4) Event versioning: version events, multiple parsers. 5) Strangler pattern: old DB alongside new. Avoid: breaking schema changes that crash consumers.",
            "useCases": [
                "Evolution"
            ],
            "realTimeUseCases": [
                "Updates"
            ]
        },
        {
            "id": 61,
            "name": "What is Microservices Communication (Synchronous)?",
            "question": "What is Microservices Communication (Synchronous)?",
            "answer": "Synchronous: caller waits for response. REST: Order Service calls Payment Service, waits for result. Pros: simple, immediate feedback. Cons: tight coupling, cascading failures (if Payment slow, Order slow). Timeout needed: prevent hanging. Retry with backoff. Use for: critical operations (payment), request-response pattern.",
            "useCases": [
                "Direct communication"
            ],
            "realTimeUseCases": [
                "HTTP APIs"
            ]
        },
        {
            "id": 62,
            "name": "What is Microservices Communication (Asynchronous)?",
            "question": "What is Microservices Communication (Asynchronous)?",
            "answer": "Asynchronous: caller doesn't wait. Order Service publishes event 'order.created'; Payment Service consumes later. Pros: loose coupling, resilience, scalability. Cons: eventual consistency, complex debugging. Use for: notifications, non-critical updates, high-volume events. Technology: Kafka, RabbitMQ, SNS.",
            "useCases": [
                "Event-based communication"
            ],
            "realTimeUseCases": [
                "High-scale systems"
            ]
        },
        {
            "id": 63,
            "name": "REST vs Kafka: when to use which?",
            "question": "REST vs Kafka: when to use which?",
            "answer": "REST: 1) Request-response pattern. 2) Immediate response needed. 3) Simple interactions. 4) Low latency critical. Example: get product by ID. Kafka: 1) Fire-and-forget. 2) Multiple consumers. 3) Event streaming. 4) Eventual consistency OK. Example: order placed â†’ multiple services consume. Best: use both (sync for critical, async for others).",
            "useCases": [
                "Communication choice"
            ],
            "realTimeUseCases": [
                "Design decision"
            ]
        },
        {
            "id": 64,
            "name": "How does a synchronous request flow work in microservices?",
            "question": "How does a synchronous request flow work in microservices?",
            "answer": "1) Client â†’ API Gateway: POST /orders. 2) Gateway â†’ Order Service: create order. 3) Order Service â†’ Payment Service: charge. 4) Payment Service: process, return response. 5) Order Service: receives response, updates order status. 6) Order Service â†’ Gateway: response. 7) Gateway â†’ Client: response. Entire flow: ~500ms. If any service fails, client gets error immediately.",
            "useCases": [
                "Request flow"
            ],
            "realTimeUseCases": [
                "REST APIs"
            ]
        },
        {
            "id": 65,
            "name": "How does an asynchronous request flow work in microservices?",
            "question": "How does an asynchronous request flow work in microservices?",
            "answer": "1) Client â†’ API Gateway: POST /orders. 2) Gateway â†’ Order Service: create order. 3) Order Service: save order (immediately return), publish 'order.created' event. 4) Client receives response immediately (order queued). 5) Payment Service consumes event (async). 6) Payment Service: process payment. 7) Email Service: send confirmation (async). Complete flow: client response ~10ms, backend async ~500ms. Non-blocking.",
            "useCases": [
                "Async flow"
            ],
            "realTimeUseCases": [
                "High-volume systems"
            ]
        },
        {
            "id": 66,
            "name": "What is Caching in Microservices?",
            "question": "What is Caching in Microservices?",
            "answer": "Caching: store frequently accessed data in fast storage (memory, Redis). Purpose: reduce DB hits, improve latency. Example: cache product list (1h TTL). Cache aside: on miss, fetch from DB, cache result. Cache-through: cache acts as entry point. Cache-back: write to cache first, sync to DB. Invalidation: remove cache on update. Tools: Redis, Memcached.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Scalability"
            ]
        },
        {
            "id": 67,
            "name": "What is distributed caching in microservices?",
            "question": "What is distributed caching in microservices?",
            "answer": "Distributed Cache: shared across services (Redis cluster). Benefits: 1) Services see same cache (consistency). 2) Persistent (survives service restart). 3) Scalable (add nodes). 4) High availability (replicated). Example: cache product catalog in Redis. Order, Product, Recommendation services all access same cache. Challenges: network latency, consistency (TTL/invalidation).",
            "useCases": [
                "Shared caching"
            ],
            "realTimeUseCases": [
                "Multi-service"
            ]
        },
        {
            "id": 68,
            "name": "What is Spring Cloud Config Server?",
            "question": "What is Spring Cloud Config Server?",
            "answer": "Spring Cloud Config Server: centralized configuration management. Services fetch config at startup/runtime. Benefits: 1) Single source of truth. 2) Update config without redeployment (refresh). 3) Environment-specific (dev, prod). 4) Secure secrets. Alternative: Consul, etcd. Example: database URL, feature flags, timeouts configured centrally.",
            "useCases": [
                "Configuration management"
            ],
            "realTimeUseCases": [
                "Dynamic config"
            ]
        },
        {
            "id": 69,
            "name": "What is centralized configuration in microservices?",
            "question": "What is centralized configuration in microservices?",
            "answer": "Centralized Config: single place for all service configs. Avoid: hardcoding. Benefits: 1) Change without redeployment. 2) Environment separation. 3) Secure secrets (encryption). 4) Audit (track changes). Tools: ConfigServer, Consul, Kubernetes ConfigMap. Example: db_url, api_timeout, log_level centralized.",
            "useCases": [
                "Configuration"
            ],
            "realTimeUseCases": [
                "Operations"
            ]
        },
        {
            "id": 70,
            "name": "What are Health Checks in microservices?",
            "question": "What are Health Checks in microservices?",
            "answer": "Health Check: endpoint reporting service health. Endpoint: /health returns status (UP, DOWN, DEGRADED). Checks: 1) Database connectivity. 2) External service availability. 3) Memory/disk. Benefits: 1) Load balancer removes unhealthy. 2) Service Discovery marks as down. 3) Auto-recovery (restart unhealthy). Example: if DB down, health returns DOWN, service removed from registry.",
            "useCases": [
                "Availability"
            ],
            "realTimeUseCases": [
                "Monitoring"
            ]
        },
        {
            "id": 71,
            "name": "What are Actuator Endpoints in Spring Boot microservices?",
            "question": "What are Actuator Endpoints in Spring Boot microservices?",
            "answer": "Actuator: exposes operational endpoints. Key endpoints: /health (status), /metrics (performance), /env (environment), /loggers (log level). Benefits: 1) Monitor application state. 2) Tune at runtime. 3) Troubleshoot issues. Example: /metrics shows request latency, memory usage. /loggers allows changing log level without restart.",
            "useCases": [
                "Operational insights"
            ],
            "realTimeUseCases": [
                "Debugging"
            ]
        },
        {
            "id": 72,
            "name": "What is centralized logging in microservices?",
            "question": "What is centralized logging in microservices?",
            "answer": "Centralized Logging: all service logs in single place (ELK stack). Benefits: 1) Search across services (find all errors). 2) Correlation: trace request across services via trace ID. 3) Analytics: identify patterns. 4) Archival: compliance. Tools: ELK (Elasticsearch, Logstash, Kibana), Splunk, Datadog. Example: search logs for order_id=123 across all services.",
            "useCases": [
                "Debugging",
                "Analytics"
            ],
            "realTimeUseCases": [
                "Production troubleshooting"
            ]
        },
        {
            "id": 73,
            "name": "What is centralized monitoring in microservices?",
            "question": "What is centralized monitoring in microservices?",
            "answer": "Centralized Monitoring: collect metrics from all services (CPU, memory, latency). Tools: Prometheus (scrape metrics), Grafana (dashboard). Benefits: 1) Track health (memory increasing?). 2) Identify bottlenecks. 3) Set alerts (memory > 80%). 4) Capacity planning. Typical metrics: latency, throughput, error rate, resource usage.",
            "useCases": [
                "Observability"
            ],
            "realTimeUseCases": [
                "Ops monitoring"
            ]
        },
        {
            "id": 74,
            "name": "What is Distributed Tracing?",
            "question": "What is Distributed Tracing?",
            "answer": "Distributed Tracing: follow request across services. Trace ID: injected in every request, logged at each service. Tools: Jaeger, Zipkin. Flow: Client â†’ API Gateway (trace_id=123) â†’ Order Service â†’ Payment Service. Visualize: timeline showing latency per step. Benefits: identify slow services, bottlenecks. Example: order checkout takes 2s; tracing shows Payment Service = 1.8s.",
            "useCases": [
                "Performance debugging"
            ],
            "realTimeUseCases": [
                "Latency analysis"
            ]
        },
        {
            "id": 75,
            "name": "What are Correlation IDs and how do they help?",
            "question": "What are Correlation IDs and how do they help?",
            "answer": "Correlation ID: unique ID for entire request flow (same as trace ID). Injected at entry (API Gateway), passed through all services. Benefit: correlate logs across services. Search: grep correlation_id=123 in logs â†’ see all actions for this request. Debugging: understand request path, timing, failures. Essential for distributed systems.",
            "useCases": [
                "Request tracking"
            ],
            "realTimeUseCases": [
                "Debugging"
            ]
        },
        {
            "id": 76,
            "name": "What are Design Patterns used in microservices?",
            "question": "What are Design Patterns used in microservices?",
            "answer": "Key patterns: 1) API Gateway. 2) Service Discovery. 3) Circuit Breaker. 4) Saga. 5) CQRS. 6) Event Sourcing. 7) Strangler Fig. 8) Database-per-Service. 9) Cache-Aside. 10) Bulkhead. 11) Retry. 12) Timeout. 13) Fallback. Understanding these: essential for robust microservices.",
            "useCases": [
                "Architecture patterns"
            ],
            "realTimeUseCases": [
                "System design"
            ]
        },
        {
            "id": 77,
            "name": "What is the API Gateway Pattern?",
            "question": "What is the API Gateway Pattern?",
            "answer": "Pattern: single entry point for all client requests. Responsibilities: routing, authentication, rate limiting, response aggregation. Benefits: 1) Clients don't know service locations. 2) Centralized cross-cutting concerns. 3) API evolution (versioning, deprecation). Implementation: Kong, AWS API Gateway, Netflix Zuul.",
            "useCases": [
                "Entry point"
            ],
            "realTimeUseCases": [
                "Client-server"
            ]
        },
        {
            "id": 78,
            "name": "What is the Saga Pattern?",
            "question": "What is the Saga Pattern?",
            "answer": "Pattern: distributed transaction across services. Coordinates multi-step flows (order â†’ payment â†’ inventory). Two types: 1) Choreography (event-driven). 2) Orchestration (central coordinator). Ensures eventual consistency: if step fails, compensate (rollback). Without: distributed transaction complexity.",
            "useCases": [
                "Distributed transactions"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 79,
            "name": "What is the Circuit Breaker Pattern?",
            "question": "What is the Circuit Breaker Pattern?",
            "answer": "Pattern: prevents cascading failures. States: CLOSED (normal) â†’ OPEN (failing, fail-fast) â†’ HALF_OPEN (testing recovery). Benefits: 1) Fail fast (don't wait for hanging service). 2) Recovery time (allow service to restart). 3) Resilience. Implementation: Hystrix, Resilience4j.",
            "useCases": [
                "Failure prevention"
            ],
            "realTimeUseCases": [
                "Resilience"
            ]
        },
        {
            "id": 80,
            "name": "What is the CQRS Pattern?",
            "question": "What is the CQRS Pattern?",
            "answer": "Pattern: separate read and write models. Writes: to write DB (normalized). Reads: from read DB (denormalized, cached). Benefits: 1) Optimize each model. 2) Independent scaling. 3) Complex queries simple. Trade-off: eventual consistency. Example: write to SQL, read from Redis cache.",
            "useCases": [
                "Scalability"
            ],
            "realTimeUseCases": [
                "High-load systems"
            ]
        },
        {
            "id": 81,
            "name": "What is the Event Sourcing Pattern?",
            "question": "What is the Event Sourcing Pattern?",
            "answer": "Pattern: store all state changes as immutable events. Current state = replay events. Benefits: 1) Audit trail. 2) Temporal queries. 3) Recovery. 4) Debugging. Trade-off: complexity, eventual consistency. Example: Order events = created â†’ paid â†’ shipped. Current state derived.",
            "useCases": [
                "Audit",
                "History"
            ],
            "realTimeUseCases": [
                "Financial systems"
            ]
        },
        {
            "id": 82,
            "name": "What is the Strangler Fig Pattern?",
            "question": "What is the Strangler Fig Pattern?",
            "answer": "Pattern: gradually migrate monolith to microservices. Old system running; new microservice slowly replaces functionality. Traffic gradually diverted (old â†’ new). Benefits: 1) Low risk (rollback possible). 2) Incremental (team learns). 3) Zero downtime. Timeline: 3-12 months typically.",
            "useCases": [
                "Migration"
            ],
            "realTimeUseCases": [
                "Monolith to microservices"
            ]
        },
        {
            "id": 83,
            "name": "What is the Sidecar Pattern?",
            "question": "What is the Sidecar Pattern?",
            "answer": "Pattern: auxiliary service deployed alongside main service. Purpose: cross-cutting concerns (logging, monitoring, auth). Benefits: 1) Decouples logic. 2) Language-agnostic. 3) Easy to update. Implementation: service mesh (Istio, Linkerd). Example: logging sidecar captures all requests.",
            "useCases": [
                "Cross-cutting concerns"
            ],
            "realTimeUseCases": [
                "Service mesh"
            ]
        },
        {
            "id": 84,
            "name": "What is the Database-per-Service Pattern?",
            "question": "What is the Database-per-Service Pattern?",
            "answer": "Pattern: each service owns its database. Benefits: 1) Technology freedom. 2) Independent scaling. 3) Loose coupling (schema changes isolated). Challenge: distributed transactions. Solution: Saga, eventual consistency. Example: User Service (PostgreSQL), Order Service (MongoDB).",
            "useCases": [
                "Data architecture"
            ],
            "realTimeUseCases": [
                "Microservices design"
            ]
        },
        {
            "id": 85,
            "name": "What is the Retry Pattern?",
            "question": "What is the Retry Pattern?",
            "answer": "Pattern: automatically retry failed requests. Strategy: immediate, fixed backoff, exponential backoff. Max retries: typically 3. Idempotent operations only. Benefits: handles transient failures. Implementation: libraries like axios-retry.",
            "useCases": [
                "Resilience"
            ],
            "realTimeUseCases": [
                "Transient failures"
            ]
        },
        {
            "id": 86,
            "name": "What is the Fallback Pattern?",
            "question": "What is the Fallback Pattern?",
            "answer": "Pattern: provide degraded response if service fails. Example: product cache serves stale data vs error. Benefits: better user experience, graceful degradation. Implementation: catch exception, return cached or default.",
            "useCases": [
                "Resilience"
            ],
            "realTimeUseCases": [
                "User experience"
            ]
        },
        {
            "id": 87,
            "name": "What is the Bulkhead Pattern?",
            "question": "What is the Bulkhead Pattern?",
            "answer": "Pattern: isolate resources per operation. Example: 10 threads, 5 for external calls, 5 for internal. Benefits: one operation failure doesn't exhaust all resources. Prevents cascading failures. Implementation: thread pool separation.",
            "useCases": [
                "Resource isolation"
            ],
            "realTimeUseCases": [
                "Resilience"
            ]
        },
        {
            "id": 88,
            "name": "What is the Timeout Pattern?",
            "question": "What is the Timeout Pattern?",
            "answer": "Pattern: set maximum wait time for response. Benefits: fail fast, prevent hanging. Example: 5s timeout for API call. Too short: false failures. Too long: poor UX. Combine with retries.",
            "useCases": [
                "Failure prevention"
            ],
            "realTimeUseCases": [
                "Performance"
            ]
        },
        {
            "id": 89,
            "name": "What is the Cache-Aside Pattern?",
            "question": "What is the Cache-Aside Pattern?",
            "answer": "Pattern: on data fetch, check cache first. If miss: fetch from DB, cache result (with TTL). Benefits: reduces DB load, improves latency. Invalidation: delete cache on update. Trade-off: stale data possible.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "Scalability"
            ]
        },
        {
            "id": 90,
            "name": "What is the Rate Limiting Pattern?",
            "question": "What is the Rate Limiting Pattern?",
            "answer": "Pattern: limit requests per user/IP per time window. Example: 100 req/min per user. Benefits: prevent abuse, ensure fair access, protect from DDoS. Implementation: express-rate-limit, Nginx. Storage: memory (single instance), Redis (distributed).",
            "useCases": [
                "Protection"
            ],
            "realTimeUseCases": [
                "Abuse prevention"
            ]
        },
        {
            "id": 91,
            "name": "What is the Load Balancing Pattern?",
            "question": "What is the Load Balancing Pattern?",
            "answer": "Pattern: distribute traffic across multiple instances. Algorithms: round-robin, least connections, IP hash. Benefits: prevent overload, high availability, horizontal scaling. Placement: at gateway, within service cluster.",
            "useCases": [
                "Availability"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 92,
            "name": "What is the Service Discovery Pattern?",
            "question": "What is the Service Discovery Pattern?",
            "answer": "Pattern: dynamically find service instances. Registry stores locations; clients query to find. Benefits: handles instance scaling, IP changes. Tools: Consul, Eureka, Kubernetes DNS. Two types: client-side (client queries), server-side (load balancer queries).",
            "useCases": [
                "Dynamic routing"
            ],
            "realTimeUseCases": [
                "Scaling"
            ]
        },
        {
            "id": 93,
            "name": "What is the Configuration Server Pattern?",
            "question": "What is the Configuration Server Pattern?",
            "answer": "Pattern: centralized config management. Services fetch config at runtime. Benefits: change without redeployment, environment-specific, secure secrets. Tools: ConfigServer, Consul, Kubernetes ConfigMap. Example: db_url, log_level centralized.",
            "useCases": [
                "Configuration"
            ],
            "realTimeUseCases": [
                "Operations"
            ]
        },
        {
            "id": 94,
            "name": "What is the Health Check Pattern?",
            "question": "What is the Health Check Pattern?",
            "answer": "Pattern: expose endpoint indicating service health. Endpoint: /health returns UP/DOWN/DEGRADED. Load balancer/registry uses to determine if service available. Benefits: automatic removal of unhealthy, auto-recovery. Example: DB down â†’ health DOWN â†’ removed from service registry.",
            "useCases": [
                "Availability"
            ],
            "realTimeUseCases": [
                "Monitoring"
            ]
        },
        {
            "id": 95,
            "name": "What is the Tracing Pattern in microservices?",
            "question": "What is the Tracing Pattern in microservices?",
            "answer": "Pattern: track request across services via trace ID. Injected at entry, passed through all services. Benefits: identify bottlenecks, slow services, complete request path. Tools: Jaeger, Zipkin. Example: order checkout trace shows Payment Service = bottleneck.",
            "useCases": [
                "Debugging"
            ],
            "realTimeUseCases": [
                "Performance analysis"
            ]
        },
        {
            "id": 96,
            "name": "What is the Logging Pattern in microservices?",
            "question": "What is the Logging Pattern in microservices?",
            "answer": "Pattern: centralized logging with correlation IDs. All services log to central system (ELK). Correlation ID: unique per request, enables searching all logs for single request. Benefits: complete picture of request flow.",
            "useCases": [
                "Observability"
            ],
            "realTimeUseCases": [
                "Troubleshooting"
            ]
        },
        {
            "id": 97,
            "name": "What is the Metrics Pattern?",
            "question": "What is the Metrics Pattern?",
            "answer": "Pattern: collect metrics from services (latency, throughput, errors). Tools: Prometheus, Grafana. Benefits: identify trends, set alerts, capacity planning. Metrics: response time, request count, error rate, resource usage. Visualization: dashboards.",
            "useCases": [
                "Monitoring"
            ],
            "realTimeUseCases": [
                "Operations"
            ]
        },
        {
            "id": 98,
            "name": "What is the Alerting Pattern?",
            "question": "What is the Alerting Pattern?",
            "answer": "Pattern: notify on metric threshold breach. Example: alert if error rate > 5%, memory > 80%. Channels: email, Slack, PagerDuty. Benefits: immediate notification, faster response. Setup: define thresholds in monitoring system.",
            "useCases": [
                "Incident response"
            ],
            "realTimeUseCases": [
                "Ops"
            ]
        },
        {
            "id": 99,
            "name": "What is the API Versioning Pattern?",
            "question": "What is the API Versioning Pattern?",
            "answer": "Pattern: support multiple API versions simultaneously. Strategies: URL versioning (/v1, /v2), header versioning (API-Version header). Benefits: backward compatibility, gradual migration. Deprecate old versions after notice. Example: /api/v1/products and /api/v2/products coexist.",
            "useCases": [
                "API evolution"
            ],
            "realTimeUseCases": [
                "Updates"
            ]
        },
        {
            "id": 100,
            "name": "What is the Feature Toggle Pattern?",
            "question": "What is the Feature Toggle Pattern?",
            "answer": "Pattern: enable/disable features at runtime without redeployment. Stored in config server or feature flag service. Benefits: canary deployment, A/B testing, quick rollback. Example: new checkout flow toggled for 10% users, then 50%, then 100%.",
            "useCases": [
                "Deployment"
            ],
            "realTimeUseCases": [
                "Risk mitigation"
            ]
        },
        {
            "id": 101,
            "name": "What is the Blue-Green Deployment Pattern?",
            "question": "What is the Blue-Green Deployment Pattern?",
            "answer": "Pattern: run two production environments (Blue=old, Green=new). Deploy to Green, test, then switch traffic. Benefits: zero downtime, quick rollback (switch back to Blue). Trade-off: 2x infrastructure. Best for: critical systems.",
            "useCases": [
                "Deployment"
            ],
            "realTimeUseCases": [
                "Zero downtime"
            ]
        }
    ],
    "JWT": [
        {
            "id": 1,
            "name": "What is JWT and why is it used in modern web applications?",
            "question": "What is JWT and why is it used in modern web applications?",
            "answer": "JWT (JSON Web Token) is a compact, self-contained token format for securely transmitting claims between parties. It's stateless, scalable, and works across domains/microservices. Used for: authentication (user identity), authorization (permissions), secure inter-service communication. Benefits: no server-side session storage, reduced database queries, CORS-friendly, mobile-app compatible.",
            "useCases": [
                "Stateless auth",
                "Microservices"
            ],
            "realTimeUseCases": [
                "REST APIs",
                "Single Sign-On"
            ]
        },
        {
            "id": 2,
            "name": "What are the three parts of a JWT token?",
            "question": "What are the three parts of a JWT token?",
            "answer": "JWT has 3 parts separated by dots (header.payload.signature): 1) Header: token type (JWT), algorithm (HS256, RS256). 2) Payload: claims (user ID, role, permissions, exp, iat). 3) Signature: HMAC/RSA signature of header + payload using secret/key. Example: eyJhbGc...eyJzdWI...SflKxw...",
            "useCases": [
                "Token structure"
            ],
            "realTimeUseCases": [
                "Debugging tokens"
            ]
        },
        {
            "id": 3,
            "name": "What is the purpose of the JWT signature?",
            "question": "What is the purpose of the JWT signature?",
            "answer": "Signature verifies that the token hasn't been tampered with and confirms the issuer's identity. Created by hashing header + payload with a secret (HMAC) or private key (RSA). Receiver verifies signature using the same secret/public key. If signature mismatches, token is rejected.",
            "useCases": [
                "Token validation",
                "Integrity check"
            ],
            "realTimeUseCases": [
                "Backend verification"
            ]
        },
        {
            "id": 4,
            "name": "What is the difference between access token and refresh token?",
            "question": "What is the difference between access token and refresh token?",
            "answer": "Access token: short-lived (1h), grants access to protected resources. Refresh token: long-lived (7-30d), used to obtain new access tokens without re-login. Flow: user logs in â†’ get both tokens. On access token expiry â†’ send refresh token to server â†’ get new access token. Refresh token never leaves secure storage (httpOnly cookie).",
            "useCases": [
                "Token management",
                "Security"
            ],
            "realTimeUseCases": [
                "Session extension"
            ]
        },
        {
            "id": 5,
            "name": "How does a JWT authentication flow work end-to-end?",
            "question": "How does a JWT authentication flow work end-to-end?",
            "answer": "1) User submits credentials (email, password) to login endpoint. 2) Server validates against DB, creates JWT (HS256/RS256) with payload {userId, role, exp}. 3) Server returns access token + refresh token to client. 4) Client stores tokens securely (httpOnly cookie, sessionStorage). 5) Client sends Authorization: Bearer <token> in requests. 6) Middleware/guard verifies signature and expiry. 7) On expiry, client refreshes token; new token issued. 8) On logout, tokens invalidated (remove from DB/blacklist).",
            "useCases": [
                "Auth flow"
            ],
            "realTimeUseCases": [
                "Complete auth cycle"
            ]
        },
        {
            "id": 6,
            "name": "Is JWT encrypted or encoded?",
            "question": "Is JWT encrypted or encoded?",
            "answer": "JWT is encoded, NOT encrypted. Header + payload are Base64URL encoded (reversible, not secret). Signature proves authenticity but doesn't hide data. If you need secrecy, use JWE (JSON Web Encryption) instead. Conclusion: NEVER store secrets (passwords, API keys) in JWT payload; it's readable by anyone with the token.",
            "useCases": [
                "Security understanding"
            ],
            "realTimeUseCases": [
                "Payload design"
            ]
        },
        {
            "id": 7,
            "name": "How do you invalidate a JWT?",
            "question": "How do you invalidate a JWT?",
            "answer": "JWTs are stateless; can't revoke directly. Options: 1) Blacklist in Redis/DB: store token on logout, check on validation (slower). 2) Short expiry: 1h access token + refresh token approach (recommended). 3) Versioning: increment user's token version; old tokens become invalid. 4) Distributed tracing: revoke all tokens for user on password change. Best practice: short expiry + refresh token rotation.",
            "useCases": [
                "Logout security"
            ],
            "realTimeUseCases": [
                "Immediate logout"
            ]
        },
        {
            "id": 8,
            "name": "What is JWT token rotation and why is it important?",
            "question": "What is JWT token rotation and why is it important?",
            "answer": "Token rotation: issue new tokens periodically without user action. On each refresh, rotate both access + refresh tokens. Old tokens become unusable. Benefits: limits damage if token is stolen (max lifespan known). Prevents token reuse in attacks. Implements: track token version/jti, invalidate old versions. Most secure for high-risk apps (banking, healthcare).",
            "useCases": [
                "Security hardening"
            ],
            "realTimeUseCases": [
                "Enterprise systems"
            ]
        },
        {
            "id": 9,
            "name": "What are common JWT vulnerabilities?",
            "question": "What are common JWT vulnerabilities?",
            "answer": "1) None algorithm: attacker sets algorithm to 'none', signature skipped. Fix: whitelist algorithms (HS256 only). 2) Key confusion: mix of HMAC (symmetric) + RSA (asymmetric) keys. Fix: enforce one algorithm. 3) Weak secrets: use strong random secrets (32+ bytes). 4) Long expiry: access tokens without refresh risk. 5) Storing secrets in payload: use separate secure channels. 6) XSS/token theft: store in httpOnly cookies. 7) Replay: add nonce/jti fields.",
            "useCases": [
                "Security awareness"
            ],
            "realTimeUseCases": [
                "Threat mitigation"
            ]
        },
        {
            "id": 10,
            "name": "What is the difference between JWT, OAuth2, and Session-based authentication?",
            "question": "What is the difference between JWT, OAuth2, and Session-based authentication?",
            "answer": "Session-based: server stores session data, client gets session ID in cookie. Stateful, limited scalability, revocation instant. JWT: stateless, client stores token, no server-side storage. Scalable, harder to revoke. OAuth2: authorization framework (not auth), delegates to identity provider (Google, Facebook). Tokens flow: user â†’ provider â†’ app. Use: JWT for internal APIs, OAuth2 for third-party integrations, sessions for simple apps.",
            "useCases": [
                "Auth comparison"
            ],
            "realTimeUseCases": [
                "Architecture design"
            ]
        },
        {
            "id": 11,
            "name": "How do you store JWT securely in a React application?",
            "question": "How do you store JWT securely in a React application?",
            "answer": "Best: httpOnly cookie (XSS-proof, auto-sent in requests, CORS-safe). Server sets: Set-Cookie: token=...; HttpOnly; Secure; SameSite=Strict. Alternative: sessionStorage (cleared on tab close, XSS vulnerable). Worst: localStorage (persists, XSS vulnerable). Never: JS memory (lost on refresh). Rule: store access token securely, never expose secrets in JWT.",
            "useCases": [
                "Frontend security"
            ],
            "realTimeUseCases": [
                "React apps"
            ]
        },
        {
            "id": 12,
            "name": "What is the difference between storing JWT in localStorage vs HttpOnly cookie?",
            "question": "What is the difference between storing JWT in localStorage vs HttpOnly cookie?",
            "answer": "localStorage: manually managed, persists, vulnerable to XSS (JS can read), manually added to headers. HttpOnly cookie: auto-managed by browser, XSS-proof (JS can't access), auto-sent in requests, CORS-compatible (with credentials flag). Security: HttpOnly >> localStorage. Trade-off: localStorage works on all domains; HttpOnly requires CORS setup. Recommendation: HttpOnly for security.",
            "useCases": [
                "Token storage"
            ],
            "realTimeUseCases": [
                "Browser security"
            ]
        },
        {
            "id": 13,
            "name": "How do you attach JWT automatically to every Axios request in React?",
            "question": "How do you attach JWT automatically to every Axios request in React?",
            "answer": "Request interceptor: axios.interceptors.request.use((config) => { config.headers.Authorization = 'Bearer ' + token; return config; }). HttpOnly cookie: auto-sent if { withCredentials: true } set. Centralize in axiosInstance: export const api = axios.create(); api.interceptors.request.use(...). All requests now include token. Response interceptor handles 401 errors.",
            "useCases": [
                "Automatic auth"
            ],
            "realTimeUseCases": [
                "API communication"
            ]
        },
        {
            "id": 14,
            "name": "How do you handle token expiry in React?",
            "question": "How do you handle token expiry in React?",
            "answer": "Detect via 401 response: response interceptor checks status === 401. Call refresh endpoint with refresh token. If success: get new access token, retry original request. If fail: redirect to login. Use axios-retry for auto-retry. Store expiry in JWT (exp claim), decode jwt_decode to know when to refresh before expiry (proactive refresh).",
            "useCases": [
                "Token management"
            ],
            "realTimeUseCases": [
                "Seamless UX"
            ]
        },
        {
            "id": 15,
            "name": "How do you implement silent refresh using Axios interceptors?",
            "question": "How do you implement silent refresh using Axios interceptors?",
            "answer": "Response interceptor: if status 401, call POST /refresh with refresh token. Get new access token from response. Retry original request with new token using originalRequest with flag to prevent loops. Store attempt count to avoid infinite loops. Benefits: user never sees login page if refresh succeeds. Seamless experience even on token expiry.",
            "useCases": [
                "Seamless auth"
            ],
            "realTimeUseCases": [
                "User experience"
            ]
        },
        {
            "id": 16,
            "name": "How do you protect React routes using JWT-based Auth Guards?",
            "question": "How do you protect React routes using JWT-based Auth Guards?",
            "answer": "Create PrivateRoute component: check if token exists and valid (decode, check exp). If valid: render component. If invalid: redirect to /login. Use: <PrivateRoute component={AdminPanel} />. Can also check roles: if (token.role !== 'admin') redirect to /unauthorized. Use react-router-dom + jwtDecode.",
            "useCases": [
                "Route protection"
            ],
            "realTimeUseCases": [
                "Admin panels"
            ]
        },
        {
            "id": 17,
            "name": "How do you manage role-based UI rendering in React using JWT claims?",
            "question": "How do you manage role-based UI rendering in React using JWT claims?",
            "answer": "Decode JWT: const user = jwtDecode(token). Extract role: user.role. Conditional rendering: {user.role === 'admin' && <AdminButton />}. Create role-based components: const AdminSection = () => useAuth().role === 'admin' ? <Component /> : null. Store decoded token in context/Redux for app-wide access.",
            "useCases": [
                "RBAC UI"
            ],
            "realTimeUseCases": [
                "Permission-based features"
            ]
        },
        {
            "id": 18,
            "name": "How do you prevent XSS attacks affecting JWT on the frontend?",
            "question": "How do you prevent XSS attacks affecting JWT on the frontend?",
            "answer": "1) Store in httpOnly cookie (JS can't access). 2) Content Security Policy (CSP) headers prevent inline scripts. 3) Sanitize user inputs: DOMPurify library. 4) Use framework protections (React escapes by default). 5) Avoid innerHTML, use textContent. 6) Use helmet.js on backend for security headers. 7) HTTPS only. 8) Validate & escape all external data.",
            "useCases": [
                "Security hardening"
            ],
            "realTimeUseCases": [
                "Production apps"
            ]
        },
        {
            "id": 19,
            "name": "How do you handle 401 errors and force logout in React?",
            "question": "How do you handle 401 errors and force logout in React?",
            "answer": "Response interceptor: if 401, clear token, clear user context, redirect to /login. Show message: 'Session expired, please login again'. Prevent redirect loop by checking if already on /login. Clear localStorage/sessionStorage. Call API: POST /logout to blacklist token on server. Use context/Redux to manage auth state globally.",
            "useCases": [
                "Logout flow"
            ],
            "realTimeUseCases": [
                "Session handling"
            ]
        },
        {
            "id": 20,
            "name": "How do you manage JWT for multi-tab login across browser windows?",
            "question": "How do you manage JWT for multi-tab login across browser windows?",
            "answer": "HttpOnly cookie: shared across all tabs, all tabs auto-authenticated. localStorage: manual sync via 'storage' event listener. window.addEventListener('storage', () => { refresh local state }). Challenge: refresh token expiry; if one tab logs out, others still hold old token. Solution: check token validity on each request; server rejects expired tokens. Shared logout: clear cookie server-side.",
            "useCases": [
                "Multi-tab sync"
            ],
            "realTimeUseCases": [
                "Enterprise apps"
            ]
        },
        {
            "id": 21,
            "name": "How do you implement JWT authentication in Express middleware?",
            "question": "How do you implement JWT authentication in Express middleware?",
            "answer": "Create middleware: const auth = (req, res, next) => { const token = req.header('Authorization')?.split(' ')[1]; if (!token) return res.status(401).json({error: 'No token'}); try { const decoded = jwt.verify(token, SECRET); req.user = decoded; next(); } catch { res.status(401).json({error: 'Invalid token'}); }}. Use on routes: router.get('/profile', auth, handler).",
            "useCases": [
                "Route protection"
            ],
            "realTimeUseCases": [
                "API endpoints"
            ]
        },
        {
            "id": 22,
            "name": "How do you secure RESTful APIs in Express using JWT?",
            "question": "How do you secure RESTful APIs in Express using JWT?",
            "answer": "1) All POST/PUT/DELETE require JWT auth middleware. 2) Public endpoints (GET /products) optional. 3) Validate signature server-side: jwt.verify(). 4) Check token expiry automatically. 5) Use HTTPS only. 6) Add rate limiting on auth endpoints. 7) Log suspicious activity. 8) Return 401 for auth errors, 403 for authorization errors. 9) No sensitive data in JWT payload.",
            "useCases": [
                "API security"
            ],
            "realTimeUseCases": [
                "Production APIs"
            ]
        },
        {
            "id": 23,
            "name": "How does Express validate JWT signatures?",
            "question": "How does Express validate JWT signatures?",
            "answer": "jwt.verify(token, secret): splits token into parts. Recreates signature using original header + payload + secret. Compares with token's signature. If match: signature valid, payload readable. If mismatch: token tampered. If expired: checks 'exp' claim. Throws error if invalid; middleware catches, returns 401. Use: try { jwt.verify() } catch { handle error }.",
            "useCases": [
                "Signature validation"
            ],
            "realTimeUseCases": [
                "Security checks"
            ]
        },
        {
            "id": 24,
            "name": "How do you design reusable authentication & authorization middlewares in Express?",
            "question": "How do you design reusable authentication & authorization middlewares in Express?",
            "answer": "Auth middleware: verifies JWT, extracts user. Authorization middleware (RBAC): checks user.role. Stack: router.post('/admin', auth, authorize(['admin']), handler). Create: const authorize = (roles) => (req, res, next) => { if(!roles.includes(req.user.role)) res.status(403).json({error: 'Forbidden'}); else next(); }. Reusable across routes.",
            "useCases": [
                "Middleware design"
            ],
            "realTimeUseCases": [
                "Scalable APIs"
            ]
        },
        {
            "id": 25,
            "name": "How do you implement RBAC (Role-Based Access Control) using JWT in Express?",
            "question": "How do you implement RBAC (Role-Based Access Control) using JWT in Express?",
            "answer": "Encode role in JWT: jwt.sign({userId, role: 'admin'}, SECRET). Middleware checks: const authorize = (roles) => (req, res, next) => { if (!roles.includes(req.user.role)) return res.status(403).json({error: 'Forbidden'}); next(); }. Use: router.delete('/users/:id', auth, authorize(['admin']), deleteUser). DB validates role on sensitive operations.",
            "useCases": [
                "RBAC implementation"
            ],
            "realTimeUseCases": [
                "Admin/user separation"
            ]
        },
        {
            "id": 26,
            "name": "How do you generate JWT tokens securely in Node.js?",
            "question": "How do you generate JWT tokens securely in Node.js?",
            "answer": "npm install jsonwebtoken. Generate: jwt.sign(payload, secret, {algorithm: 'HS256', expiresIn: '1h'}). Secret: use environment variable, strong random string (32+ bytes). Payload: {userId, role, email}. Never include passwords. Set expiry to limit token lifespan. Alternative: RS256 (asymmetric) using private key from .pem file.",
            "useCases": [
                "Token generation"
            ],
            "realTimeUseCases": [
                "Login endpoint"
            ]
        },
        {
            "id": 27,
            "name": "How do you use Refresh Token flows with Express.js?",
            "question": "How do you use Refresh Token flows with Express.js?",
            "answer": "Login returns: {accessToken: shortLived, refreshToken: longLived}. Store refreshToken in db with userId. POST /refresh: verify refreshToken, issue new accessToken (optionally rotate refreshToken). Use: client sends refreshToken â†’ server validates â†’ returns new accessToken. Logout: delete refreshToken from db. Security: refreshToken in httpOnly cookie, never in URL.",
            "useCases": [
                "Token refresh"
            ],
            "realTimeUseCases": [
                "Session extension"
            ]
        },
        {
            "id": 28,
            "name": "How do you implement JWT revocation in Express?",
            "question": "How do you implement JWT revocation in Express?",
            "answer": "Blacklist approach: store token on logout in Redis/DB with TTL matching exp. On auth: check if token in blacklist. If yes, reject (401). DB approach: store jti (JWT ID) in user table. On logout: update user's tokenVersion. On auth: compare decoded jti with user's current jti. Efficient: Redis blacklist for logout, version for password changes.",
            "useCases": [
                "Logout security"
            ],
            "realTimeUseCases": [
                "Immediate logout"
            ]
        },
        {
            "id": 29,
            "name": "How do you secure backend APIs from CSRF when using JWT?",
            "question": "How do you secure backend APIs from CSRF when using JWT?",
            "answer": "JWT mitigates CSRF: tokens must be explicitly added to header (attacker can't inject). Browser can't auto-include Authorization header due to CORS. CSRF tokens: still use CSRF tokens on forms. Double-submit: store token in cookie + form; server compares. SameSite cookie: SameSite=Strict prevents cross-site cookie send. Conclusion: JWT via headers is CSRF-safe; forms need CSRF tokens.",
            "useCases": [
                "CSRF prevention"
            ],
            "realTimeUseCases": [
                "Form security"
            ]
        },
        {
            "id": 30,
            "name": "How do you protect internal microservice APIs using JWT?",
            "question": "How do you protect internal microservice APIs using JWT?",
            "answer": "Service-to-service: each service has JWT credentials (service account). Service A calls Service B with JWT. Both verify using shared secret or public key. Asymmetric (RS256): Auth Service signs with private key; other services verify with public key. Internal communication: use shorter expiry (5min) than user tokens. Rate limiting between services. Logging for audit trail.",
            "useCases": [
                "Microservice auth"
            ],
            "realTimeUseCases": [
                "Internal APIs"
            ]
        },
        {
            "id": 31,
            "name": "How do you pass JWT tokens in REST API requests?",
            "question": "How do you pass JWT tokens in REST API requests?",
            "answer": "Standard: Authorization header: 'Authorization: Bearer <token>'. Alternatives: custom header, query param (not recommended). Cookie: auto-sent if set as HttpOnly. Best practice: Bearer in header for flexibility, cookie for browser apps. Server extracts: req.header('Authorization').split(' ')[1] or req.cookies.token. Always use HTTPS.",
            "useCases": [
                "Token transmission"
            ],
            "realTimeUseCases": [
                "API calls"
            ]
        },
        {
            "id": 32,
            "name": "How does JWT support stateless REST APIs?",
            "question": "How does JWT support stateless REST APIs?",
            "answer": "Stateless: no server-side session storage. Token contains all info (userId, role, permissions). Server only verifies signature + expiry. No DB query needed per request (except optional DB checks). Scales horizontally: any server can verify any token. Reduced latency, improved throughput. Trade-off: can't instantly revoke (blacklist needed). Ideal for microservices, mobile APIs.",
            "useCases": [
                "Scalability"
            ],
            "realTimeUseCases": [
                "High-traffic APIs"
            ]
        },
        {
            "id": 33,
            "name": "How do you design scalable authentication architecture for REST services?",
            "question": "How do you design scalable authentication architecture for REST services?",
            "answer": "Architecture: Auth Service (issues tokens) â†’ API Gateway (validates) â†’ Microservices (verify token). Caching: store public keys in cache for RS256 validation. Distributed: use Redis for token blacklist/refresh validation. Load balancing: no session affinity needed (stateless). CDN: serve public keys globally. Logging: centralized logging for audit. Metrics: monitor token validation latency.",
            "useCases": [
                "Scalable design"
            ],
            "realTimeUseCases": [
                "Enterprise systems"
            ]
        },
        {
            "id": 34,
            "name": "When should REST APIs return 401 vs 403?",
            "question": "When should REST APIs return 401 vs 403?",
            "answer": "401 Unauthorized: no valid token provided, token expired, invalid signature. User is not authenticated. Response: ask user to login. 403 Forbidden: token valid but user lacks permission. User is authenticated but unauthorized for this resource. Example: user tries /admin â†’ 403. Best practice: 401 triggers re-auth, 403 shows 'Access Denied'.",
            "useCases": [
                "HTTP status codes"
            ],
            "realTimeUseCases": [
                "Error handling"
            ]
        },
        {
            "id": 35,
            "name": "What best practices must be followed when designing JWT-protected REST APIs?",
            "question": "What best practices must be followed when designing JWT-protected REST APIs?",
            "answer": "1) Short-lived access tokens (1h) + refresh tokens (7d). 2) Strong secret (32+ bytes), rotated regularly. 3) Always HTTPS. 4) Whitelist algorithms (HS256 only). 5) No sensitive data in payload. 6) Validate expiry + signature. 7) CORS properly configured. 8) Rate limiting on auth endpoints. 9) Logging and monitoring. 10) Refresh token rotation. 11) Clear error messages (don't leak info). 12) Document token format for clients.",
            "useCases": [
                "Best practices"
            ],
            "realTimeUseCases": [
                "Production APIs"
            ]
        },
        {
            "id": 36,
            "name": "How do JWT tokens enable stateless authentication in microservices?",
            "question": "How do JWT tokens enable stateless authentication in microservices?",
            "answer": "Each service receives JWT; independently verifies (no inter-service calls). Token contains user info, role, permissions. Service trusts JWT if signature valid. Enables: Service A â†’ Service B without B querying DB. Request tracing: include trace ID in JWT. Service routing: based on role in JWT. Scale: no shared session storage needed.",
            "useCases": [
                "Microservice auth"
            ],
            "realTimeUseCases": [
                "Distributed systems"
            ]
        },
        {
            "id": 37,
            "name": "How does API Gateway validate JWT before routing requests?",
            "question": "How does API Gateway validate JWT before routing requests?",
            "answer": "API Gateway intercepts all requests. Extracts Authorization header. Validates JWT: signature, expiry, format. If valid: adds user info to request, forwards to service. If invalid: returns 401. Benefits: services don't validate (offload), consistent validation, central logging. Caches public keys for RS256 validation. Rate limiting per user (from JWT).",
            "useCases": [
                "Gateway pattern"
            ],
            "realTimeUseCases": [
                "API aggregation"
            ]
        },
        {
            "id": 38,
            "name": "How do you share JWT secrets across multiple services securely?",
            "question": "How do you share JWT secrets across multiple services securely?",
            "answer": "Symmetric (HMAC): same secret on all services (risk if compromised). Store in env vars, secrets manager (Vault, AWS Secrets Manager). Asymmetric (RSA): private key only on Auth Service, public key distributed to all services. Public key fetched via JWKS endpoint. Rotate: update all services. Best: asymmetric for microservices.",
            "useCases": [
                "Secret management"
            ],
            "realTimeUseCases": [
                "Security"
            ]
        },
        {
            "id": 39,
            "name": "How does service-to-service authentication work using JWT?",
            "question": "How does service-to-service authentication work using JWT?",
            "answer": "Service A needs to call Service B. A generates JWT with 'service' scope (not user). B verifies JWT signature. A: jwt.sign({service: 'order-service', exp: now+5min}, privateKey). B: jwt.verify(token, publicKey). Trust: if signature valid, caller is trusted service. Optional: track service-to-service calls in audit log.",
            "useCases": [
                "Inter-service auth"
            ],
            "realTimeUseCases": [
                "Microservice calls"
            ]
        },
        {
            "id": 40,
            "name": "How do you generate short-lived tokens for internal microservice communication?",
            "question": "How do you generate short-lived tokens for internal microservice communication?",
            "answer": "expiresIn: '5m' for internal tokens (vs 1h for user tokens). Justification: internal network is more secure; compromised token has limited window. Service A calls Service B: fetch fresh token before each call, or cache with near-expiry refresh. Benefits: minimizes damage if token leaked. Downside: more token generation overhead.",
            "useCases": [
                "Internal security"
            ],
            "realTimeUseCases": [
                "Microservices"
            ]
        },
        {
            "id": 41,
            "name": "How do you refresh JWT tokens in a microservices ecosystem?",
            "question": "How do you refresh JWT tokens in a microservices ecosystem?",
            "answer": "Centralized Refresh Service: all services route refresh requests here. Refresh Service validates refreshToken, issues new accessToken. Can rotate refreshToken too. Redis caching: store refreshToken with version. On password change: increment version, all old tokens invalidated. Response: new accessToken, optionally new refreshToken.",
            "useCases": [
                "Token refresh"
            ],
            "realTimeUseCases": [
                "Central auth"
            ]
        },
        {
            "id": 42,
            "name": "How does RBAC work in a distributed microservices environment?",
            "question": "How does RBAC work in a distributed microservices environment?",
            "answer": "Roles in JWT: {userId, role: 'admin', permissions: ['read', 'write']}. Each service: checks role/permissions on resources. DB validation: service queries DB for user's latest permissions (cache for speed). Role changes: update DB; next JWT refresh includes new role. Eventual consistency: slight delay possible but acceptable.",
            "useCases": [
                "Distributed RBAC"
            ],
            "realTimeUseCases": [
                "Permission management"
            ]
        },
        {
            "id": 43,
            "name": "How do you prevent token replay attacks in distributed systems?",
            "question": "How do you prevent token replay attacks in distributed systems?",
            "answer": "Nonce: include one-time use nonce in JWT (server tracks used nonces, Redis). JTI (JWT ID): unique ID per token, server stores issued JTIs. Timestamp: check request timestamp vs token iat/exp. IP/device binding: validate from expected IP/device. Rate limiting: block multiple requests from same token in short time. HTTPS: prevents token interception.",
            "useCases": [
                "Attack prevention"
            ],
            "realTimeUseCases": [
                "Security"
            ]
        },
        {
            "id": 44,
            "name": "How do you use asymmetric keys (RS256) for JWT signing in microservices?",
            "question": "How do you use asymmetric keys (RS256) for JWT signing in microservices?",
            "answer": "Generate keys: openssl genrsa -out private.pem 2048; openssl rsa -in private.pem -pubout > public.pem. Auth Service signs with private key: jwt.sign(payload, privateKey, {algorithm: 'RS256'}). Other services verify with public key: jwt.verify(token, publicKey). Benefits: public key distribution safe, private key never shared. JWKS endpoint: serve public key for clients to fetch.",
            "useCases": [
                "Asymmetric signing"
            ],
            "realTimeUseCases": [
                "Multi-service"
            ]
        },
        {
            "id": 45,
            "name": "How does multi-tenant JWT authentication work in microservices?",
            "question": "How does multi-tenant JWT authentication work in microservices?",
            "answer": "JWT includes tenantId: {userId, tenantId: 'org-123', role}. Services validate: user's tenantId matches request tenantId. DB queries filtered by tenantId. Isolation: each tenant's data completely separate. Row-level security: DB enforces tenantId filtering. Advantages: single codebase, multiple customers, isolated security models.",
            "useCases": [
                "Multi-tenancy"
            ],
            "realTimeUseCases": [
                "SaaS platforms"
            ]
        },
        {
            "id": 46,
            "name": "How do you implement JWT authentication in Spring Boot?",
            "question": "How do you implement JWT authentication in Spring Boot?",
            "answer": "Dependency: spring-boot-starter-security, jjwt. Create JWT provider: @Component class JwtProvider { public String generateToken(String username) { return Jwts.builder().setSubject(username).setIssuedAt(new Date()).setExpiration(expireDate).signWith(SignatureAlgorithm.HS512, jwtSecret).compact(); } }. Use in @RestController for login endpoint.",
            "useCases": [
                "Spring Boot auth"
            ],
            "realTimeUseCases": [
                "Java APIs"
            ]
        },
        {
            "id": 47,
            "name": "How does Spring Security validate JWT tokens?",
            "question": "How does Spring Security validate JWT tokens?",
            "answer": "Custom filter extends OncePerRequestFilter: extract token from Authorization header, validate with JwtProvider, set SecurityContext. Spring Security checks SecurityContext, authorizes based on roles. Validation: signature check, expiry check. Unauthorized: throw AuthenticationException caught by ExceptionHandler, returns 401.",
            "useCases": [
                "Filter chain"
            ],
            "realTimeUseCases": [
                "Request flow"
            ]
        },
        {
            "id": 48,
            "name": "What is the difference between OncePerRequestFilter and AuthenticationEntryPoint in JWT flow?",
            "question": "What is the difference between OncePerRequestFilter and AuthenticationEntryPoint in JWT flow?",
            "answer": "OncePerRequestFilter: processes each request once, validates token, sets authentication. AuthenticationEntryPoint: handles auth failures (no token, invalid token). OncePerRequestFilter is part of filter chain; AuthenticationEntryPoint is called when authentication fails. OncePerRequestFilter: extract + validate. AuthenticationEntryPoint: handle 401 response format.",
            "useCases": [
                "Spring Security components"
            ],
            "realTimeUseCases": [
                "Architecture"
            ]
        },
        {
            "id": 49,
            "name": "How do you configure JWT authentication in Spring Security filter chain?",
            "question": "How do you configure JWT authentication in Spring Security filter chain?",
            "answer": "WebSecurityConfig extends WebSecurityConfigurerAdapter. Configure: http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class). Define public endpoints: /api/auth/login, /api/auth/refresh. Private endpoints: require authentication. Create AuthenticationEntryPoint for 401 handling. ExceptionHandler for errors.",
            "useCases": [
                "Spring config"
            ],
            "realTimeUseCases": [
                "Security setup"
            ]
        },
        {
            "id": 50,
            "name": "How do you generate JWT using Java KeyStore (JKS)?",
            "question": "How do you generate JWT using Java KeyStore (JKS)?",
            "answer": "Create keystore: keytool -genkey -keyalg RSA -alias jwt-key -keystore jwt-keystore.jks. Load in Spring: KeyStore keyStore = KeyStore.getInstance('JKS'); keyStore.load(inputStream, password); PrivateKey = keyStore.getKey('jwt-key', password). Use for RS256 signing: Jwts.builder()...signWith(SignatureAlgorithm.RS256, privateKey).",
            "useCases": [
                "Key management"
            ],
            "realTimeUseCases": [
                "Enterprise security"
            ]
        },
        {
            "id": 51,
            "name": "How do you implement refresh token logic in Spring Boot?",
            "question": "How do you implement refresh token logic in Spring Boot?",
            "answer": "Controller: @PostMapping('/refresh') { String refreshToken = request.getHeader('Authorization').split(' ')[1]; if (jwtProvider.validateRefreshToken(refreshToken)) { String username = jwtProvider.getUsernameFromToken(refreshToken); String newAccessToken = jwtProvider.generateToken(username); return new ResponseEntity<>(newAccessToken, OK); } return new ResponseEntity<>(UNAUTHORIZED); }",
            "useCases": [
                "Refresh flow"
            ],
            "realTimeUseCases": [
                "Token extension"
            ]
        },
        {
            "id": 52,
            "name": "How do you attach roles and permissions to JWT claims in Spring Boot?",
            "question": "How do you attach roles and permissions to JWT claims in Spring Boot?",
            "answer": "After authentication, extract roles: Collection<GrantedAuthority> authorities = user.getAuthorities(). Add to JWT: Jwts.builder().claim('roles', authorities).build(). Decode in filter: List<String> roles = (List) claims.get('roles'). Grant authorities: new UsernamePasswordAuthenticationToken(user, null, roles).",
            "useCases": [
                "RBAC in JWT"
            ],
            "realTimeUseCases": [
                "Role management"
            ]
        },
        {
            "id": 53,
            "name": "How do you secure REST controllers in Spring using JWT and PreAuthorize?",
            "question": "How do you secure REST controllers in Spring using JWT and PreAuthorize?",
            "answer": "Enable: @EnableGlobalMethodSecurity(prePostEnabled = true). Controller: @GetMapping('/admin') @PreAuthorize('hasRole(ADMIN)') public String admin() { return 'Admin content'; }. Spring checks if current user has ADMIN role from JWT claims. Return 403 if unauthorized. Clean, declarative authorization.",
            "useCases": [
                "Method-level security"
            ],
            "realTimeUseCases": [
                "Controller protection"
            ]
        },
        {
            "id": 54,
            "name": "How do you blacklist JWT tokens in Spring Boot?",
            "question": "How do you blacklist JWT tokens in Spring Boot?",
            "answer": "Cache: inject RedisTemplate. On logout: POST /logout â†’ jwtProvider.getTokenId(token) â†’ redisTemplate.opsForValue().set(jti, 'blacklisted', expiryTime). In filter: on every request, check if jti in Redis. If blacklisted, reject. TTL auto-deletes after expiry.",
            "useCases": [
                "Logout security"
            ],
            "realTimeUseCases": [
                "Token revocation"
            ]
        },
        {
            "id": 55,
            "name": "How do you handle JWT expiration in enterprise Spring Boot APIs?",
            "question": "How do you handle JWT expiration in enterprise Spring Boot APIs?",
            "answer": "Filter: catch ExpiredJwtException, call AuthenticationEntryPoint. ExceptionHandler: @ExceptionHandler(ExpiredJwtException) returns custom error. Client: receives error, calls refresh endpoint. Server: validates refreshToken, issues new accessToken, client retries. Proactive: client decodes token, refreshes before expiry using exp claim.",
            "useCases": [
                "Expiry handling"
            ],
            "realTimeUseCases": [
                "Enterprise apps"
            ]
        },
        {
            "id": 56,
            "name": "How do you store user credentials securely in SQL databases?",
            "question": "How do you store user credentials securely in SQL databases?",
            "answer": "Never store plaintext passwords. Hash with bcrypt: $2b$12$... Use: bcrypt.hashPassword(password, 12). Store hash + salt. On login: bcrypt.verifyPassword(inputPassword, storedHash). DB schema: CREATE TABLE users (id, email, password_hash, salt). No recovery: hashes irreversible. Audit log: track login attempts.",
            "useCases": [
                "Password security"
            ],
            "realTimeUseCases": [
                "User management"
            ]
        },
        {
            "id": 57,
            "name": "How do you design SQL tables for RBAC (Users, Roles, Permissions)?",
            "question": "How do you design SQL tables for RBAC (Users, Roles, Permissions)?",
            "answer": "Tables: users (id, email, password_hash), roles (id, name), permissions (id, name), user_roles (user_id FK, role_id FK), role_permissions (role_id FK, permission_id FK). Query user permissions: SELECT p.* FROM permissions p JOIN role_permissions rp ON p.id = rp.permission_id JOIN user_roles ur ON rp.role_id = ur.role_id WHERE ur.user_id = ?. Flexible: easily add/remove roles.",
            "useCases": [
                "Schema design"
            ],
            "realTimeUseCases": [
                "RBAC system"
            ]
        },
        {
            "id": 58,
            "name": "How do SQL triggers or stored procedures help in authentication?",
            "question": "How do SQL triggers or stored procedures help in authentication?",
            "answer": "Stored procedure: CREATE PROCEDURE ValidateUser(email, password) â†’ query user, verify hash, return user_id + role. Triggers: on password_change â†’ log audit, invalidate old tokens, force re-login. Benefits: centralized logic, reduced code duplication, audit trail, enforced security rules at DB level.",
            "useCases": [
                "DB-level security"
            ],
            "realTimeUseCases": [
                "Audit compliance"
            ]
        },
        {
            "id": 59,
            "name": "How do you validate refresh tokens stored in SQL tables?",
            "question": "How do you validate refresh tokens stored in SQL tables?",
            "answer": "Table: refresh_tokens (id, user_id FK, token_hash, exp, revoked). On refresh: SELECT user_id FROM refresh_tokens WHERE token_hash = SHA256(token) AND exp > NOW() AND revoked = false. If found: issue new accessToken. Benefits: can revoke tokens (set revoked=1), track token usage, enforce single token per user (delete old before issuing new).",
            "useCases": [
                "Token validation"
            ],
            "realTimeUseCases": [
                "Logout safety"
            ]
        },
        {
            "id": 60,
            "name": "How do you manage JWT blacklisting using SQL tables?",
            "question": "How do you manage JWT blacklisting using SQL tables?",
            "answer": "Table: blacklisted_tokens (id, jti, user_id FK, exp, created_at). On logout: INSERT INTO blacklisted_tokens (jti, user_id, exp) VALUES (...). On auth: SELECT FROM blacklisted_tokens WHERE jti = ? AND exp > NOW(). If found: reject token. Cleanup: DELETE FROM blacklisted_tokens WHERE exp < NOW() (auto-cleanup job). Alternative: use Redis for speed.",
            "useCases": [
                "Token revocation"
            ],
            "realTimeUseCases": [
                "Logout"
            ]
        },
        {
            "id": 61,
            "name": "How do you scale SQL authentication under high traffic?",
            "question": "How do you scale SQL authentication under high traffic?",
            "answer": "Indexing: INDEX on email, user_id. Connection pooling: 20-50 concurrent connections. Caching: cache user roles in Redis (invalidate on change). Read replicas: auth queries on replica, write on primary. Async logging: log audits asynchronously. Rate limiting: limit login attempts per IP. Denormalize: cache user + roles in JWT, reduce DB queries.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "High traffic"
            ]
        },
        {
            "id": 62,
            "name": "What SQL indexes improve authentication performance?",
            "question": "What SQL indexes improve authentication performance?",
            "answer": "Indexes: users (email), refresh_tokens (token_hash, user_id), blacklisted_tokens (jti, exp), user_roles (user_id), role_permissions (role_id). Composite: (user_id, revoked) for filtering. Monitor: EXPLAIN ANALYZE on auth queries. Optimal: auth query < 1ms with indexes. Avoid: full table scans.",
            "useCases": [
                "Query optimization"
            ],
            "realTimeUseCases": [
                "Latency reduction"
            ]
        },
        {
            "id": 63,
            "name": "How do you prevent SQL injection attacks in JWT login flow?",
            "question": "How do you prevent SQL injection attacks in JWT login flow?",
            "answer": "Use parameterized queries: Prepared statements (user inputs as placeholders). Example: Prepare: SELECT * FROM users WHERE email = ?; Execute(email). ORM (Sequelize, TypeORM, SQLAlchemy): abstraction prevents injection. Validation: sanitize email input (regex), hash password. Never concatenate SQL strings with user input.",
            "useCases": [
                "Security"
            ],
            "realTimeUseCases": [
                "Login endpoint"
            ]
        },
        {
            "id": 64,
            "name": "How do you implement JWT authentication using Django REST Framework (DRF)?",
            "question": "How do you implement JWT authentication using Django REST Framework (DRF)?",
            "answer": "Package: djangorestframework-simplejwt. Settings: REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ('rest_framework_simplejwt.authentication.JWTAuthentication',) }. View: @api_view(['POST']) def login(request) â†’ ObtainTokenView. Returns access + refresh tokens. Use @permission_classes([IsAuthenticated]) on protected views.",
            "useCases": [
                "Django auth"
            ],
            "realTimeUseCases": [
                "REST APIs"
            ]
        },
        {
            "id": 65,
            "name": "What are DRF SimpleJWT access & refresh token flows?",
            "question": "What are DRF SimpleJWT access & refresh token flows?",
            "answer": "Login (POST /api/token/): returns {access, refresh}. Refresh (POST /api/token/refresh/): send {refresh} â†’ returns new {access}. Access token: 5min. Refresh token: 24h. Blacklist: enable BLACKLIST to revoke on logout. Customize: AUTH_USER_MODEL, TOKEN_TYPE_CLAIM.",
            "useCases": [
                "Token flow"
            ],
            "realTimeUseCases": [
                "DRF setup"
            ]
        },
        {
            "id": 66,
            "name": "How do you customize JWT payload in Django?",
            "question": "How do you customize JWT payload in Django?",
            "answer": "Create serializer: class MyTokenObtainPairSerializer(TokenObtainPairSerializer): @classmethod def get_token(cls, user): token = super().get_token(user); token['role'] = user.role; return token. Register in settings: SIMPLE_JWT = { 'TOKEN_OBTAIN_SERIALIZER': 'path.MyTokenObtainPairSerializer' }. Custom payload on every token.",
            "useCases": [
                "JWT customization"
            ],
            "realTimeUseCases": [
                "Role inclusion"
            ]
        },
        {
            "id": 67,
            "name": "How do you validate JWT tokens in Django middleware?",
            "question": "How do you validate JWT tokens in Django middleware?",
            "answer": "Middleware: class JWTAuthMiddleware(BaseMiddleware): extract token from Authorization header, call JWTAuthentication.authenticate_header(). Set request.user if valid. Benefits: validate at middleware level, log auth events. Alternative: use DRF's IsAuthenticated permission on views.",
            "useCases": [
                "Middleware validation"
            ],
            "realTimeUseCases": [
                "Request processing"
            ]
        },
        {
            "id": 68,
            "name": "How do you handle role-based permissions using Django + JWT?",
            "question": "How do you handle role-based permissions using Django + JWT?",
            "answer": "Encode role in JWT payload. Create permission class: class IsAdmin(BasePermission): def has_permission(self, request, view) { return request.user.role == 'admin' }. Use: @permission_classes([IsAdmin]) on views. DRF checks before handler execution. Combine multiple: @permission_classes([IsAuthenticated, IsAdmin]).",
            "useCases": [
                "RBAC in Django"
            ],
            "realTimeUseCases": [
                "Authorization"
            ]
        },
        {
            "id": 69,
            "name": "How do you invalidate refresh tokens in Django?",
            "question": "How do you invalidate refresh tokens in Django?",
            "answer": "Enable blacklist: SIMPLE_JWT = { 'BLACKLIST_AFTER_ROTATION': True }. Model: BlacklistedToken. On logout: manually add to blacklist. Middleware checks blacklist before accepting token. TTL: tokens auto-cleanup. Alternative: version-based (increment token_version on logout).",
            "useCases": [
                "Token revocation"
            ],
            "realTimeUseCases": [
                "Logout"
            ]
        },
        {
            "id": 70,
            "name": "How do you protect Django REST APIs using JWT + CORS + CSRF rules?",
            "question": "How do you protect Django REST APIs using JWT + CORS + CSRF rules?",
            "answer": "Settings: CORS_ALLOWED_ORIGINS = ['https://frontend.com']. CSRF: use CSRF middleware for forms; JWT via header is CSRF-safe. JWTs: store in httpOnly cookie or explicit header. Combine: JWT for APIs, CSRF tokens for forms. HTTPS only. SameSite=Strict cookie.",
            "useCases": [
                "API security"
            ],
            "realTimeUseCases": [
                "CORS+CSRF"
            ]
        },
        {
            "id": 71,
            "name": "How do you design a multi-database JWT flow for NMG eCommerce?",
            "question": "How do you design a multi-database JWT flow for NMG eCommerce?",
            "answer": "SQL DB (MySQL/Oracle): users, roles, permissions. MongoDB (catalog): products, reviews. Auth: SQL stores credentials, issues JWT. JWT includes userId + role. Order Service: SQL stores orders + transactions. Cache: Redis caches user roles, product details. On user update: invalidate JWT, force re-login.",
            "useCases": [
                "Multi-DB architecture"
            ],
            "realTimeUseCases": [
                "eCommerce"
            ]
        },
        {
            "id": 72,
            "name": "How do you implement JWT token rotation policy for sensitive eCommerce transactions?",
            "question": "How do you implement JWT token rotation policy for sensitive eCommerce transactions?",
            "answer": "Sensitive ops (payment): require fresh token (< 5min old). Rotate token on every transaction. Issue new token after payment completion. Track token age: include iat in payload. Before payment: check age; if > 5min, refresh. Response: include new token for next request. Benefits: limits damage if payment token stolen.",
            "useCases": [
                "Payment security"
            ],
            "realTimeUseCases": [
                "eCommerce transactions"
            ]
        },
        {
            "id": 73,
            "name": "How do you manage JWT across Customer Portal and Admin Portal in NMG?",
            "question": "How do you manage JWT across Customer Portal and Admin Portal in NMG?",
            "answer": "Single Auth Service issues both. Role determines portal access. Customer: role='customer' â†’ access /portal/products, /portal/orders. Admin: role='admin' â†’ access /admin/users, /admin/analytics. JWT trusted by both; includes role. Logout: clear token in both. Cross-portal: if role changes, force re-login.",
            "useCases": [
                "Multi-portal"
            ],
            "realTimeUseCases": [
                "NMG eCommerce"
            ]
        },
        {
            "id": 74,
            "name": "How do you secure JWT during multi-device login for NMG customers?",
            "question": "How do you secure JWT during multi-device login for NMG customers?",
            "answer": "Device ID in JWT: include deviceId in payload. On login: issue new token per device, store mapping (userId, deviceId, token). Support multi-device: allow N concurrent tokens. Logout from one device: invalidate that deviceId's token. Session table: track active devices. Security: revoke all on password change.",
            "useCases": [
                "Multi-device"
            ],
            "realTimeUseCases": [
                "Mobile + web"
            ]
        },
        {
            "id": 75,
            "name": "How do you implement JWT caching for inventory and order APIs?",
            "question": "How do you implement JWT caching for inventory and order APIs?",
            "answer": "Cache decoded JWT: Redis key = userId:tenantId, value = {role, permissions, exp}. TTL matches token expiry. On auth: check cache first, skip verification. If hit: retrieve permissions immediately (< 1ms). Benefits: reduces crypto operations, faster auth checks on high-volume inventory queries.",
            "useCases": [
                "Performance"
            ],
            "realTimeUseCases": [
                "High traffic"
            ]
        },
        {
            "id": 76,
            "name": "How do you handle JWT in real-time checkout and payment confirmation?",
            "question": "How do you handle JWT in real-time checkout and payment confirmation?",
            "answer": "Checkout: verify JWT (user authenticated). Generate order_id. Call Payment Service with JWT. Payment Service: verifies JWT, processes payment. Response: updated JWT with order_id claim. Confirmation: client receives new JWT with transaction details. Idempotency: use order_id as nonce to prevent duplicate orders.",
            "useCases": [
                "Checkout security"
            ],
            "realTimeUseCases": [
                "Payment flow"
            ]
        },
        {
            "id": 77,
            "name": "How do you prevent JWT token theft in NMG mobile app?",
            "question": "How do you prevent JWT token theft in NMG mobile app?",
            "answer": "Storage: httpOnly cookie + secure flag. Transmission: HTTPS only. Device binding: include device ID, hardware ID in JWT. Pin validation: require biometric on first use per device. Token expiry: 1h access + refresh. Refresh on app launch. On compromise: biometric fails â†’ logout, clear all tokens.",
            "useCases": [
                "Mobile security"
            ],
            "realTimeUseCases": [
                "App protection"
            ]
        },
        {
            "id": 78,
            "name": "How do you implement JWT for guest checkout without login in NMG?",
            "question": "How do you implement JWT for guest checkout without login in NMG?",
            "answer": "Guest flow: no credentials â†’ temporary JWT issued. Payload: {guestId, role: 'guest', exp: +30min}. Guest can add to cart, proceed to checkout. Before payment: prompt login (optional). If login: convert guest order to user order, link orders. Benefits: reduces friction; guest can become customer. Cleanup: delete guest data after 24h if no login.",
            "useCases": [
                "Guest checkout"
            ],
            "realTimeUseCases": [
                "Conversion optimization"
            ]
        },
        {
            "id": 79,
            "name": "How do you handle JWT expiry during long checkout process in NMG?",
            "question": "How do you handle JWT expiry during long checkout process in NMG?",
            "answer": "Monitor token expiry: decode exp claim, warn before expiry. Auto-refresh: if nearing expiry (< 5min), call refresh endpoint. Pause checkout: if token expired, show 'Session expired' modal, redirect to login. Resume: after login, return to cart (preserve state). Best practice: extend token on activity (e.g., adding item), reduce friction.",
            "useCases": [
                "UX improvement"
            ],
            "realTimeUseCases": [
                "Checkout flow"
            ]
        },
        {
            "id": 80,
            "name": "How do you audit JWT-based actions for compliance in NMG?",
            "question": "How do you audit JWT-based actions for compliance in NMG?",
            "answer": "Audit table: log (userId, action, timestamp, ip, user_agent, token_jti). Extract from JWT. Centralized logging: all services log to single source (ELK, Splunk). Compliance: trace who did what, when. Payment logs: separate, immutable. Retention: 7 years for payments. GDPR: anonymize old logs on user deletion.",
            "useCases": [
                "Compliance"
            ],
            "realTimeUseCases": [
                "Audit trail"
            ]
        },
        {
            "id": 81,
            "name": "How do you design JWT for high-frequency API calls in real-time inventory?",
            "question": "How do you design JWT for high-frequency API calls in real-time inventory?",
            "answer": "Lightweight JWT: minimal claims (userId, tenantId, role). Signed once, verified many times. Caching: decode + verify once per request-batch. Batch requests: combine multiple inventory checks in one call. Rate limiting: enforce at gateway (1000 req/min per user). Async background: inventory sync happens off-request.",
            "useCases": [
                "Performance at scale"
            ],
            "realTimeUseCases": [
                "Real-time inventory"
            ]
        },
        {
            "id": 82,
            "name": "How do you handle JWT in Kafka-based event processing for orders?",
            "question": "How do you handle JWT in Kafka-based event processing for orders?",
            "answer": "Event payload: include JWT (or userId + role) in Kafka message. Consumer validates JWT (or trusts userId if from known producer). Tracing: include trace_id + request_id from JWT. Security: Kafka topics access-controlled per service. Audit: log which service produced event (verified from JWT).",
            "useCases": [
                "Event-driven auth"
            ],
            "realTimeUseCases": [
                "Order processing"
            ]
        },
        {
            "id": 83,
            "name": "How do you implement JWT for inter-microservice API calls in NMG?",
            "question": "How do you implement JWT for inter-microservice API calls in NMG?",
            "answer": "Service-to-service tokens: separate from user tokens. Service A has credentials (id, secret). On startup: obtain JWT from Auth Service. Request Service B with JWT. B verifies: if signature valid, trust caller. Rotation: refresh every hour. Logging: trace service calls for audit. Security: internal network only.",
            "useCases": [
                "Microservice communication"
            ],
            "realTimeUseCases": [
                "Service calls"
            ]
        },
        {
            "id": 84,
            "name": "How do you manage JWT state for real-time order tracking in NMG?",
            "question": "How do you manage JWT state for real-time order tracking in NMG?",
            "answer": "JWT includes orderId claim. WebSocket connection: authenticate with JWT. Subscribe to order updates (e.g., /orders/123). Server validates JWT, verifies user owns order. Push updates via WebSocket (order status changes). Reconnect: re-authenticate with JWT. Logout: close WebSocket, clear subscriptions.",
            "useCases": [
                "Real-time updates"
            ],
            "realTimeUseCases": [
                "Order status"
            ]
        },
        {
            "id": 85,
            "name": "How do you design JWT for seasonal high-traffic periods (Black Friday) in NMG?",
            "question": "How do you design JWT for seasonal high-traffic periods (Black Friday) in NMG?",
            "answer": "Pre-planning: increase secret key rotation frequency. Shorter token lifespan (30min). More refresh tokens issued. Rate limiting stricter: 500 req/min. Load balancing: distribute auth across multiple Auth Services. Caching: aggressive JWT payload caching (Redis). Async auth: defer non-critical auth checks. Monitoring: track token generation rate, auth latency.",
            "useCases": [
                "Traffic spikes"
            ],
            "realTimeUseCases": [
                "Black Friday"
            ]
        },
        {
            "id": 86,
            "name": "How do you handle JWT expiry notification to users in real-time?",
            "question": "How do you handle JWT expiry notification to users in real-time?",
            "answer": "Frontend: decode JWT, calculate expiry. 5min before: show 'Session expiring in 5 min'. Click 'Continue': call refresh endpoint, get new token. Timeout: auto-logout, redirect to login. WebSocket: server pushes expiry warning to client. Benefits: prevents losing work, improves UX.",
            "useCases": [
                "User notification"
            ],
            "realTimeUseCases": [
                "Session management"
            ]
        },
        {
            "id": 87,
            "name": "How do you implement JWT with geolocation verification for fraud prevention?",
            "question": "How do you implement JWT with geolocation verification for fraud prevention?",
            "answer": "On login: capture IP geolocation. Add geo claim to JWT. On each request: compare current IP with JWT geo. If different country: trigger 2FA. Stored tokens (geo data): prevent token reuse across geo. Benefits: detects account takeover. Trade-off: frequent travelers may be inconvenienced.",
            "useCases": [
                "Fraud prevention"
            ],
            "realTimeUseCases": [
                "Security"
            ]
        },
        {
            "id": 88,
            "name": "How do you design JWT for API version compatibility in NMG?",
            "question": "How do you design JWT for API version compatibility in NMG?",
            "answer": "JWT payload: include api_version claim. Legacy API (v1): expects specific claims. New API (v2): additional claims. Backward compatibility: both versions accept old tokens. Graceful deprecation: warn clients (headers), set sunset date. Migration: guide clients to new version.",
            "useCases": [
                "Version management"
            ],
            "realTimeUseCases": [
                "API evolution"
            ]
        },
        {
            "id": 89,
            "name": "How do you handle JWT for third-party integrations in NMG?",
            "question": "How do you handle JWT for third-party integrations in NMG?",
            "answer": "External API key: issue long-lived JWT to partners. Scoped: limited claims (specific endpoints, resources). Rotate annually. Revocation: revoke if abuse detected. Logging: all partner API calls logged. Rate limiting: per-partner quotas. HTTPS + IP whitelisting. Agreement: terms of use, data handling.",
            "useCases": [
                "Partner integrations"
            ],
            "realTimeUseCases": [
                "Third-party APIs"
            ]
        },
        {
            "id": 90,
            "name": "How do you secure JWT for analytics and reporting APIs?",
            "question": "How do you secure JWT for analytics and reporting APIs?",
            "answer": "Analytics token: issued for data analysts (special role). Read-only scope: can't modify data. Time-limited: 24h validity. IP whitelisting: access from office only. Logging: all queries logged, audit-ready. Data masking: PII fields encrypted. Rate limiting: 100 req/min. Compliance: GDPR-compliant data access.",
            "useCases": [
                "Analytics security"
            ],
            "realTimeUseCases": [
                "Data access control"
            ]
        }
    ],
    "Axios": [
        {
            "id": 1,
            "name": "Express JS",
            "question": "What is JavaScript?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Java": [
        {
            "id": 1,
            "name": "Java",
            "question": "What is Java?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "Spring Framework": [
        {
            "id": 1,
            "name": "Spring Core - IoC & DI",
            "question": "What is IoC (Inversion of Control)? What is Dependency Injection? What are the types of Dependency Injection? How does Spring implement IoC? What is the difference between IoC and DI? What is Constructor Injection? What is Setter Injection? Which DI approach does Spring recommend and why?",
            "answer": "IoC (Inversion of Control) is a design principle where the framework controls creation and wiring of objects instead of application code. Dependency Injection (DI) is a concrete implementation of IoC where dependencies are supplied to objects rather than created by them. Types: Constructor Injection (dependencies provided via constructor), Setter Injection (via setter methods), Field Injection (directly into fields). Spring implements IoC with an IoC container (BeanFactory / ApplicationContext) that instantiates, wires, and manages bean lifecycles based on configuration (XML, Java @Configuration, or annotations). IoC is the high-level principle; DI is the technique used to achieve it. Constructor Injection is preferred for mandatory, immutable dependencies because it makes requirements explicit and improves testability; Setter Injection is useful for optional or reconfigurable dependencies. Spring recommends Constructor Injection for required dependencies and setter/field injection for optional wiring or framework-provided conveniences.",
            "useCases": [
                "Enforcing required dependencies via constructors",
                "Providing optional collaborators via setters",
                "Swapping implementations for testing and configuration"
            ],
            "realTimeUseCases": [
                "OrderService(OrderRepository repo) constructor ensures repository is always provided",
                "Optional ReportService injected via setter to avoid startup cost",
                "Mock repositories injected in unit tests to isolate service logic"
            ]
        },
        {
            "id": 2,
            "name": "Spring Core - Containers, Autowiring & Scopes",
            "question": "What is the BeanFactory? What is the ApplicationContext? Difference between BeanFactory and ApplicationContext? What is Inversion of Control Container? How Spring manages object lifecycles? What is auto-wiring in Spring? Types of auto-wiring in Spring? What happens internally during dependency injection? How does Spring resolve dependencies internally? What are the problems solved by IoC? How do you inject collections in Spring? What is circular dependency in Spring? How to handle circular dependencies in Spring?",
            "answer": "BeanFactory is the basic IoC container providing lazy bean instantiation and simple DI. ApplicationContext builds on BeanFactory and adds enterprise features: internationalization, event propagation, application lifecycle management, automatic BeanPostProcessor/BeanFactoryPostProcessor handling, and eager instantiation of singletons by default. The IoC container manages bean creation, wiring dependencies, invoking lifecycle callbacks, and destruction. Spring manages lifecycles via bean metadata and callbacks: instantiation -> populate properties -> Aware callbacks -> BeanPostProcessor.beforeInitialization -> @PostConstruct/init-method -> BeanPostProcessor.afterInitialization -> ready -> @PreDestroy/destroy-method on shutdown for singletons. Autowiring automatically injects bean dependencies by type (and optionally by name/qualifier). Modes: byName, byType, constructor, and annotation-driven (@Autowired). Internally, Spring builds a dependency graph, chooses constructors or setters, resolves candidate beans by type/name, applies @Primary/@Qualifier rules, handles proxies for AOP, and performs injection by invoking constructors or setting fields via reflection. IoC decouples object creation from use, enabling easier testing, configuration, and pluggable implementations. Inject collections by declaring List/Set/Map of the bean type (Spring will autowire matching beans), or configure collection elements in XML/Java config. Circular dependency occurs when A depends on B and B depends on A; Spring can resolve circular references for singletons using early references and proxies, but cannot resolve constructor-based cycles. Handle cycles by refactoring to remove the cycle, switching one side to setter injection, using @Lazy, or employing Provider/FactoryBean approaches.",
            "useCases": [
                "Autowire services and repositories to reduce boilerplate",
                "Inject List<Plugin> to register multiple strategy implementations",
                "Use scopes to manage lifecycles (singleton/prototype)"
            ],
            "realTimeUseCases": [
                "Autowire all PaymentProcessors: Map<String, PaymentProcessor> to pick processor by name",
                "Inject List<PromotionRule> into PricingService to apply rules sequentially",
                "Use @Lazy for heavy ReportService to defer startup cost"
            ]
        },
        {
            "id": 3,
            "name": "Spring Annotations & Configuration",
            "question": "What is @Autowired? What is @Qualifier? Difference between @Autowired and @Inject? Can we perform DI without annotations in Spring? What is @Bean annotation? What is @Configuration annotation? What is XML-based DI? What is Java-based DI? What is annotation-based DI? What is @Component? What are @Controller, @Service, @Repository? How component scanning works in Spring? What is @Primary annotation? What is @Lazy annotation? What is @Scope annotation? Bean Scopes in Spring? What is prototype vs singleton scope? Life cycle methods in Spring Bean?",
            "answer": "`@Autowired` injects dependencies by type (and optionally by name) into constructors, fields, or setters. `@Qualifier` narrows the candidate bean when multiple beans of the same type exist. `@Inject` is the JSR-330 equivalent of `@Autowired`; both work similarly but `@Autowired` offers Spring-specific features like `required=false`. DI without annotations is possible via XML configuration or Java `@Configuration` classes with `@Bean` methods. `@Bean` marks a method producing a bean; `@Configuration` marks a class as a source of bean definitions enabling CGLIB proxies for proper singleton behavior. XML-based DI uses <bean> definitions, Java-based DI uses `@Configuration`/`@Bean`, and annotation-based DI uses component stereotypes with component scanning. `@Component` is the generic stereotype; `@Service` denotes service layer semantics, `@Repository` marks data-access components (adds persistence exception translation), and `@Controller` denotes MVC controllers. Component scanning inspects packages and registers classes annotated with stereotype annotations as beans. `@Primary` designates the preferred bean when multiple candidates exist. `@Lazy` defers bean creation until first requested. `@Scope` declares bean scope: `singleton` (one per container), `prototype` (new instance per request), and web-specific scopes like `request` and `session`. Prototype beans are created for each request and are not fully lifecycle-managed by the container (destroy callbacks arenâ€™t called automatically); singletons are created once and fully managed including init/destroy. Lifecycle hooks include Aware interfaces, `@PostConstruct`/`@PreDestroy`, init-method/destroy-method, and BeanPostProcessor callbacks.",
            "useCases": [
                "Use @Service/@Repository to clearly mark layers",
                "Use @Qualifier or @Primary to resolve multiple bean candidates",
                "Prefer @Configuration/@Bean when custom construction logic is needed"
            ],
            "realTimeUseCases": [
                "@Autowired constructor injection in OrderService to ensure required dependencies",
                "@Repository classes for JPA with exception translation",
                "@Primary PaymentProcessor for default payment flow and @Qualifier for specialized processors",
                "@Lazy heavy services like analytics to reduce startup time"
            ]
        },
        {
            "id": 4,
            "name": "Spring MVC - Dispatcher & Request Flow",
            "question": "What is Spring MVC? What is DispatcherServlet? Explain Spring MVC request flow? What is the role of DispatcherServlet? What is @Controller annotation? What is @RestController? Difference between @Controller and @RestController? What is @RequestMapping? Difference between @GetMapping, @PostMapping, @PutMapping, @DeleteMapping?",
            "answer": "Spring MVC is a request-driven web framework following the Model-View-Controller pattern. `DispatcherServlet` is the front controller that receives HTTP requests, consults HandlerMapping to find the appropriate controller, delegates to a HandlerAdapter to execute the controller, receives a ModelAndView or body, and resolves and renders a view. Request flow: client -> DispatcherServlet -> HandlerMapping -> Controller (via HandlerAdapter) -> ModelAndView or response -> ViewResolver -> View -> response. `@Controller` denotes a component returning views; `@RestController` is shorthand for `@Controller` + `@ResponseBody` so methods return serialized responses (JSON/XML). `@RequestMapping` maps URLs and HTTP methods; `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` are specialized shortcuts for common HTTP verbs.",
            "useCases": [
                "Build web pages with @Controller and views",
                "Expose REST APIs with @RestController",
                "Use DispatcherServlet as central request dispatcher and extension point"
            ],
            "realTimeUseCases": [
                "Checkout API: @PostMapping('/checkout') for order submission",
                "Product detail page: @Controller returning ModelAndView for server-side rendering",
                "Admin endpoint: @GetMapping('/admin/orders') secured by interceptor"
            ]
        },
        {
            "id": 5,
            "name": "Spring MVC - Views, Interceptors & Data Binding",
            "question": "What is ModelAndView? What is ViewResolver? What is InternalResourceViewResolver? What are Interceptors in Spring MVC? What is HandlerMapping? What is HandlerAdapter? What is HandlerInterceptor? What is form binding in Spring MVC? What is data validation in Spring MVC? What is @Valid? How exception handling works in Spring MVC? What is @ControllerAdvice? What is @ExceptionHandler? What are filters in Spring? Difference between Filters and Interceptors? How to upload files in Spring MVC? How to return JSON response in Spring MVC? How does REST work in Spring MVC? What is Content Negotiation in Spring? What is HttpMessageConverter? What is @ResponseBody? What is @RequestBody? Difference between @ResponseBody and @RestController? What is CORS and how to enable it? How Spring MVC integrates with Spring Boot? What is HiddenHttpMethodFilter?",
            "answer": "`ModelAndView` holds model attributes and view name for rendering. `ViewResolver` maps logical view names to physical view implementations; `InternalResourceViewResolver` forwards to server-side templates like JSP by applying prefix/suffix. Interceptors (`HandlerInterceptor`) allow preHandle/postHandle/afterCompletion hooks for cross-cutting logic (logging, auth). `HandlerMapping` resolves request to controller; `HandlerAdapter` executes the controller method. Form binding maps request parameters to POJOs, and validation uses JSR-303/JSR-380 with `@Valid` to trigger validation and `BindingResult` to inspect errors. Exception handling can be local with `@ExceptionHandler` or global with `@ControllerAdvice`. Filters are servlet-level (operate before DispatcherServlet) and are suitable for low-level tasks (CORS, security); Interceptors operate within Spring MVC lifecycle and are better for handler-specific concerns. File upload uses `MultipartResolver` and `MultipartFile`. To return JSON, use `@RestController` or `@ResponseBody`; Spring uses `HttpMessageConverter` (e.g., Jackson) to convert objects to/from JSON. `@RequestBody` binds request JSON to method params; `@ResponseBody` serializes return values. Content negotiation picks response format based on client headers or URL. CORS allows cross-origin requests and can be enabled via `@CrossOrigin`, global CORS config, or filters. Spring Boot auto-configures many MVC components like message converters, multipart resolver, exception handlers, and DispatcherServlet. `HiddenHttpMethodFilter` supports PUT/DELETE via a hidden `_method` field in HTML forms.",
            "useCases": [
                "Use @ControllerAdvice for centralized error handling",
                "Use interceptors for request logging and authentication checks",
                "Use HttpMessageConverters to serve JSON and XML APIs"
            ],
            "realTimeUseCases": [
                "Global error mapping to standardized API error responses",
                "File upload endpoint for product images",
                "REST APIs returning JSON for frontend consumption"
            ]
        },
        {
            "id": 6,
            "name": "Spring Beans & Bean Lifecycle",
            "question": "What is a Spring Bean? What is Bean lifecycle in Spring? What is BeanPostProcessor? What is BeanFactoryPostProcessor? What is @PostConstruct? What is @PreDestroy? How to initialize beans in Spring? What is init-method and destroy-method? What is @Bean annotation? What is @Configuration? What is @DependsOn? How Spring creates singleton beans? How Spring manages bean scopes? What is ApplicationContextAware? What is BeanNameAware? What is FactoryBean? What is the purpose of BeanDefinition? What is prototype scope bean lifecycle? How to handle prototype-scoped beans? What is @Lookup annotation? What is Lazy Initialization? What is Eager Initialization?",
            "answer": "A Spring Bean is an object instantiated, assembled, and managed by the Spring container. Lifecycle: definition parsed -> instantiation -> populate properties -> Aware callbacks (BeanNameAware, ApplicationContextAware) -> BeanPostProcessor.beforeInitialization -> @PostConstruct / init-method -> BeanPostProcessor.afterInitialization -> ready for use -> @PreDestroy / destroy-method on shutdown for singletons. `BeanPostProcessor` allows intercepting bean creation to add proxies (used by AOP), and `BeanFactoryPostProcessor` can modify bean definitions before instantiation. `@PostConstruct`/@PreDestroy` are JSR lifecycle callbacks for init and destroy. Initialize via `@PostConstruct`, init-method on XML/@Bean, or implementing InitializingBean; destroy via `@PreDestroy` or DisposableBean/destroy-method. `@Bean` marks a factory method, `@Configuration` groups bean definitions and keeps semantics correct for @Bean methods. `@DependsOn` enforces creation order for beans with explicit dependencies. Singleton beans are created once per container (eager by default) while prototype beans are created per request; Spring fully manages singleton lifecycle including destroy callbacks but does not call destroy on prototype beans by default. `ApplicationContextAware` and `BeanNameAware` allow beans to obtain context or their configured name. `FactoryBean` is a special bean that exposes an object created inside it rather than the FactoryBean itself. `BeanDefinition` stores metadata like bean class, scope, constructor args, properties, init/destroy methods. To handle prototype lifecycles and cleanup, use custom destroy methods or let the client code manage lifecycle; use `@Lookup` to dynamically request new prototype instances from a singleton. `@Lazy` defers instantiation until first used; eager initialization creates singletons at startup which helps detect configuration errors early.",
            "useCases": [
                "Use @PostConstruct to perform initialization tasks",
                "Implement BeanPostProcessor to create AOP proxies",
                "Use FactoryBean for advanced factory patterns",
                "Use @Lookup when a singleton needs fresh prototype instances"
            ],
            "realTimeUseCases": [
                "@PostConstruct in DataLoader to seed demo data after dependencies wired",
                "FactoryBean to wrap complex cache creation",
                "Prototype-scoped form beans for per-request state in web flows",
                "BeanPostProcessor to wrap transaction behavior with proxies"
            ]
        },
        {
            "id": 7,
            "name": "Spring AOP - Aspect-Oriented Programming",
            "question": "What is AOP? What problems does AOP solve? What is Aspect? What is JoinPoint? What is Advice? Types of Advice in Spring AOP? What is Pointcut? What is Target Object? What is Proxy in Spring? Difference between JDK Dynamic Proxy and CGLIB? What is @Aspect annotation? What is @Before, @After, @Around? What is ProceedingJoinPoint? What is weaving in AOP? What is compile-time vs runtime weaving? What is Introduction in AOP? What is AOP Proxy? What are cross-cutting concerns? How to enable AOP in Spring? What are limitations of Spring AOP?",
            "answer": "AOP (Aspect-Oriented Programming) separates cross-cutting concerns (like logging, transactions, security) from business logic by applying behavior (advice) at predefined points (join points) in program execution. An Aspect bundles advice and pointcut definitions that specify where the advice should apply. A JoinPoint is a point in execution (method call, execution) where advice can be applied. Advice is the action taken by an aspect at a join point; common advice types are @Before, @After, @AfterReturning, @AfterThrowing, and @Around. A Pointcut is an expression that selects one or more join points (e.g., execution(* com.example..*(..))). The Target Object is the actual business object being proxied. Spring uses proxies to apply advice: a proxy wraps the target and intercepts calls to apply advice. JDK Dynamic Proxy creates proxies for interfaces; CGLIB creates subclass proxies for classes (used when no interface present). `@Aspect` marks a class as an aspect in Spring AOP. `@Before` runs before the target method; `@After` runs after (finally); `@Around` wraps the method allowing pre/post behavior and control over proceeding by using `ProceedingJoinPoint` which provides access to method args and allows invocation via `proceed()`. Weaving is the process of applying aspects to target code; compile-time weaving (AspectJ) weaves at compile time or class-load time, while Spring AOP typically does proxy-based runtime weaving. Introduction (aka inter-type declaration) allows adding new methods/fields to existing classes (limited in Spring AOP compared to full AspectJ). Cross-cutting concerns are features scattered across many modules (logging, security, transactions) and are ideal for AOP. Enable Spring AOP by adding `@EnableAspectJAutoProxy` in config or `<aop:aspectj-autoproxy/>` in XML and by defining `@Aspect` beans. Limitations: Spring AOP is proxy-based and works by method interception only (no field interception), only public/protected methods via proxy depending on proxy type, and cannot advise calls within the same class (self-invocation) without AspectJ compile-time or load-time weaving.",
            "useCases": [
                "Centralized logging and metrics",
                "Declarative transaction management",
                "Authorization checks via aspects",
                "Retry and circuit breaker patterns implemented as aspects"
            ],
            "realTimeUseCases": [
                "@Around aspect to measure execution time for service methods",
                "@Before aspect to inject user context for audit logging",
                "@Transactional implemented via AOP to wrap repository calls in transactions",
                "Security check aspects to verify roles before executing controller methods"
            ]
        },
        {
            "id": 8,
            "name": "Spring Security - Authentication & Authorization",
            "question": "What is Spring Security? What is Authentication vs Authorization? What is UserDetailsService? What is PasswordEncoder? What is AuthenticationManager? What is SecurityContext? What is SecurityContextHolder? What is DelegatingFilterProxy? What is FilterChainProxy? What is CSRF? How to enable/disable CSRF? What is JWT? How JWT works internally? How to integrate JWT with Spring Security? What are roles and authorities? What is @EnableWebSecurity? Difference between @PreAuthorize and @Secured? What is OAuth2? Difference between JWT vs OAuth2? What is Basic Auth vs Bearer Token? How to configure custom login page in Spring Security? What is CORS and how to configure it? How session management works in Spring Security? What is stateless authentication?",
            "answer": "Spring Security is a framework providing authentication, authorization, and security features for Java applications. Authentication verifies identity (who you are); authorization checks permissions (what you can do). `UserDetailsService` loads user-specific data (username, password, authorities) for authentication. `PasswordEncoder` hashes and verifies passwords securely (e.g., BCryptPasswordEncoder). `AuthenticationManager` coordinates authentication providers to authenticate credentials. `SecurityContext` holds security information (Authentication) for the current execution; `SecurityContextHolder` stores the `SecurityContext` (thread-local or strategy-based). `DelegatingFilterProxy` bridges Servlet filters to Spring-managed beans; `FilterChainProxy` is Spring Security's central filter that delegates to a chain of security filters. CSRF (Cross-Site Request Forgery) is an attack where unauthorized commands are transmitted; Spring Security provides CSRF tokens to protect state-changing endpoints. Enable/disable CSRF via HttpSecurity.csrf().disable() or configure tokens. JWT (JSON Web Token) is a compact token that contains claims and is signed; internally it has header.payload.signature encoded in base64; verification checks signature and claims. Integrate JWT by creating authentication filter to validate token, populate `SecurityContext` with Authentication, and configure stateless session management. Roles are high-level groupings (ROLE_ADMIN) while authorities are fine-grained permissions (e.g., 'ORDER_READ'); Spring treats roles as authorities with ROLE_ prefix. `@EnableWebSecurity` enables Spring Security configuration; `@PreAuthorize` uses SpEL expressions for method-level checks with more expressive power, while `@Secured` checks specific roles (less flexible). OAuth2 is an authorization framework for delegated access (third-party apps access resources via tokens); JWT is a token format that can be used with OAuth2 but is not an authorization framework itself. Basic Auth sends base64-encoded credentials in Authorization header; Bearer Token (JWT) sends token in Authorization header. Configure custom login page by overriding formLogin().loginPage(`/logic`) and providing controller/views. CORS (Cross-Origin Resource Sharing) permits cross-origin requests; configure with CorsRegistry, @CrossOrigin, or via HttpSecurity.cors(). Session management: Spring Security can use HTTP sessions to store authenticated principal; configure session creation policy. Stateless authentication (common with JWT) avoids server-side session state: each request contains full authentication data (token) and server validates token per request, improving scalability but requiring token revocation strategies.",
            "useCases": [
                "Protect REST APIs via JWT and stateless filters",
                "Use method security for service-level authorization",
                "Integrate OAuth2 for third-party login (Google, Facebook)"
            ],
            "realTimeUseCases": [
                "JWT filter validates token and populates SecurityContext for each API call",
                "UserDetailsService backed by database for login flow",
                "BCrypt PasswordEncoder for storing user passwords",
                "@PreAuthorize(\"hasRole('ADMIN')\") on admin service methods",
                "Stateless JWT authentication for mobile and SPA clients to scale horizontally"
            ]
        }
    ],
    "Spring Data JPA / Hibernate": [
        {
            "id": 1,
            "name": "Spring Data JPA / Hibernate",
            "question": "What is JPA? What is Hibernate? Difference between JPA and Hibernate? What is ORM? What is Entity? What is @Entity annotation? What is @Id and @GeneratedValue? What are JPA relationships? (OneToOne, OneToMany, ManyToMany) What is FetchType LAZY vs EAGER? What is @Transactional? What is Persistence Context? What is First-Level Cache? What is Second-Level Cache? What is JPQL? What is Criteria API? What is @Query annotation? How to write native queries? What is N+1 query problem? How to solve N+1 problem? What is CascadeType? What is orphanRemoval? What is optimistic vs pessimistic locking? What is @EntityListeners? What is Dirty Checking?",
            "answer": "JPA (Java Persistence API) is the Java specification for object-relational mapping (ORM) that defines how Java objects are persisted to relational databases. Hibernate is a mature, widely used implementation of JPA that also provides additional features and optimizations. In practice JPA is the API/spec, Hibernate is an implementation with extras. An Entity is a persistent domain object mapped to a database table and is annotated with @Entity. @Id marks the primary key field; @GeneratedValue instructs the provider to generate keys (strategies: IDENTITY, SEQUENCE, TABLE, AUTO). JPA relationships model associations: @OneToOne, @OneToMany, @ManyToOne, @ManyToMany; define ownership via mappedBy and join tables where needed. FetchType.EAGER loads associations immediately while FetchType.LAZY defers loading until accessed â€” prefer LAZY for collections to avoid unnecessary queries. @Transactional demarcates transactional boundaries so the persistence context (EntityManager session) is bound to the method execution and commits/rolls back as a unit. The Persistence Context tracks managed entities and provides the First-Level Cache (per EntityManager/session cache). Second-Level Cache is optional, shared across sessions (providers: EHCache, Hazelcast) to reduce DB hits for read-mostly reference data. JPQL is an entity-centric query language (e.g., SELECT p FROM Product p); Criteria API builds queries programmatically and type-safely. @Query on repository methods allows custom JPQL or native queries (use nativeQuery=true for raw SQL). The N+1 problem happens when lazy-loading a collection causes N additional queries for N child records; solve it using JOIN FETCH, entity graphs, batch fetching, or optimized repository queries. CascadeType controls propagation of persistence operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH); orphanRemoval=true deletes child entities removed from a parent collection. Optimistic locking uses a version column to detect concurrent modifications and fail conflicting transactions, while pessimistic locking acquires DB locks (SELECT ... FOR UPDATE) to prevent concurrent changes. @EntityListeners register lifecycle callbacks (prePersist, postLoad, preUpdate). Dirty checking is Hibernate's mechanism that detects entity state changes at flush time and emits minimal SQL UPDATEs automatically, letting you work with entities without manual SQL in most cases.",
            "useCases": [
                "Map domain objects to tables with @Entity and JPA annotations",
                "Use @Transactional at service layer to ensure atomic operations",
                "Use JPQL or @Query for reporting and complex reads",
                "Apply second-level cache for reference data to reduce DB load"
            ],
            "realTimeUseCases": [
                "Order and OrderItem: @OneToMany mapping with JOIN FETCH in queries to avoid N+1",
                "Product catalog caching: enable second-level cache for categories and attributes",
                "Use optimistic locking (version) to prevent lost updates during concurrent order processing",
                "Write @Query methods for aggregated reports or complex joins"
            ]
        },
        {
            "id": 2,
            "name": "Repositories & Query Methods",
            "question": "What are Spring Data repositories? How do derived query methods work? When to use @Query or custom repository implementations?",
            "answer": "Spring Data repositories (CrudRepository, JpaRepository) provide standard CRUD, paging, and sorting operations. Derived query methods generate queries from method names (e.g., findByStatusAndCreatedAtAfter). Use @Query for complex JPQL or native SQL, and implement custom repository fragments when logic cannot be expressed by method names or annotations (for performance or specialized SQL).",
            "useCases": [
                "Use JpaRepository for CRUD and pagination",
                "Use derived queries for simple filters",
                "Use @Query or custom implementations for complex or optimized queries"
            ],
            "realTimeUseCases": [
                "OrderRepository.findByCustomerIdAndStatus(customerId, 'SHIPPED')",
                "@Query for aggregated sales reports",
                "Custom repository using JdbcTemplate for optimized bulk updates"
            ]
        },
        {
            "id": 3,
            "name": "Pagination, Sorting & Projections",
            "question": "How to implement pagination and sorting? What are DTO projections and interface projections?",
            "answer": "Use Pageable and Page<T> to request pages and Sort for ordering. Projections allow fetching only required properties: DTO projections (constructor expressions) or interface-based projections populated by Spring. Projections reduce payload and improve performance for list endpoints.",
            "useCases": [
                "PageRequest.of(page, size, Sort.by('createdAt').descending())",
                "Use projections for lightweight API responses"
            ],
            "realTimeUseCases": [
                "ProductRepository.findByCategory(category, PageRequest.of(0,20))",
                "Interface projection ProductSummary { String getName(); BigDecimal getPrice(); } for product lists"
            ]
        },
        {
            "id": 4,
            "name": "Batching & Bulk Operations",
            "question": "How to perform efficient batch inserts/updates? What are pitfalls of bulk operations?",
            "answer": "Enable JDBC batching (hibernate.jdbc.batch_size) and use saveAll or JdbcTemplate batching. Bulk JPQL updates run directly in DB and bypass the persistence context, so you must clear or synchronize the EntityManager after. Tune batch size and chunk processing to balance memory and DB load.",
            "useCases": [
                "Enable JDBC batching for large imports",
                "Chunk and flush/clear EntityManager between batches"
            ],
            "realTimeUseCases": [
                "Batch import products using saveAll with chunking",
                "Use native JDBC batch for inventory updates"
            ]
        },
        {
            "id": 5,
            "name": "Auditing, Migrations & Production Tips",
            "question": "How to add auditing (createdBy/createdDate)? How to handle schema migrations? What are best practices for production readiness?",
            "answer": "Enable JPA auditing with @EnableJpaAuditing and use @CreatedDate, @LastModifiedDate, and AuditorAware to capture user context. Use Flyway or Liquibase for versioned DB migrations. For production, enable connection pooling, profile slow queries, use second-level cache for static data, and monitor metrics for query latency and cache hit rates.",
            "useCases": [
                "Enable JPA auditing for traceability",
                "Use Flyway for deterministic schema migrations",
                "Monitor DB performance and adjust fetch strategies"
            ],
            "realTimeUseCases": [
                "@EnableJpaAuditing with AuditorAware implementation",
                "Flyway migrations run in CI/CD for deploys",
                "Tune indexes and queries for reporting endpoints"
            ]
        }
    ],
    "Spring Boot": [
        {
            "id": 1,
            "name": "RESTful WebServices",
            "question": "What is RESTful WebServices?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        },
        {
            "id": 3,
            "name": "What is Spring Boot?",
            "question": "What is Spring Boot?",
            "answer": "Spring Boot is an opinionated framework that simplifies building standalone Spring-based applications by providing sensible defaults, embedded servers, and production-ready features so you can get running with minimal configuration.",
            "useCases": [
                "Quick REST APIs",
                "Microservice bootstrap"
            ],
            "realTimeUseCases": [
                "Create a product service with embedded Tomcat and packaged JAR",
                "Bootstrap microservices with minimal configuration"
            ]
        },
        {
            "id": 4,
            "name": "What problem does Spring Boot solve?",
            "question": "What problem does Spring Boot solve?",
            "answer": "Spring Boot removes boilerplate setup and complex XML configuration by auto-configuring common dependencies, embedding servers, and offering starters so teams focus on business logic rather than plumbing.",
            "useCases": [
                "Reduce project setup time",
                "Standardize project structure"
            ],
            "realTimeUseCases": [
                "Replace verbose web.xml and server deployment with an executable JAR",
                "Use starters to add features like Web, Data JPA, Security quickly"
            ]
        },
        {
            "id": 5,
            "name": "What is auto-configuration?",
            "question": "What is auto-configuration?",
            "answer": "Auto-configuration is Spring Boot's mechanism that inspects classpath and beans and automatically configures Spring components (DataSource, MVC, JPA, etc.) when conditions are met, reducing manual configuration.",
            "useCases": [
                "Auto-configure DataSource and JPA",
                "Auto-configure Jackson for JSON"
            ],
            "realTimeUseCases": [
                "Spring Boot configures HikariCP and DataSource when JDBC driver is present",
                "Automatically configures Jackson for REST controllers"
            ]
        },
        {
            "id": 6,
            "name": "What is Spring Boot Starter?",
            "question": "What is Spring Boot Starter?",
            "answer": "A Starter is a convenient dependency descriptor (starter POM) that pulls in a curated set of dependencies for a feature (e.g., spring-boot-starter-web includes Spring MVC, Jackson, and an embedded server).",
            "useCases": [
                "Add web support quickly",
                "Add data support with a single dependency"
            ],
            "realTimeUseCases": [
                "Add 'spring-boot-starter-data-jpa' to enable JPA and Hibernate",
                "Use 'spring-boot-starter-security' to enable Spring Security defaults"
            ]
        },
        {
            "id": 7,
            "name": "What is Spring Boot CLI?",
            "question": "What is Spring Boot CLI?",
            "answer": "Spring Boot CLI is a command-line tool that lets you run and test Spring Boot applications written in Groovy with minimal code, useful for quick prototyping and scripts.",
            "useCases": [
                "Prototype small services",
                "Run quick Groovy scripts using Spring features"
            ],
            "realTimeUseCases": [
                "Prototype REST endpoints with one-file Groovy scripts",
                "Experiment with auto-configuration quickly"
            ]
        },
        {
            "id": 8,
            "name": "What is @SpringBootApplication?",
            "question": "What is @SpringBootApplication?",
            "answer": "@SpringBootApplication is a convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan to bootstrap a Spring Boot application from a single class.",
            "useCases": [
                "Bootstrap application context",
                "Enable auto-configuration"
            ],
            "realTimeUseCases": [
                "Main application class annotated with @SpringBootApplication starts the app via SpringApplication.run(...)"
            ]
        },
        {
            "id": 9,
            "name": "How does Spring Boot load properties?",
            "question": "How does Spring Boot load properties?",
            "answer": "Spring Boot loads properties from multiple locations in a defined order: application.properties/application.yml on classpath, external config locations, environment variables, and command-line arguments; later sources override earlier ones.",
            "useCases": [
                "Externalize configuration",
                "Support environment-specific overrides"
            ],
            "realTimeUseCases": [
                "Use application-prod.yml for production overrides",
                "Pass db password via environment variable to avoid embedding secrets"
            ]
        },
        {
            "id": 10,
            "name": "What is application.properties vs application.yml?",
            "question": "What is application.properties vs application.yml?",
            "answer": "Both are property sources: application.properties uses key=value pairs; application.yml uses YAML for hierarchical configuration which can be more readable for nested settings; Spring Boot supports both and loads them equivalently.",
            "useCases": [
                "Choose YAML for nested config",
                "Use properties for simple flat lists"
            ],
            "realTimeUseCases": [
                "Define datasource.url in properties or YAML",
                "Group complex datasource and JPA settings in YAML for readability"
            ]
        },
        {
            "id": 11,
            "name": "What is Spring Boot Actuator?",
            "question": "What is Spring Boot Actuator?",
            "answer": "Actuator provides production-ready endpoints and metrics (health, metrics, info, env, beans) to monitor and manage applications; it integrates with Micrometer for metrics publishing.",
            "useCases": [
                "Health checks",
                "Expose metrics and environment info"
            ],
            "realTimeUseCases": [
                "/actuator/health used by load balancer for readiness checks",
                "Expose JVM metrics to Prometheus via Micrometer"
            ]
        },
        {
            "id": 12,
            "name": "What is Spring Boot DevTools?",
            "question": "What is Spring Boot DevTools?",
            "answer": "DevTools speeds development by enabling automatic restarts, live reload support, and developer-friendly defaults; it should not be used in production.",
            "useCases": [
                "Faster development iteration",
                "Auto-restart on code changes"
            ],
            "realTimeUseCases": [
                "Change a controller and see app reload automatically",
                "Enable livereload to refresh browser on templates change"
            ]
        },
        {
            "id": 13,
            "name": "What is @ConfigurationProperties?",
            "question": "What is @ConfigurationProperties?",
            "answer": "@ConfigurationProperties binds a group of external configuration properties to a POJO, enabling type-safe and structured configuration mapping (use with @EnableConfigurationProperties or component scanning).",
            "useCases": [
                "Bind complex config sections to beans",
                "Validate configuration via JSR-303"
            ],
            "realTimeUseCases": [
                "Bind mail.server.* properties into MailProperties bean",
                "Use @Validated on config properties for startup validation"
            ]
        },
        {
            "id": 14,
            "name": "What is Embedded Tomcat?",
            "question": "What is Embedded Tomcat?",
            "answer": "An embedded Tomcat is a server packaged inside the Spring Boot application JAR so the app runs standalone without deploying to an external servlet container.",
            "useCases": [
                "Executable JARs",
                "Simplified deployments"
            ],
            "realTimeUseCases": [
                "Run app with java -jar app.jar, Tomcat starts internally",
                "Simplify containerization by treating app as single artifact"
            ]
        },
        {
            "id": 15,
            "name": "What is Spring Boot Profile?",
            "question": "What is Spring Boot Profile?",
            "answer": "Profiles allow grouping configuration and beans per environment (dev, test, prod); activate profiles via properties or environment to load environment-specific settings.",
            "useCases": [
                "Environment-specific config",
                "Conditional bean registration"
            ],
            "realTimeUseCases": [
                "Use 'spring.profiles.active=prod' to load production settings",
                "Define @Profile('dev') beans for local development only"
            ]
        },
        {
            "id": 16,
            "name": "What is @ConditionalOnMissingBean?",
            "question": "What is @ConditionalOnMissingBean?",
            "answer": "This conditional prevents auto-configuration from creating a bean if the application already defines one of the same type, allowing custom overrides of auto-configured beans.",
            "useCases": [
                "Allow user-provided beans to override auto-configured ones",
                "Create flexible library defaults"
            ],
            "realTimeUseCases": [
                "Auto-configured DataSource backs off if application defines its own DataSource bean"
            ]
        },
        {
            "id": 17,
            "name": "What is @ConditionalOnProperty?",
            "question": "What is @ConditionalOnProperty?",
            "answer": "This annotation enables configuration when a specific property is set or has a specific value, useful for toggling features on/off via properties.",
            "useCases": [
                "Feature toggles via config",
                "Enable optional integrations"
            ],
            "realTimeUseCases": [
                "Enable SSO integration only when 'security.sso.enabled=true' is set"
            ]
        },
        {
            "id": 18,
            "name": "What is Spring Boot Banner?",
            "question": "What is Spring Boot Banner?",
            "answer": "The banner is a startup text/logo shown on application startup; you can customize or disable it via properties or banner.txt.",
            "useCases": [
                "Branding at startup",
                "Display build info"
            ],
            "realTimeUseCases": [
                "Show application name and version in banner at startup"
            ]
        },
        {
            "id": 19,
            "name": "What is health check endpoint?",
            "question": "What is health check endpoint?",
            "answer": "A health endpoint (e.g., /actuator/health) reports application health and readiness for orchestration tools or load balancers to make routing decisions.",
            "useCases": [
                "Readiness and liveness probes",
                "Operational monitoring"
            ],
            "realTimeUseCases": [
                "Kubernetes liveness/readiness probes call /actuator/health",
                "Enable custom checks for downstream services"
            ]
        },
        {
            "id": 20,
            "name": "How to create custom actuator endpoints?",
            "question": "How to create custom actuator endpoints?",
            "answer": "Create a bean annotated with @Endpoint or use @RestController to expose custom endpoints; for actuator integration, implement @ReadOperation/@WriteOperation methods inside an @Endpoint-annotated class.",
            "useCases": [
                "Expose custom metrics or operations",
                "Add management APIs"
            ],
            "realTimeUseCases": [
                "Create an endpoint to trigger cache eviction or reindexing via actuator"
            ]
        },
        {
            "id": 21,
            "name": "How to externalize configuration?",
            "question": "How to externalize configuration?",
            "answer": "Externalize via application.properties/yml, environment variables, command-line args, or external config servers (Spring Cloud Config) so sensitive and environment-specific settings are not packaged in the artifact.",
            "useCases": [
                "Keep secrets out of VCS",
                "Configure per-environment settings"
            ],
            "realTimeUseCases": [
                "Provide DB credentials via environment variables in containerized deployments",
                "Use Spring Cloud Config to centralize config across services"
            ]
        },
        {
            "id": 22,
            "name": "How to secure Spring Boot endpoints?",
            "question": "How to secure Spring Boot endpoints?",
            "answer": "Secure endpoints using Spring Security: configure HttpSecurity rules, enable method security, use OAuth2/JWT for stateless APIs, and restrict actuator endpoints via management.security or custom security config.",
            "useCases": [
                "Protect REST APIs",
                "Harden management endpoints"
            ],
            "realTimeUseCases": [
                "Require authentication for /api/* endpoints",
                "Expose actuator/health publicly but secure sensitive actuator endpoints like /actuator/env"
            ]
        },
        {
            "id": 23,
            "name": "What are the most important Spring Boot annotations?",
            "question": "What are the most important Spring Boot annotations?",
            "answer": "@SpringBootApplication combines @Configuration, @EnableAutoConfiguration, and @ComponentScan for quick startup. @RestController marks a class as a REST endpoint provider. @RequestMapping/@GetMapping/@PostMapping define HTTP routes. @Service, @Repository, @Component create managed beans. @Autowired injects dependencies. @Configuration marks configuration classes. @PropertySource loads external configs. @ConditionalOnProperty/@ConditionalOnMissingBean enable conditional bean creation. @EnableAutoConfiguration triggers auto-configuration. @Value injects property values. @Bean creates custom beans in config classes. @ResponseStatus sets HTTP response status. @ControllerAdvice centralizes exception handling. @Transactional manages transactions. @Validated enables JSR-303 validation. @EnableScheduling enables @Scheduled tasks. @Async enables async method execution. @LoadBalanced configures Ribbon for load balancing. @FeignClient creates HTTP clients. @EnableEurekaClient registers with Eureka service discovery.",
            "useCases": [
                "Understanding core Spring Boot annotations",
                "Building REST APIs with proper annotations",
                "Managing application configuration",
                "Implementing enterprise patterns"
            ],
            "realTimeUseCases": [
                "Use @SpringBootApplication on main class to bootstrap entire app; internally enables auto-config and component scanning for NMG product-service discovering @Service(ProductService) and @RestController(ProductController) automatically",
                "Use @GetMapping(\"/products\") on controller method to handle HTTP GET requests; combined with @Autowired ProductService, enables clean REST endpoint handling in product listing feature",
                "Use @ConfigurationProperties to bind application-prod.yml datasource.* settings to DataSourceProperties bean; Spring Boot validates and auto-configures HikariCP on startup",
                "Use @Async on methods to execute in thread pool; ProductService.indexProducts() runs asynchronously without blocking API response, improving user experience",
                "Use @ControllerAdvice with @ExceptionHandler to centralize error handling; handle ProductNotFoundException globally returning 404 JSON response across all REST endpoints",
                "Use @Transactional on OrderService.placeOrder() to ensure atomicity across multiple DB operations (insert order, update inventory, create shipment); rollback all if any fails",
                "Use @Value(\"${app.api.timeout:5000}\") to inject configurable values; easy to change timeouts per environment without code change",
                "Use @EnableScheduling with @Scheduled(fixedRate=60000) on cache refresh task; automatically runs cache eviction every 60s without explicit scheduling code",
                "Use @Validated with @Valid on request DTO parameters to auto-validate incoming JSON; returns 400 if name is blank or email invalid per JSR-303 constraints",
                "Use @LoadBalanced RestTemplate to distribute calls across multiple service instances in microservices deployment; Spring Cloud integrates with Eureka discovery"
            ]
        },
        {
            "id": 24,
            "name": "Database configuration files",
            "question": "What are the database configuration files and where to put DB connection details?",
            "answer": "Spring Boot loads DB settings from externalized config such as application.properties or application.yml (classpath or external locations). Connection details (URL, username, password, driver) typically go under spring.datasource.* or custom property groups. You can also bind complex settings to POJOs with @ConfigurationProperties or use Spring Cloud Config for centralized configuration.",
            "useCases": [
                "Store DB URL and credentials",
                "Use profiles for env-specific config",
                "Bind complex settings to POJOs"
            ],
            "realTimeUseCases": [
                "Define spring.datasource.url/username/password in application-prod.yml",
                "Use environment variables for secrets in containers"
            ]
        },
        {
            "id": 25,
            "name": "Multiple DBs and default environment",
            "question": "How to configure multiple databases per environment and what is the default environment?",
            "answer": "Use Spring profiles (application-dev.yml, application-test.yml, application-prod.yml) and activate the profile with spring.profiles.active. For multiple DBs, define multiple DataSource beans (e.g., primary and secondary) or configure multiple property groups (spring.datasource.primary.*, spring.datasource.secondary.*) and use @ConfigurationProperties to bind each. Mark one DataSource @Primary or wire repositories to specific EntityManagerFactories. If no profile is active, Spring uses properties in application.properties/application.yml (the 'default' environment).",
            "useCases": [
                "Per-environment DB URLs via profiles",
                "Multiple DataSources for read/write or reporting",
                "Use @Primary to select default DataSource"
            ],
            "realTimeUseCases": [
                "application-dev.yml points to local dev DB; application-qa.yml points to QA DB; CI sets spring.profiles.active=qa",
                "Primary DataSource for app data, secondary for reporting DB"
            ]
        },
        {
            "id": 26,
            "name": "Difference between @RestController and @Controller",
            "question": "What are the main differences between @RestController and @Controller in Spring Boot?",
            "answer": "@Controller marks a Spring MVC controller intended to return view names (rendered via a ViewResolver). @RestController is a convenience annotation that combines @Controller and @ResponseBody, so return values are serialized (usually JSON) directly to the HTTP response. Use @Controller for server-rendered HTML pages and @RestController for REST APIs returning JSON or XML.",
            "useCases": [
                "Server-side rendered pages with @Controller",
                "JSON REST APIs with @RestController"
            ],
            "realTimeUseCases": [
                "Use @Controller + Thymeleaf for admin UIs",
                "Use @RestController for product API endpoints consumed by SPAs"
            ]
        },
        {
            "id": 27,
            "name": "Common Spring Boot annotations (summary)",
            "question": "List common Spring Boot annotations and explain them briefly.",
            "answer": "@SpringBootApplication â€” convenience meta-annotation combining @Configuration, @EnableAutoConfiguration, @ComponentScan. @ConfigurationProperties â€” binds external config to a POJO. @Value â€” inject individual property values. @EnableAutoConfiguration â€” enable Spring Boot auto-configuration (usually via @SpringBootApplication). @ConditionalOnProperty / @ConditionalOnMissingBean â€” conditional auto-configure controls. @Profile â€” activate beans per environment. @RestController / @Controller â€” REST vs MVC controllers. @Bean â€” declare a bean in configuration. @Component/@Service/@Repository â€” stereotype annotations for component scanning.",
            "useCases": [
                "Bootstrapping apps, binding config, conditional auto-configuration, profile-based beans"
            ],
            "realTimeUseCases": [
                "Annotate main class with @SpringBootApplication to bootstrap",
                "Use @ConfigurationProperties for typed config classes",
                "Use @Profile('dev') to register dev-only beans"
            ]
        }
    ],
    "Spring Cloud & Microservices": [
        {
            "id": 1,
            "name": "Microservices",
            "question": "What is Microservices?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Kafka": [
        {
            "id": 1,
            "name": "Microservices",
            "question": "What is Microservices?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "SQL": [
        {
            "id": 1,
            "name": "SQL",
            "question": "What is SQL?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "Python": [
        {
            "id": 1,
            "name": "Azure",
            "question": "What is Azure?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Django": [
        {
            "id": 1,
            "name": "Node JS",
            "question": "What is Node JS?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "Fast API": [
        {
            "id": 1,
            "name": "Express JS",
            "question": "What is JavaScript?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "PySpark": [
        {
            "id": 1,
            "name": "Java",
            "question": "What is Java?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "Flask API": [
        {
            "id": 1,
            "name": "Net",
            "question": "What is Net?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    ".Net": [
        {
            "id": 1,
            "name": "Net",
            "question": "What is Net?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "ASP.Net": [
        {
            "id": 1,
            "name": "ASP .Net",
            "question": "What is ASP .Net?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "JPA.net": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Power BI": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Tableau": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "DAX": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "CyberSecurity": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Git/GitHub": [
        {
            "id": 1,
            "name": "AWS",
            "question": "What is AWS?",
            "answer": "HTML stands for HyperText Markup Language and is used to create web pages.",
            "useCases": [
                "Building web structure",
                "Embedding multimedia"
            ],
            "realTimeUseCases": [
                "Developing website templates",
                "Creating forms"
            ]
        },
        {
            "id": 2,
            "name": "CSS",
            "question": "What is CSS?",
            "answer": "CSS is used to style and layout web pages.",
            "useCases": [
                "Styling",
                "Responsive Design"
            ],
            "realTimeUseCases": [
                "Creating themes",
                "Designing UI"
            ]
        }
    ],
    "Jenkins": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Docker": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Kubernates": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "TerraForm": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "SonarQube": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Graphana": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Manual Testing": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Automation Testing": [
        {
            "id": 1,
            "name": "Kafka",
            "question": "What is Kafka?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "AWS": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Azure": [
        {
            "id": 1,
            "name": "Git",
            "question": "What is Git?",
            "answer": "JavaScript is a programming language used to make web pages interactive.",
            "useCases": [
                "Form validation",
                "APIs integration"
            ],
            "realTimeUseCases": [
                "Building SPAs",
                "Creating dashboards"
            ]
        }
    ],
    "Core Java": [
        {
            "id": 1,
            "name": "What is Java?",
            "question": "What is Java?",
            "answer": "Java is a high-level, class-based, object-oriented programming language designed to have as few implementation dependencies as possible. It compiles to platform-independent bytecode that runs on the JVM.",
            "useCases": [
                "Server-side applications",
                "Android apps"
            ],
            "realTimeUseCases": [
                "Enterprise backend services",
                "Android mobile apps"
            ]
        },
        {
            "id": 2,
            "name": "Why Java?",
            "question": "Why Java?",
            "answer": "Java offers portability (write once, run anywhere), strong ecosystem, mature tooling, automatic memory management, robust standard libraries, and wide enterprise adoption, making it suitable for large-scale systems.",
            "useCases": [
                "Enterprise systems",
                "Cross-platform apps"
            ],
            "realTimeUseCases": [
                "Banking backends",
                "Large eCommerce platforms"
            ]
        },
        {
            "id": 3,
            "name": "Core features of Java",
            "question": "What are the core features of Java?",
            "answer": "Core features include platform independence via bytecode/JVM, object-orientation, automatic garbage collection, strong typing, multithreading support, built-in networking, and rich standard libraries.",
            "useCases": [
                "Scalable apps",
                "Safe memory management"
            ],
            "realTimeUseCases": [
                "Multithreaded servers",
                "Networked applications"
            ]
        },
        {
            "id": 4,
            "name": "Platform Independence",
            "question": "What is Platform Independence?",
            "answer": "Platform independence means Java source is compiled to bytecode that can run on any system with a compatible JVM, decoupling compiled code from underlying OS and hardware.",
            "useCases": [
                "Cross-platform deployment",
                "Portability"
            ],
            "realTimeUseCases": [
                "Deploy same artifact across Windows/Linux"
            ]
        },
        {
            "id": 5,
            "name": "Bytecode",
            "question": "What is Bytecode?",
            "answer": "Bytecode is the intermediate, platform-neutral instruction set produced by the Java compiler (.class files); the JVM interprets or JIT-compiles it to native code at runtime.",
            "useCases": [
                "Portability",
                "Security via verification"
            ],
            "realTimeUseCases": [
                "Distribution of .class/.jar files"
            ]
        },
        {
            "id": 6,
            "name": "Java security",
            "question": "What makes Java secure?",
            "answer": "Security arises from bytecode verification, the JVM sandboxing model, strong type checks, controlled native access, security manager (legacy), and safe library design that reduce undefined behavior.",
            "useCases": [
                "Safe execution",
                "Sandboxing"
            ],
            "realTimeUseCases": [
                "Running untrusted applets historically, secured microservices"
            ]
        },
        {
            "id": 7,
            "name": "High-level language",
            "question": "Why Java is called high-level language?",
            "answer": "Because it abstracts low-level details (memory management, pointers) and provides rich built-in constructs, allowing developers to focus on logic rather than hardware specifics.",
            "useCases": [
                "Faster development",
                "Maintainability"
            ],
            "realTimeUseCases": [
                "Business logic implementation"
            ]
        },
        {
            "id": 8,
            "name": "Robustness",
            "question": "Why Java is called robust?",
            "answer": "Java emphasizes early error checking, exception handling, memory management via garbage collection, and strong typing, which reduces runtime crashes and improves reliability.",
            "useCases": [
                "Reliable systems",
                "Error handling"
            ],
            "realTimeUseCases": [
                "Payment processing servers"
            ]
        },
        {
            "id": 9,
            "name": "Portability",
            "question": "Why Java is called portable?",
            "answer": "Because the same compiled bytecode runs on any platform with a compatible JVM without recompilation, enabling easy distribution across environments.",
            "useCases": [
                "Cross-OS deployment",
                "Dev/prod parity"
            ],
            "realTimeUseCases": [
                "Cloud deployments across providers"
            ]
        },
        {
            "id": 10,
            "name": "Simplicity",
            "question": "Why Java is simple compared to C/C++?",
            "answer": "Java removes complex features like manual memory management and pointer arithmetic, provides a simpler object model, and offers a consistent standard library, lowering cognitive overhead.",
            "useCases": [
                "Rapid development",
                "Fewer low-level bugs"
            ],
            "realTimeUseCases": [
                "Team-based enterprise development"
            ]
        },
        {
            "id": 11,
            "name": "JVM",
            "question": "What is JVM?",
            "answer": "The Java Virtual Machine is a runtime that loads, verifies, interprets or JIT-compiles bytecode, provides memory management, and offers platform abstraction for Java applications.",
            "useCases": [
                "Runtime execution",
                "Isolation"
            ],
            "realTimeUseCases": [
                "Running microservices on JVM"
            ]
        },
        {
            "id": 12,
            "name": "JVM responsibilities",
            "question": "What are the responsibilities of JVM?",
            "answer": "JVM loads classes, verifies bytecode, manages memory and garbage collection, provides execution (interpreter/JIT), handles exceptions, and enforces security checks.",
            "useCases": [
                "Execution management",
                "Security"
            ],
            "realTimeUseCases": [
                "Production Java servers"
            ]
        },
        {
            "id": 13,
            "name": "JRE",
            "question": "What is JRE?",
            "answer": "JRE (Java Runtime Environment) includes the JVM and standard libraries required to run Java applications but does not include development tools like the compiler.",
            "useCases": [
                "Runtime deployments",
                "End-user runtime"
            ],
            "realTimeUseCases": [
                "Servers with only runtime installed"
            ]
        },
        {
            "id": 14,
            "name": "JDK",
            "question": "What is JDK?",
            "answer": "JDK (Java Development Kit) bundles the JRE plus development tools (javac, jar, javadoc) necessary to compile, package, and develop Java applications.",
            "useCases": [
                "Development",
                "Build systems"
            ],
            "realTimeUseCases": [
                "CI build agents with JDK installed"
            ]
        },
        {
            "id": 15,
            "name": "JVM vs JRE vs JDK",
            "question": "What is the difference between JVM, JRE, and JDK?",
            "answer": "JVM is the runtime engine that executes bytecode. JRE is the package containing the JVM and standard runtime libraries to run Java apps. JDK includes JRE plus developer tools to build Java applications.",
            "useCases": [
                "Clarifying components",
                "Environment setup"
            ],
            "realTimeUseCases": [
                "Choosing JRE for production, JDK for development"
            ]
        },
        {
            "id": 16,
            "name": "Class loading and execution",
            "question": "How JVM loads, verifies, and executes a class file internally?",
            "answer": "The class loader subsystem loads binary class data, the bytecode verifier checks format and type-safety, the runtime links and resolves symbolic references, and finally the interpreter or JIT executes the code.",
            "useCases": [
                "Startup behavior",
                "Security"
            ],
            "realTimeUseCases": [
                "Classloading in app servers"
            ]
        },
        {
            "id": 17,
            "name": "ClassLoader",
            "question": "What is ClassLoader?",
            "answer": "ClassLoader is a JVM component responsible for dynamically loading classes into the JVM from various sources (filesystem, network, jars) and delegating to parent loaders per delegation model.",
            "useCases": [
                "Modular loading",
                "Isolation"
            ],
            "realTimeUseCases": [
                "App servers isolating webapp classes"
            ]
        },
        {
            "id": 18,
            "name": "Types of ClassLoaders",
            "question": "What are the types of ClassLoaders?",
            "answer": "Common loaders: Bootstrap (core runtime), Extension (optional packages), and Application (loads classes from application classpath). Containers may add custom classloaders.",
            "useCases": [
                "Custom loading",
                "Classpath separation"
            ],
            "realTimeUseCases": [
                "Tomcat custom classloaders per webapp"
            ]
        },
        {
            "id": 19,
            "name": "Role of ClassLoader",
            "question": "What is the role of ClassLoader in JVM architecture?",
            "answer": "ClassLoaders discover and load class definitions, enforce namespace isolation, support dynamic loading/unloading, and enable modular deployments and plugin architectures.",
            "useCases": [
                "Dynamic modules",
                "Security"
            ],
            "realTimeUseCases": [
                "Hot plugin loading"
            ]
        },
        {
            "id": 20,
            "name": "JIT compiler",
            "question": "What is JIT compiler?",
            "answer": "JIT (Just-In-Time) compiler compiles frequently executed bytecode paths to native machine code at runtime to improve performance by reducing interpretation overhead.",
            "useCases": [
                "Performance optimization",
                "Hotspot compilation"
            ],
            "realTimeUseCases": [
                "Long-running services benefitting from JIT optimizations"
            ]
        },
        {
            "id": 21,
            "name": "Why JIT improves performance",
            "question": "Why JIT improves performance?",
            "answer": "JIT optimizes hot code paths using runtime information, inlines methods, removes redundant checks, and generates optimized native code tuned to the current workload and CPU.",
            "useCases": [
                "Runtime optimizations",
                "Adaptive compilation"
            ],
            "realTimeUseCases": [
                "Throughput improvements in servers"
            ]
        },
        {
            "id": 22,
            "name": "Memory Management in Java",
            "question": "What is Memory Management in Java?",
            "answer": "Memory management is the automated allocation and deallocation of heap memory via garbage collection, freeing developers from manual memory handling while maintaining safety and performance.",
            "useCases": [
                "Safety",
                "Simplicity"
            ],
            "realTimeUseCases": [
                "Long-running servers without memory leaks"
            ]
        },
        {
            "id": 23,
            "name": "Different memory areas in JVM",
            "question": "What are the different memory areas in JVM?",
            "answer": "JVM memory areas: Heap (objects, GC-managed), Stack (primitives, method calls), Method Area (classes, constants), PC Register (current instruction), Native Method Stack (native code).",
            "useCases": [
                "Memory layout understanding",
                "Performance tuning"
            ],
            "realTimeUseCases": [
                "Debugging OutOfMemoryError"
            ]
        },
        {
            "id": 24,
            "name": "Heap memory",
            "question": "What is Heap memory?",
            "answer": "Heap is a runtime memory area where objects are allocated and garbage collected. It is shared across threads, dynamically sized, and slower to access than stack. GC manages lifetime.",
            "useCases": [
                "Object storage",
                "Shared data"
            ],
            "realTimeUseCases": [
                "Storing application objects"
            ]
        },
        {
            "id": 25,
            "name": "Stack memory",
            "question": "What is Stack memory?",
            "answer": "Stack stores method calls, local primitives, and references. Each thread has its own stack. LIFO allocation/deallocation. Fast access. Thread-safe by design. Throws StackOverflowError if full.",
            "useCases": [
                "Local data storage",
                "Method tracking"
            ],
            "realTimeUseCases": [
                "Method execution, local variables"
            ]
        },
        {
            "id": 26,
            "name": "Method Area",
            "question": "What is Method Area?",
            "answer": "Method Area stores class structures, method data, code, constants, runtime constant pool, and static variables. Shared across threads. Also called PermGen (Java 7) or Metaspace (Java 8+).",
            "useCases": [
                "Class metadata storage",
                "Static data"
            ],
            "realTimeUseCases": [
                "Storing class definitions in app servers"
            ]
        },
        {
            "id": 27,
            "name": "PC Register",
            "question": "What is PC Register?",
            "answer": "Program Counter (PC) Register stores address of currently executing JVM instruction. For native methods, PC is undefined. Per-thread. Small fixed size.",
            "useCases": [
                "Instruction tracking",
                "Native interface"
            ],
            "realTimeUseCases": [
                "Debugger operation"
            ]
        },
        {
            "id": 28,
            "name": "Native Method Stack",
            "question": "What is Native Method Stack?",
            "answer": "Native Method Stack contains all native methods used in Java code. Written in C/C++. Per-thread. Managed by JNI (Java Native Interface).",
            "useCases": [
                "Native code support",
                "System integration"
            ],
            "realTimeUseCases": [
                "Calling system libraries via JNI"
            ]
        },
        {
            "id": 29,
            "name": "Stack vs Heap speed",
            "question": "Why stack memory is faster than heap?",
            "answer": "Stack uses simple pointer increment for allocation, LIFO auto-deallocation, no GC overhead, cache-friendly sequential access. Heap requires allocation search, fragmentation management, and GC overhead.",
            "useCases": [
                "Performance optimization",
                "Memory design"
            ],
            "realTimeUseCases": [
                "Hot loops using stack variables"
            ]
        },
        {
            "id": 30,
            "name": "Method call memory layout",
            "question": "What happens in memory when a method is called?",
            "answer": "Method creates a stack frame: local variables pushed, method parameters stored, execution proceeds. On return, frame popped, return address goes to caller. Stack pointer adjusted. Heap objects accessed via references.",
            "useCases": [
                "Execution flow",
                "Memory layout"
            ],
            "realTimeUseCases": [
                "Understanding method call overhead"
            ]
        },
        {
            "id": 31,
            "name": "Escape Analysis",
            "question": "What is Escape Analysis in Java?",
            "answer": "Escape Analysis is a JVM optimization identifying objects that don't escape method scope and eliminating them via stack allocation or scalar replacement instead of heap allocation.",
            "useCases": [
                "Performance optimization",
                "Memory efficiency"
            ],
            "realTimeUseCases": [
                "Short-lived temporary objects"
            ]
        },
        {
            "id": 32,
            "name": "OutOfMemoryError",
            "question": "What is OutOfMemoryError?",
            "answer": "OutOfMemoryError occurs when heap exhaustion prevents new object allocation. Causes: memory leaks, unbounded collections, insufficient heap size. Fix: increase heap or find leaks.",
            "useCases": [
                "Error diagnosis",
                "Memory tuning"
            ],
            "realTimeUseCases": [
                "Production incidents with OOM"
            ]
        },
        {
            "id": 33,
            "name": "StackOverflowError",
            "question": "What is StackOverflowError?",
            "answer": "StackOverflowError occurs when stack depth exceeds limit (e.g., deep recursion). Causes: infinite recursion, very deep call chains. Fix: iterative approach or increase stack size.",
            "useCases": [
                "Recursion limits",
                "Error handling"
            ],
            "realTimeUseCases": [
                "Debugging runaway recursion"
            ]
        },
        {
            "id": 34,
            "name": "Garbage Collection",
            "question": "What is Garbage Collection?",
            "answer": "Garbage Collection (GC) is automatic memory reclamation that identifies unreachable heap objects and frees their memory for reuse, eliminating manual deallocation and preventing memory leaks.",
            "useCases": [
                "Memory safety",
                "Automation"
            ],
            "realTimeUseCases": [
                "Long-running services"
            ]
        },
        {
            "id": 35,
            "name": "Why GC required",
            "question": "Why is Garbage Collection required?",
            "answer": "GC prevents memory leaks (unreachable objects consuming memory), avoids manual deallocation errors (double-free, use-after-free), and simplifies development. Essential for safety and reliability.",
            "useCases": [
                "Memory safety",
                "Development speed"
            ],
            "realTimeUseCases": [
                "Reliable enterprise apps"
            ]
        },
        {
            "id": 36,
            "name": "How GC works internally",
            "question": "How does Garbage Collection work internally?",
            "answer": "GC uses mark-sweep or generational algorithms: mark phase identifies reachable objects via root tracing, sweep phase frees unmarked objects. Generational GC separates young/old objects for efficiency.",
            "useCases": [
                "Performance tuning",
                "Understanding pauses"
            ],
            "realTimeUseCases": [
                "Reducing GC pause times in critical systems"
            ]
        },
        {
            "id": 37,
            "name": "Minor and Major GC",
            "question": "What are Minor GC and Major GC?",
            "answer": "Minor GC (Young GC) collects young generation objects; fast, frequent, small pause. Major GC (Full GC) collects all objects; slow, infrequent, long pause. Full GC includes compaction.",
            "useCases": [
                "GC tuning",
                "Performance analysis"
            ],
            "realTimeUseCases": [
                "Observing GC logs for optimization"
            ]
        },
        {
            "id": 38,
            "name": "Different garbage collectors",
            "question": "What are the different garbage collectors in Java?",
            "answer": "Collectors: Serial (single-thread), Parallel (multi-thread), CMS (concurrent mark-sweep, low-pause), G1 (region-based), ZGC (ultra-low pause), Shenandoah. Choice depends on latency/throughput requirements.",
            "useCases": [
                "GC selection",
                "Latency tuning"
            ],
            "realTimeUseCases": [
                "Selecting GC for microservices vs batch"
            ]
        },
        {
            "id": 39,
            "name": "G1 Garbage Collector",
            "question": "What is G1 Garbage Collector?",
            "answer": "G1 divides heap into regions, collects regions with most garbage first (garbage first). Generational. Low pause times. Default in Java 9+. Balances throughput and latency.",
            "useCases": [
                "Large heaps",
                "Low latency"
            ],
            "realTimeUseCases": [
                "Default choice for modern apps"
            ]
        },
        {
            "id": 40,
            "name": "CMS Garbage Collector deprecation",
            "question": "Why CMS Garbage Collector was deprecated?",
            "answer": "CMS (Concurrent Mark-Sweep) was complex, prone to fragmentation, had unpredictable pauses, and maintenance burden. G1 and ZGC provide better alternatives. Removed in Java 14+.",
            "useCases": [
                "GC history",
                "Migration planning"
            ],
            "realTimeUseCases": [
                "Migrating from legacy CMS to G1"
            ]
        },
        {
            "id": 41,
            "name": "Memory Leaks in Java",
            "question": "What causes Memory Leaks in Java?",
            "answer": "Leaks: static collections growing unbounded, circular references, unclosed resources, listeners not unregistered, cached objects held indefinitely. GC can't free unreachable objects.",
            "useCases": [
                "Leak prevention",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Preventing OutOfMemory in long-running apps"
            ]
        },
        {
            "id": 42,
            "name": "Detect memory leaks",
            "question": "How to detect memory leaks?",
            "answer": "Use heap dumps, profilers (JProfiler, YourKit), GC logs analysis, monitoring tools (Micrometer, NewRelic). Look for growing heap usage, repeated GC pauses, OutOfMemory errors.",
            "useCases": [
                "Production monitoring",
                "Debugging"
            ],
            "realTimeUseCases": [
                "Heap dump analysis after OOM"
            ]
        },
        {
            "id": 43,
            "name": "Prevent memory leaks",
            "question": "How to prevent memory leaks?",
            "answer": "Use try-with-resources, unregister listeners, avoid static collections, use weak references for caches, proper resource cleanup, regular monitoring, heap analysis in QA.",
            "useCases": [
                "Best practices",
                "Code quality"
            ],
            "realTimeUseCases": [
                "Code review checklist items"
            ]
        },
        {
            "id": 44,
            "name": "finalize() deprecation",
            "question": "What is finalize() and why is it deprecated?",
            "answer": "finalize() was a Object method intended for cleanup before GC. Deprecated since Java 9: unpredictable timing, performance impact, poor semantics. Use try-with-resources or AutoCloseable instead.",
            "useCases": [
                "Resource management",
                "Migration"
            ],
            "realTimeUseCases": [
                "Modernizing legacy Java code"
            ]
        },
        {
            "id": 45,
            "name": "Data types in Java",
            "question": "What are data types in Java?",
            "answer": "Data types classify values: primitives (byte, short, int, long, float, double, boolean, char) and non-primitives (Object, String, arrays, classes). Determines size, range, and behavior.",
            "useCases": [
                "Type safety",
                "Memory efficiency"
            ],
            "realTimeUseCases": [
                "Variable declarations"
            ]
        },
        {
            "id": 46,
            "name": "Primitive data types",
            "question": "What are primitive data types?",
            "answer": "Primitives: byte (8-bit), short (16-bit), int (32-bit), long (64-bit), float (32-bit), double (64-bit), boolean (true/false), char (16-bit Unicode). Stack-allocated. No methods.",
            "useCases": [
                "Basic values",
                "Performance"
            ],
            "realTimeUseCases": [
                "Loop counters, flags"
            ]
        },
        {
            "id": 47,
            "name": "Non-primitive data types",
            "question": "What are non-primitive data types?",
            "answer": "Non-primitives (reference types): classes, interfaces, arrays, enums. Heap-allocated. Have methods. Can be null. Examples: String, Integer[], List.",
            "useCases": [
                "Complex structures",
                "OOP"
            ],
            "realTimeUseCases": [
                "Collections, custom objects"
            ]
        },
        {
            "id": 48,
            "name": "Why Java not fully OOP",
            "question": "Why Java is not fully object-oriented?",
            "answer": "Java has primitives (not objects), static methods (not purely OOP), and procedural constructs (for loops). A fully OOP language wraps everything in objects (like Ruby or Python).",
            "useCases": [
                "Language design",
                "Understanding Java"
            ],
            "realTimeUseCases": [
                "Interview discussions"
            ]
        },
        {
            "id": 49,
            "name": "Type casting",
            "question": "What is type casting?",
            "answer": "Type casting converts a value from one data type to another: explicit (int x = (int)3.14) or implicit (widening). Casting objects checks runtime type (ClassCastException on mismatch).",
            "useCases": [
                "Type conversion",
                "Polymorphism"
            ],
            "realTimeUseCases": [
                "Converting double to int"
            ]
        },
        {
            "id": 50,
            "name": "Widening and narrowing",
            "question": "What is widening and narrowing conversion?",
            "answer": "Widening (promotion): implicit, safe conversion to larger type (intâ†’long). Narrowing (demotion): explicit, potential loss (longâ†’int requires cast). Widening always safe; narrowing may lose data.",
            "useCases": [
                "Type compatibility",
                "Automatic conversions"
            ],
            "realTimeUseCases": [
                "Method overload resolution"
            ]
        },
        {
            "id": 51,
            "name": "Variables in Java",
            "question": "What are variables in Java?",
            "answer": "Variables are named memory locations holding values: local (method-scoped), instance (object-scoped), static (class-scoped). Declared with type, optional initial value.",
            "useCases": [
                "Data storage",
                "State management"
            ],
            "realTimeUseCases": [
                "All programs"
            ]
        },
        {
            "id": 52,
            "name": "Scope of a variable",
            "question": "What is the scope of a variable?",
            "answer": "Scope defines where variable is accessible: local (within method/block), instance (within object), static (within class/globally via class name). Out-of-scope = compilation error.",
            "useCases": [
                "Name resolution",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Avoiding name conflicts"
            ]
        },
        {
            "id": 53,
            "name": "Local variable",
            "question": "What is a local variable?",
            "answer": "Local variable declared inside method/constructor/block, scoped to that block, stack-allocated, must be initialized before use, destroyed when block exits.",
            "useCases": [
                "Method-local state",
                "Performance"
            ],
            "realTimeUseCases": [
                "Loop variables, temporary calculations"
            ]
        },
        {
            "id": 54,
            "name": "Instance variable",
            "question": "What is an instance variable?",
            "answer": "Instance variable declared in class body, scoped to object, heap-allocated (with object), default-initialized (0, false, null), each object has own copy.",
            "useCases": [
                "Object state",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Properties of User, Product, Order"
            ]
        },
        {
            "id": 55,
            "name": "Class/static variable",
            "question": "What is a class/static variable?",
            "answer": "Static variable declared with 'static' keyword, scoped to class, stored in Method Area, shared by all objects, default-initialized, accessed via ClassName.variable.",
            "useCases": [
                "Shared state",
                "Constants"
            ],
            "realTimeUseCases": [
                "Counters, configuration constants"
            ]
        },
        {
            "id": 56,
            "name": "Why static in method area",
            "question": "Why static variables are stored in the method area?",
            "answer": "Static variables are class-level, shared by all instances, allocated once at class load time in Method Area (not heap). Enables class-level state and avoids per-instance memory.",
            "useCases": [
                "Memory efficiency",
                "Class-level state"
            ],
            "realTimeUseCases": [
                "Singleton patterns, constants"
            ]
        },
        {
            "id": 57,
            "name": "Operators in Java",
            "question": "What are operators in Java?",
            "answer": "Operators: arithmetic (+, -, *, /, %), comparison (==, !=, <, >), logical (&&, ||, !), assignment (=, +=), bitwise (&, |, ^), ternary (?:). Operate on operands to produce results.",
            "useCases": [
                "Expressions",
                "Control flow"
            ],
            "realTimeUseCases": [
                "All code"
            ]
        },
        {
            "id": 58,
            "name": "Short-circuit evaluation",
            "question": "What is short-circuit evaluation in logical operators?",
            "answer": "Short-circuit: && stops evaluating if left is false (right not evaluated), || stops if left is true. Avoids unnecessary computation, prevents null pointer exceptions (if (obj != null && obj.method())).",
            "useCases": [
                "Performance",
                "Safety"
            ],
            "realTimeUseCases": [
                "Null-safe checks"
            ]
        },
        {
            "id": 59,
            "name": "Difference between = and ==",
            "question": "What is the difference between = and == ?",
            "answer": "= is assignment operator (stores value in variable). == is comparison operator (checks if two values are equal). Example: x = 5 assigns 5 to x; x == 5 checks if x equals 5.",
            "useCases": [
                "Variable assignment",
                "Comparison"
            ],
            "realTimeUseCases": [
                "All code"
            ]
        },
        {
            "id": 60,
            "name": "Difference between == and equals()",
            "question": "What is the difference between == and equals()?",
            "answer": "== compares references (object identity), equals() compares values (content). For Strings, == checks same object, equals() checks content. Override equals() for custom equality.",
            "useCases": [
                "Object comparison",
                "String handling"
            ],
            "realTimeUseCases": [
                "Comparing User objects, Strings"
            ]
        },
        {
            "id": 61,
            "name": "Conditional statements",
            "question": "What are conditional statements in Java?",
            "answer": "Conditionals: if/else (execute block if condition true), else if (multiple conditions), switch/case (multi-branch). Control program flow based on conditions.",
            "useCases": [
                "Decision logic",
                "Control flow"
            ],
            "realTimeUseCases": [
                "Business logic"
            ]
        },
        {
            "id": 62,
            "name": "How switch-case works internally",
            "question": "How does switch-case work internally?",
            "answer": "Switch compiles to jump table (bytecode tableswitch/lookupswitch) for efficiency. Compares expression to cases, jumps to matching case or default. Requires break to exit (fall-through otherwise).",
            "useCases": [
                "Performance optimization",
                "Code generation"
            ],
            "realTimeUseCases": [
                "Multiple branches on single value"
            ]
        },
        {
            "id": 63,
            "name": "Switch supports String",
            "question": "Why switch supports String from Java 7?",
            "answer": "Java 7 added String switch support: compiler converts String to hashCode() lookup and equality check, then switches on hash value. Cleaner syntax than if-else chains for Strings.",
            "useCases": [
                "String handling",
                "Code readability"
            ],
            "realTimeUseCases": [
                "Parsing command strings"
            ]
        },
        {
            "id": 64,
            "name": "Difference between loops",
            "question": "What is the difference between for, while, do-while?",
            "answer": "for: init, condition, increment explicit (count-based). while: condition-checked before loop. do-while: loop executes once before condition check (guaranteed at least one iteration).",
            "useCases": [
                "Iteration",
                "Control flow"
            ],
            "realTimeUseCases": [
                "Array iteration, input validation"
            ]
        },
        {
            "id": 65,
            "name": "For-each loop",
            "question": "What is for-each loop?",
            "answer": "Enhanced for loop (for-each): for (Type item : collection) iterates over arrays and iterables without index. Cleaner, less error-prone than indexed loops. Introduced in Java 5.",
            "useCases": [
                "Cleaner iteration",
                "Collections"
            ],
            "realTimeUseCases": [
                "Iterating over List, arrays"
            ]
        },
        {
            "id": 66,
            "name": "Java for-in support",
            "question": "Does Java support \"for-in\" like JavaScript?",
            "answer": "Java has for-each (similar to JavaScript for-in), not exact for-in. for-each iterates values of collections/arrays. Java does not have for-in which iterates property names like JS.",
            "useCases": [
                "Language comparison",
                "Iteration"
            ],
            "realTimeUseCases": [
                "Interview discussions"
            ]
        },
        {
            "id": 67,
            "name": "Why no foreach index loop",
            "question": "Why Java does not have \"foreach index\"-style loop?",
            "answer": "for-each abstracts away index for simplicity and safety. For index-based access, use traditional for loop. Iterator pattern avoids exposing internal iteration mechanism.",
            "useCases": [
                "API design",
                "Abstraction"
            ],
            "realTimeUseCases": [
                "Working with LinkedList (no index)"
            ]
        },
        {
            "id": 68,
            "name": "Static in Java",
            "question": "What is static in Java?",
            "answer": "Static keyword marks class-level members (variables, methods, blocks) shared across all instances, loaded once at class load time, accessed via ClassName.member. No instance required.",
            "useCases": [
                "Class-level state",
                "Utilities"
            ],
            "realTimeUseCases": [
                "main() method, Math.sqrt()"
            ]
        },
        {
            "id": 69,
            "name": "Static variables",
            "question": "What are static variables?",
            "answer": "Static variables are class-level, shared by all instances, initialized once, stored in Method Area, accessed via ClassName.var or this.var. Default-initialized (0, false, null).",
            "useCases": [
                "Constants",
                "Counters"
            ],
            "realTimeUseCases": [
                "Configuration values"
            ]
        },
        {
            "id": 70,
            "name": "Static methods",
            "question": "What are static methods?",
            "answer": "Static methods are class-level, no implicit 'this', cannot access instance members, called via ClassName.method(). Useful for utility functions (Math.sqrt, Arrays.sort).",
            "useCases": [
                "Utilities",
                "Helper methods"
            ],
            "realTimeUseCases": [
                "Formatter.parse(), StringUtils.isEmpty()"
            ]
        },
        {
            "id": 71,
            "name": "Static block",
            "question": "What is a static block?",
            "answer": "Static block (static { ... }) executes once when class is loaded, before any object creation or static method calls. Used for static variable initialization, loading resources.",
            "useCases": [
                "Class initialization",
                "Resource loading"
            ],
            "realTimeUseCases": [
                "Database driver loading (Class.forName())"
            ]
        },
        {
            "id": 72,
            "name": "When static blocks executed",
            "question": "When are static blocks executed?",
            "answer": "Static blocks execute when class is loaded by ClassLoader, before main() runs, before any object instantiation, in order of appearance in source. Once per class per JVM session.",
            "useCases": [
                "Initialization order",
                "Startup"
            ],
            "realTimeUseCases": [
                "Driver registration, config loading"
            ]
        },
        {
            "id": 73,
            "name": "Why main is static",
            "question": "Why main() method is static?",
            "answer": "main() is static so JVM can call it without instantiating the class: JVM.main(...). Allows program entry point without creating object first. Convention for app startup.",
            "useCases": [
                "Program entry point",
                "Startup"
            ],
            "realTimeUseCases": [
                "All Java applications"
            ]
        },
        {
            "id": 74,
            "name": "Static method limitations",
            "question": "What cannot be done inside a static method?",
            "answer": "Static methods cannot: access non-static variables, call non-static methods (no implicit this), use 'this' or 'super' keywords. Can only access static members and parameters.",
            "useCases": [
                "Scope understanding",
                "Design"
            ],
            "realTimeUseCases": [
                "Avoiding common errors"
            ]
        },
        {
            "id": 75,
            "name": "Access instance variables from static",
            "question": "Can we access instance variables inside static context?",
            "answer": "No, static methods cannot access instance variables directly (no 'this'). Workaround: pass object as parameter, or use class.getInstanceVariable() via reflection.",
            "useCases": [
                "Scope rules",
                "Design"
            ],
            "realTimeUseCases": [
                "Avoiding compilation errors"
            ]
        },
        {
            "id": 76,
            "name": "Can class be static",
            "question": "Can a class be static in Java?",
            "answer": "Only inner classes can be static (nested static classes). Top-level classes cannot be static. Static inner class: no implicit reference to outer instance, accessed via OuterClass.InnerClass.",
            "useCases": [
                "Nested classes",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Builder pattern (static inner class)"
            ]
        },
        {
            "id": 77,
            "name": "Static vs non-static members",
            "question": "Difference between static and non-static members?",
            "answer": "Static: class-level, shared by all instances, no 'this', accessed via ClassName.member. Non-static: instance-level, per-object, has 'this', accessed via object.member.",
            "useCases": [
                "Scope understanding",
                "Design patterns"
            ],
            "realTimeUseCases": [
                "Utility methods vs object properties"
            ]
        },
        {
            "id": 78,
            "name": "Final keyword",
            "question": "What is the use of the final keyword?",
            "answer": "final: on variables (immutable after assignment), methods (cannot override), classes (cannot extend). Enables optimizations, enforces design constraints.",
            "useCases": [
                "Immutability",
                "Design",
                "Performance"
            ],
            "realTimeUseCases": [
                "Constants, String class immutability"
            ]
        },
        {
            "id": 79,
            "name": "Transient keyword",
            "question": "What is the use of the transient keyword?",
            "answer": "transient: marks instance variable to exclude from serialization. Serialization skips transient fields (set to default values on deserialization). Used for non-persistent data.",
            "useCases": [
                "Serialization control",
                "Privacy"
            ],
            "realTimeUseCases": [
                "Excluding passwords from serialization"
            ]
        },
        {
            "id": 80,
            "name": "Volatile keyword",
            "question": "What is the use of the volatile keyword?",
            "answer": "volatile: ensures thread visibility of variable changes across threads. Prevents compiler optimizations, forces reads from main memory. Use for shared mutable state in multithreaded code.",
            "useCases": [
                "Multithreading",
                "Visibility"
            ],
            "realTimeUseCases": [
                "Shutdown flags, config updates"
            ]
        },
        {
            "id": 81,
            "name": "Super keyword",
            "question": "What is the use of the super keyword?",
            "answer": "super: accesses parent class members (variables, methods, constructor). super.method() calls parent method, super() calls parent constructor. Enables inheritance chain access.",
            "useCases": [
                "Inheritance",
                "Method overriding"
            ],
            "realTimeUseCases": [
                "Calling parent constructor"
            ]
        },
        {
            "id": 82,
            "name": "This keyword",
            "question": "What is the use of the this keyword?",
            "answer": "this: refers to current object, clarifies instance variables vs local variables, calls other constructors (this()), passes object to methods. Essential in constructors, setters.",
            "useCases": [
                "Disambiguation",
                "Constructor chaining"
            ],
            "realTimeUseCases": [
                "Setters: this.name = name"
            ]
        },
        {
            "id": 83,
            "name": "Return keyword",
            "question": "What is the use of the return keyword?",
            "answer": "return: exits method, optionally returns value. Type must match method return type. Can appear multiple times (conditional returns). void methods use bare return.",
            "useCases": [
                "Control flow",
                "Value return"
            ],
            "realTimeUseCases": [
                "Early returns on conditions"
            ]
        },
        {
            "id": 84,
            "name": "Break and continue keywords",
            "question": "What is the use of the break and continue keywords?",
            "answer": "break: exits loop or switch block, jumps to next statement. continue: skips current iteration, jumps to next. break with label exits outer loop. Used for flow control.",
            "useCases": [
                "Loop control",
                "Early termination"
            ],
            "realTimeUseCases": [
                "Exiting search loop when found"
            ]
        },
        {
            "id": 85,
            "name": "Package in Java",
            "question": "What is a package in Java?",
            "answer": "Package: namespace organizing related classes, hierarchical naming (com.company.project). Prevents name collisions, controls access (package-private), supports modularity.",
            "useCases": [
                "Organization",
                "Access control"
            ],
            "realTimeUseCases": [
                "com.example.ecommerce.model"
            ]
        },
        {
            "id": 86,
            "name": "Why packages used",
            "question": "Why packages are used?",
            "answer": "Packages: organize code logically, prevent naming conflicts, enable access control, support modularity, match directory structure (convention), improve code reusability.",
            "useCases": [
                "Code organization",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Separating models, services, controllers"
            ]
        },
        {
            "id": 87,
            "name": "Default package",
            "question": "What is the default package?",
            "answer": "Default package: classes without package declaration, unnamed package. Used only for simple scripts. Not recommended for projects: no namespacing, limited access control.",
            "useCases": [
                "Simple programs",
                "Learning"
            ],
            "realTimeUseCases": [
                "Rarely used in production"
            ]
        },
        {
            "id": 88,
            "name": "Import statements difference",
            "question": "What is the difference between import package.* and import package.ClassName?",
            "answer": "import package.*: imports all public classes from package (used for convenience). import package.ClassName: imports single class (explicit, no ambiguity). Both load class on first use.",
            "useCases": [
                "Code organization",
                "Clarity"
            ],
            "realTimeUseCases": [
                "import java.util.*; or import java.util.ArrayList;"
            ]
        },
        {
            "id": 89,
            "name": "Classpath works internally",
            "question": "How classpath works internally?",
            "answer": "Classpath: list of directories/JARs where ClassLoader searches for .class files. Can set via CLASSPATH env var, -cp flag, or .jar manifest. Searched in order; first match wins.",
            "useCases": [
                "Class loading",
                "Deployment"
            ],
            "realTimeUseCases": [
                "java -cp lib/*:src Main"
            ]
        },
        {
            "id": 90,
            "name": "Java compilation",
            "question": "What happens when we compile a Java program?",
            "answer": "Compiler (javac): parses source (.java), performs semantic analysis, generates bytecode (.class), writes to .class files. Each .java can have multiple classes; each gets own .class.",
            "useCases": [
                "Build process",
                "Understanding compilation"
            ],
            "realTimeUseCases": [
                "javac MyProgram.java"
            ]
        },
        {
            "id": 91,
            "name": "Java program execution",
            "question": "What happens when we run a Java program?",
            "answer": "JVM: loads .class file, classloader loads referenced classes, bytecode verifier checks .class, JIT compiles bytecode to native code, executes. GC reclaims memory. Program terminates on exit.",
            "useCases": [
                "Execution flow",
                "Understanding JVM"
            ],
            "realTimeUseCases": [
                "java MyProgram"
            ]
        },
        {
            "id": 92,
            "name": "Javac",
            "question": "What is javac?",
            "answer": "javac is the Java source code compiler, part of JDK. Converts .java source files to .class bytecode files. Syntax: javac MyProgram.java or javac -cp ... -d out src/*.java",
            "useCases": [
                "Compilation",
                "Build tools"
            ],
            "realTimeUseCases": [
                "javac in build scripts, Maven, Gradle"
            ]
        },
        {
            "id": 93,
            "name": "Java command",
            "question": "What is java command?",
            "answer": "java command: executes compiled Java program. Syntax: java ClassName (loads ClassName.class) or java -cp ... -jar app.jar. JVM launcher that starts the runtime.",
            "useCases": [
                "Program execution",
                "Deployment"
            ],
            "realTimeUseCases": [
                "java -Xmx512m MyApp"
            ]
        },
        {
            "id": 94,
            "name": "Main method purpose",
            "question": "What is the purpose of main(String[] args)?",
            "answer": "main(): entry point for JVM to start program execution. Must be public static void. String[] args: command-line arguments passed to program.",
            "useCases": [
                "Program entry",
                "Command-line apps"
            ],
            "realTimeUseCases": [
                "public static void main(String[] args)"
            ]
        },
        {
            "id": 95,
            "name": "Why main argument is String array",
            "question": "Why main method argument is String array?",
            "answer": "String[] args: holds command-line arguments as strings. Array allows variable number of arguments. Example: java MyApp arg1 arg2 â†’ args = [\"arg1\", \"arg2\"]",
            "useCases": [
                "CLI parameters",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "java MyApp --port 8080 --debug"
            ]
        },
        {
            "id": 96,
            "name": "Wrapper classes",
            "question": "What are Wrapper classes?",
            "answer": "Wrapper classes: object versions of primitives (Integer, Double, Boolean, etc.). Extend Number, immutable, provide methods. Enable primitives in collections (List<Integer>).",
            "useCases": [
                "Collections support",
                "Type flexibility"
            ],
            "realTimeUseCases": [
                "List<Integer> numbers"
            ]
        },
        {
            "id": 97,
            "name": "Why wrapper classes needed",
            "question": "Why wrapper classes are needed in Java?",
            "answer": "Wrappers bridge primitives and OOP: enable primitives in generics (List<Integer>), provide utility methods (Integer.parseInt, Double.isNaN), offer null capability (Integer vs int).",
            "useCases": [
                "Collections",
                "Null handling"
            ],
            "realTimeUseCases": [
                "Map<String, Integer> caching values"
            ]
        },
        {
            "id": 98,
            "name": "Autoboxing",
            "question": "What is autoboxing?",
            "answer": "Autoboxing: automatic conversion of primitive to wrapper (intâ†’Integer). JVM calls Integer.valueOf(). Enables: int x = 5; Integer y = x; List<Integer> list = new ArrayList<>(); list.add(5);",
            "useCases": [
                "Convenience",
                "Generics"
            ],
            "realTimeUseCases": [
                "Adding primitives to collections"
            ]
        },
        {
            "id": 99,
            "name": "Unboxing",
            "question": "What is unboxing?",
            "answer": "Unboxing: automatic conversion of wrapper to primitive (Integerâ†’int). JVM calls Integer.intValue(). Enables: Integer x = 5; int y = x; Throws NullPointerException if wrapper is null.",
            "useCases": [
                "Convenience",
                "Arithmetic"
            ],
            "realTimeUseCases": [
                "Extracting int from Integer"
            ]
        },
        {
            "id": 100,
            "name": "Why wrapper immutable",
            "question": "Why wrapper objects are immutable?",
            "answer": "Wrappers are immutable: thread-safe, can be cached, hashable (safe for HashMap keys), predictable behavior. Once created, value cannot change. Ensures reliability in collections.",
            "useCases": [
                "Thread safety",
                "Caching"
            ],
            "realTimeUseCases": [
                "Using Integer in HashMap keys"
            ]
        },
        {
            "id": 101,
            "name": "Enum in Java",
            "question": "What is enum in Java?",
            "answer": "Enum: type-safe constant set, implicitly extends Enum, can have fields/methods, singletons per value. Declared: enum Color { RED, GREEN, BLUE; }. Access: Color.RED.",
            "useCases": [
                "Constants",
                "Type safety"
            ],
            "realTimeUseCases": [
                "Status = ACTIVE, INACTIVE, PENDING"
            ]
        },
        {
            "id": 102,
            "name": "Why enum used",
            "question": "Why enum is used?",
            "answer": "Enums: type-safe (no string magic), singleton per value (only one RED instance), exhaustive switch cases, self-documenting, enable static imports (import static Color.RED).",
            "useCases": [
                "Type safety",
                "Clarity"
            ],
            "realTimeUseCases": [
                "OrderStatus.PENDING, PaymentMethod.CARD"
            ]
        },
        {
            "id": 103,
            "name": "Enums in memory",
            "question": "How enums are stored in memory?",
            "answer": "Enums: static instances in Method Area (one per value), accessible via name array. Each enum value is singleton. Loaded once at class load time. Safe across threads.",
            "useCases": [
                "Memory layout",
                "Performance"
            ],
            "realTimeUseCases": [
                "Single instance per enum constant"
            ]
        },
        {
            "id": 104,
            "name": "JAR vs WAR",
            "question": "What is the difference between JAR and WAR files?",
            "answer": "JAR (Java Archive): packages classes/resources, standalone executable or library. WAR (Web Archive): packages web app (servlets, JSPs, web.xml), deploys to servlet containers (Tomcat).",
            "useCases": [
                "Packaging",
                "Deployment"
            ],
            "realTimeUseCases": [
                "app.jar as service, app.war in Tomcat"
            ]
        },
        {
            "id": 105,
            "name": "Marker interface",
            "question": "What is a marker interface?",
            "answer": "Marker interface: interface with no methods (empty). Marks class for special treatment (e.g., Serializable, Cloneable). Used for compile-time checks and runtime behavior hints.",
            "useCases": [
                "Type checking",
                "Semantics"
            ],
            "realTimeUseCases": [
                "instanceof Serializable before serialization"
            ]
        },
        {
            "id": 106,
            "name": "Access Modifiers",
            "question": "What are Access Modifiers in Java?",
            "answer": "Access modifiers: public (all), protected (subclass/package), default/package-private (package), private (class only). Control visibility/encapsulation.",
            "useCases": [
                "Encapsulation",
                "API design"
            ],
            "realTimeUseCases": [
                "All classes"
            ]
        },
        {
            "id": 107,
            "name": "Why Access Modifiers needed",
            "question": "Why Access Modifiers are needed in Java?",
            "answer": "Modifiers: enforce encapsulation, hide implementation, control API surface, prevent misuse, support inheritance levels. Essential for maintainable, secure code.",
            "useCases": [
                "Encapsulation",
                "Design"
            ],
            "realTimeUseCases": [
                "private fields with public getters"
            ]
        },
        {
            "id": 108,
            "name": "Types of Access Modifiers",
            "question": "What are the types of Access Modifiers in Java?",
            "answer": "Modifiers: public (visible everywhere), private (class only), protected (class + subclass + package), default (package only). Applied to classes, methods, variables.",
            "useCases": [
                "Visibility control",
                "API design"
            ],
            "realTimeUseCases": [
                "public methods, private fields"
            ]
        },
        {
            "id": 109,
            "name": "Access Modifiers vs Specifiers",
            "question": "What is the difference between Access Modifiers and Access Specifiers?",
            "answer": "Same thing: both terms refer to public, private, protected, default. Modifiers is standard Java terminology. Specifiers is alternative (less common) term.",
            "useCases": [
                "Terminology",
                "Understanding"
            ],
            "realTimeUseCases": [
                "Interview discussions"
            ]
        },
        {
            "id": 110,
            "name": "Why different access levels",
            "question": "Why does Java provide different access levels?",
            "answer": "Levels enable: encapsulation (hide internals), API design (expose only needed), inheritance flexibility (protected for subclasses), package cohesion (default), security.",
            "useCases": [
                "Design",
                "Security"
            ],
            "realTimeUseCases": [
                "Library design with public API, private implementation"
            ]
        },
        {
            "id": 111,
            "name": "Default access modifier",
            "question": "What is default access modifier in Java?",
            "answer": "Default (package-private): no keyword, visible within package only. Used when access modifier omitted. Enables package-level encapsulation without public exposure.",
            "useCases": [
                "Package cohesion",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Internal helper classes"
            ]
        },
        {
            "id": 112,
            "name": "Public access modifier",
            "question": "What is the public access modifier?",
            "answer": "public: visible everywhere (all classes, all packages). Used for API, public methods, public classes. Most permissive. Care needed: hard to change, affects all consumers.",
            "useCases": [
                "API design",
                "Exposure"
            ],
            "realTimeUseCases": [
                "public methods in service classes"
            ]
        },
        {
            "id": 113,
            "name": "Private access modifier",
            "question": "What is the private access modifier?",
            "answer": "private: visible only within same class. Used for internal state, helper methods, data. Most restrictive. Enables full encapsulation, implementation hiding.",
            "useCases": [
                "Encapsulation",
                "Data hiding"
            ],
            "realTimeUseCases": [
                "private fields, private helper methods"
            ]
        },
        {
            "id": 114,
            "name": "Protected access modifier",
            "question": "What is the protected access modifier?",
            "answer": "protected: visible within class, subclasses, package. Enables inheritance flexibility. Used in frameworks/libraries for extension points. Less restrictive than private, more than default.",
            "useCases": [
                "Inheritance",
                "Framework design"
            ],
            "realTimeUseCases": [
                "protected methods in abstract base classes"
            ]
        },
        {
            "id": 115,
            "name": "Default package-private access",
            "question": "What is the default (package-private) access modifier?",
            "answer": "Default (no keyword): visible within package, hidden from other packages. Enables internal package structure, intermediate visibility. Common for cohesive packages.",
            "useCases": [
                "Package encapsulation",
                "Design"
            ],
            "realTimeUseCases": [
                "com.company.payment.internal classes"
            ]
        },
        {
            "id": 116,
            "name": "Visibility scope",
            "question": "What is the visibility scope of public, private, protected, default?",
            "answer": "public: all; protected: class + subclass + package; default: package only; private: class only. Scope increases: private < default < protected < public.",
            "useCases": [
                "Access control",
                "Design"
            ],
            "realTimeUseCases": [
                "Choosing modifier per requirement"
            ]
        },
        {
            "id": 117,
            "name": "Why private methods no access outside",
            "question": "Why private methods cannot be accessed outside the class?",
            "answer": "private: encapsulation guarantee. Class controls internal implementation, prevents external misuse, allows safe refactoring. Supports information hiding principle.",
            "useCases": [
                "Encapsulation",
                "Implementation hiding"
            ],
            "realTimeUseCases": [
                "Private helper method refactoring safe"
            ]
        },
        {
            "id": 118,
            "name": "Can private methods be inherited",
            "question": "Can private methods be inherited?",
            "answer": "No, private members not inherited. Subclass does not have access to parent's private methods. Subclass can declare own method with same name (shadowing, not overriding).",
            "useCases": [
                "Inheritance rules",
                "Encapsulation"
            ],
            "realTimeUseCases": [
                "Private methods not part of contract"
            ]
        },
        {
            "id": 119,
            "name": "Why protected for subclasses",
            "question": "Why protected allows access to subclasses?",
            "answer": "protected: intentional extension point. Allows subclasses to customize behavior via overriding. Enables template method pattern, factory patterns, safe inheritance hierarchy.",
            "useCases": [
                "Framework design",
                "Extension"
            ],
            "realTimeUseCases": [
                "HttpServlet.doGet() as protected extension point"
            ]
        },
        {
            "id": 120,
            "name": "Highest visibility modifier",
            "question": "Which modifier has the highest visibility?",
            "answer": "public has highest visibility (visible everywhere, all packages, all classes). Most permissive, affects widest audience.",
            "useCases": [
                "API design",
                "Scope understanding"
            ],
            "realTimeUseCases": [
                "Public library API"
            ]
        },
        {
            "id": 121,
            "name": "Least visibility modifier",
            "question": "Which modifier has the least visibility?",
            "answer": "private has least visibility (class only, not even package). Most restrictive, full encapsulation.",
            "useCases": [
                "Encapsulation",
                "Data hiding"
            ],
            "realTimeUseCases": [
                "Private instance variables"
            ]
        },
        {
            "id": 122,
            "name": "OOPs in Java",
            "question": "What is OOPs in Java?",
            "answer": "OOP (Object-Oriented Programming): paradigm organizing code around objects (data + behavior), using classes as blueprints. Enables modularity, reusability, maintainability.",
            "useCases": [
                "Programming model",
                "Design"
            ],
            "realTimeUseCases": [
                "All Java applications"
            ]
        },
        {
            "id": 123,
            "name": "Why use OOPs",
            "question": "Why do we use OOPs?",
            "answer": "OOP: models real-world entities, encapsulates data/behavior, promotes code reuse via inheritance, enables flexible design via polymorphism, improves maintainability.",
            "useCases": [
                "Code organization",
                "Design"
            ],
            "realTimeUseCases": [
                "Modeling eCommerce domain"
            ]
        },
        {
            "id": 124,
            "name": "Problems OOP solves",
            "question": "What problems does OOP solve?",
            "answer": "OOP solves: code reuse (inheritance), flexibility (polymorphism), encapsulation (data hiding), modularity (objects), maintainability (clear structure). Avoids spaghetti code of procedural paradigm.",
            "useCases": [
                "Design paradigm",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Enterprise application design"
            ]
        },
        {
            "id": 125,
            "name": "Four pillars of OOPs",
            "question": "What are the four pillars/principles of OOPs?",
            "answer": "Four pillars: Encapsulation (data hiding), Inheritance (code reuse), Polymorphism (flexibility), Abstraction (interface). Some add Modularity. Together they form OOP foundation.",
            "useCases": [
                "OOP fundamentals",
                "Design"
            ],
            "realTimeUseCases": [
                "All OOP code"
            ]
        },
        {
            "id": 126,
            "name": "Benefits of OOPs",
            "question": "What are the benefits of using OOPs in real-time applications?",
            "answer": "Benefits: code reuse (DRY), maintainability (clear structure), scalability (modularity), flexibility (polymorphism), safety (encapsulation), collaboration (clear interfaces).",
            "useCases": [
                "Architecture",
                "Project planning"
            ],
            "realTimeUseCases": [
                "Large enterprise systems"
            ]
        },
        {
            "id": 127,
            "name": "Procedural vs OOP",
            "question": "What is the difference between procedural programming and object-oriented programming?",
            "answer": "Procedural: functions, step-by-step logic, data separate from functions. OOP: objects, data + methods together, models entities, reusable components, easier maintenance.",
            "useCases": [
                "Programming paradigms",
                "Design"
            ],
            "realTimeUseCases": [
                "Legacy C vs modern Java"
            ]
        },
        {
            "id": 128,
            "name": "When to use OOPs",
            "question": "When should we use OOPs in real-time projects?",
            "answer": "Use OOP: complex systems, long-term projects, team development, frequent changes, domain modeling. Not needed for simple scripts or one-time tasks.",
            "useCases": [
                "Project planning",
                "Design"
            ],
            "realTimeUseCases": [
                "Enterprise apps, NOT simple utilities"
            ]
        },
        {
            "id": 129,
            "name": "Class in Java",
            "question": "What is a Class in Java?",
            "answer": "Class: blueprint for objects, defines attributes (fields) and behaviors (methods). Declares structure and logic. Objects are instances. Syntax: class ClassName { }",
            "useCases": [
                "OOP foundation",
                "Data structure"
            ],
            "realTimeUseCases": [
                "public class User { private String name; }"
            ]
        },
        {
            "id": 130,
            "name": "Class syntax",
            "question": "What is the syntax of a class?",
            "answer": "Syntax: [access] [abstract] class ClassName [extends Parent] [implements Interface] { fields; methods; constructors; }. Fields: state. Methods: behavior.",
            "useCases": [
                "Code structure",
                "Definition"
            ],
            "realTimeUseCases": [
                "public class Product extends Item { }"
            ]
        },
        {
            "id": 131,
            "name": "Why use class",
            "question": "Why do we use a class in Java?",
            "answer": "Classes: organize code, bundle related data/methods, create reusable blueprints, enable polymorphism, support inheritance, encapsulate logic. Fundamental to OOP.",
            "useCases": [
                "Organization",
                "Reusability"
            ],
            "realTimeUseCases": [
                "Domain models: User, Order, Payment"
            ]
        },
        {
            "id": 132,
            "name": "When to use class",
            "question": "When to use a class in real-time?",
            "answer": "Use class: model entities (User, Order), group related methods, share common behavior (inheritance), encapsulate state. Use whenever you need structured data + behavior.",
            "useCases": [
                "Design decisions",
                "Architecture"
            ],
            "realTimeUseCases": [
                "eCommerce: Product class"
            ]
        },
        {
            "id": 133,
            "name": "Object in Java",
            "question": "What is an Object in Java?",
            "answer": "Object: instance of a class, occupies memory at runtime. Contains state (field values) and behavior (methods). Created with 'new', garbage collected when unreachable.",
            "useCases": [
                "Runtime entities",
                "Memory model"
            ],
            "realTimeUseCases": [
                "User user = new User();"
            ]
        },
        {
            "id": 134,
            "name": "Why create objects",
            "question": "Why do we create objects?",
            "answer": "Objects: represent real-world entities, hold state, perform actions, are passed between methods, stored in collections. Essential for modeling and solving problems.",
            "useCases": [
                "Problem modeling",
                "Data representation"
            ],
            "realTimeUseCases": [
                "Every application"
            ]
        },
        {
            "id": 135,
            "name": "How to create object",
            "question": "How to create an object in Java?",
            "answer": "Syntax: ClassName obj = new ClassName(); Calls constructor, allocates heap memory, initializes fields, returns reference. Objects can also be created via reflection, deserialization.",
            "useCases": [
                "Instantiation",
                "Initialization"
            ],
            "realTimeUseCases": [
                "User user = new User(\"John\");"
            ]
        },
        {
            "id": 136,
            "name": "Object creation internally",
            "question": "What happens internally when an object is created?",
            "answer": "Creation steps: memory allocated on heap, field default values set, constructor called (field initialization, parent constructor), object reference returned. New object fully initialized.",
            "useCases": [
                "Memory model",
                "Understanding JVM"
            ],
            "realTimeUseCases": [
                "Understanding new operator"
            ]
        },
        {
            "id": 137,
            "name": "Can create instance of normal class",
            "question": "Can we create an instance of a normal class? Why?",
            "answer": "Yes, normal (concrete) classes can be instantiated. Have concrete implementations of all methods. Non-abstract, fully defined. ClassName obj = new ClassName();",
            "useCases": [
                "Instantiation",
                "Concrete classes"
            ],
            "realTimeUseCases": [
                "public class User { } â†’ User u = new User();"
            ]
        },
        {
            "id": 138,
            "name": "Can create instance of abstract class",
            "question": "Can we create an instance of an abstract class? Why not?",
            "answer": "No, abstract classes cannot be instantiated. Marked abstract, may have abstract methods without implementation. Must subclass and provide implementations before instantiation.",
            "useCases": [
                "Design pattern",
                "Inheritance"
            ],
            "realTimeUseCases": [
                "abstract class PaymentGateway { ... }; class Stripe extends PaymentGateway { }"
            ]
        },
        {
            "id": 139,
            "name": "Can create instance of interface",
            "question": "Can we create an instance of an interface? Why not?",
            "answer": "No, interfaces cannot be instantiated (abstract types, no implementation). Must implement via concrete class: class MyImpl implements MyInterface { }. Then instantiate implementation.",
            "useCases": [
                "Design pattern",
                "Polymorphism"
            ],
            "realTimeUseCases": [
                "interface List; ArrayList implements List"
            ]
        },
        {
            "id": 140,
            "name": "Access interface methods",
            "question": "How do we access interface methods if we cannot create an object of it?",
            "answer": "Via implementation: interface Payment { void pay(); } class Card implements Payment { void pay() {...} } Access: Payment p = new Card(); p.pay();",
            "useCases": [
                "Polymorphism",
                "Loose coupling"
            ],
            "realTimeUseCases": [
                "Using List list = new ArrayList();"
            ]
        },
        {
            "id": 141,
            "name": "Create objects via anonymous classes",
            "question": "Can we create objects through anonymous classes?",
            "answer": "Yes, anonymous classes: inline class implementation without name. Syntax: new Interface() { @Override method() { } }. Common for listeners, callbacks. Compiles to separate .class file.",
            "useCases": [
                "Quick implementations",
                "Callbacks"
            ],
            "realTimeUseCases": [
                "button.setOnClickListener(new OnClickListener() { ... })"
            ]
        },
        {
            "id": 142,
            "name": "Concrete Class",
            "question": "What is a Concrete Class?",
            "answer": "Concrete class: normal class with complete implementation (not abstract), can be instantiated directly. Has concrete methods (no abstract). Every Java application needs at least one concrete class.",
            "useCases": [
                "Instantiation",
                "Implementation"
            ],
            "realTimeUseCases": [
                "public class User { ... }"
            ]
        },
        {
            "id": 143,
            "name": "Concrete class syntax",
            "question": "What is the syntax of a concrete class?",
            "answer": "Syntax: [public] class ClassName { private fields; public methods; constructors; } All methods have bodies (implementation). Can extend/implement other types.",
            "useCases": [
                "Class definition",
                "Structure"
            ],
            "realTimeUseCases": [
                "public class Product { private String name; public String getName() { ... } }"
            ]
        },
        {
            "id": 144,
            "name": "Why use concrete classes",
            "question": "Why do we use concrete classes?",
            "answer": "Concrete: model actual entities, provide complete functionality, can be instantiated, simple and straightforward. Essential for representing real-world things.",
            "useCases": [
                "Entity modeling",
                "Implementation"
            ],
            "realTimeUseCases": [
                "User, Order, Product classes"
            ]
        },
        {
            "id": 145,
            "name": "When to use concrete class",
            "question": "When should we use a concrete class?",
            "answer": "Use concrete: when you need complete, usable entity (User, Product). Don't use when behavior is variable (use abstract/interface). Balance: not every class should be abstract.",
            "useCases": [
                "Design decisions",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Most application classes are concrete"
            ]
        },
        {
            "id": 146,
            "name": "Real-time use of concrete class",
            "question": "What are the real-time use cases of concrete classes?",
            "answer": "Concrete classes: domain models (User, Order), services (UserService), utilities (StringUtils), DTOs (UserDTO), configuration (AppConfig). Core building blocks.",
            "useCases": [
                "Application structure",
                "Architecture"
            ],
            "realTimeUseCases": [
                "eCommerce: Product, Cart, Order, Payment"
            ]
        },
        {
            "id": 147,
            "name": "Abstract and interface with concrete",
            "question": "Even when abstract class and interface exist, why do we still use concrete classes?",
            "answer": "Concrete classes: provide complete, instantiable implementations for actual entities. Abstract/interface define contracts. Concrete implements both, represents real domain objects.",
            "useCases": [
                "Layering",
                "Design"
            ],
            "realTimeUseCases": [
                "interface PaymentService, abstract PaymentGateway, concrete StripePayment"
            ]
        },
        {
            "id": 148,
            "name": "Concrete class in eCommerce",
            "question": "In which scenario did you use a concrete class in your NMG eCommerce project?",
            "answer": "Example: class Product { fields: id, name, price; methods: getPrice(), applyDiscount() }. Directly used in cart, order processing. Instantiated and manipulated throughout app.",
            "useCases": [
                "Project experience",
                "Domain modeling"
            ],
            "realTimeUseCases": [
                "Product p = new Product(\"Laptop\", 50000);"
            ]
        },
        {
            "id": 149,
            "name": "Real-time eCommerce example concrete",
            "question": "Give a simple real-time eCommerce example where you used a concrete class (Product, CartItem, User, etc.).",
            "answer": "Example: class CartItem { Product product; int quantity; double total; getTotalPrice() { return product.getPrice() * quantity; } }. Concrete, used in Cart, persisted to DB.",
            "useCases": [
                "Real-world modeling",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Shopping cart implementation"
            ]
        },
        {
            "id": 150,
            "name": "Encapsulation",
            "question": "What is Encapsulation in Java?",
            "answer": "Encapsulation: bundling data (fields) + methods together, hiding internal state (private), exposing behavior via public interface. Protects invariants, enables safe changes.",
            "useCases": [
                "Data hiding",
                "Safety"
            ],
            "realTimeUseCases": [
                "private fields with public getters/setters"
            ]
        },
        {
            "id": 151,
            "name": "Why encapsulation",
            "question": "Why do we use encapsulation?",
            "answer": "Encapsulation: hides complexity, prevents invalid states, enables refactoring internals safely, controls access, enforces business rules. Essential for maintainable code.",
            "useCases": [
                "Data protection",
                "API design"
            ],
            "realTimeUseCases": [
                "Preventing direct field modification"
            ]
        },
        {
            "id": 152,
            "name": "Problems encapsulation solves",
            "question": "What problems does encapsulation solve?",
            "answer": "Encapsulation solves: uncontrolled access (via private), invalid states (via validation in setters), tight coupling (hide implementation), fragile code (refactor safely).",
            "useCases": [
                "Code quality",
                "Maintenance"
            ],
            "realTimeUseCases": [
                "Changing internal logic without API change"
            ]
        },
        {
            "id": 153,
            "name": "Encapsulation syntax",
            "question": "What is the syntax of encapsulation (getters/setters)?",
            "answer": "Syntax: private Type field; public Type getField() { return field; } public void setField(Type value) { validate(value); this.field = value; } Protects field, enables logic.",
            "useCases": [
                "Property access",
                "Validation"
            ],
            "realTimeUseCases": [
                "private int age; public void setAge(int a) { if (a > 0) this.age = a; }"
            ]
        },
        {
            "id": 154,
            "name": "How to implement encapsulation",
            "question": "How do we implement encapsulation in Java?",
            "answer": "Steps: declare fields private, provide public getters/setters, add validation in setters, use access modifiers (private/public), document API. Tools: Lombok @Getter @Setter.",
            "useCases": [
                "Implementation pattern",
                "Code generation"
            ],
            "realTimeUseCases": [
                "IDE: Alt+Insert to generate getters/setters"
            ]
        },
        {
            "id": 155,
            "name": "Use abstract vs interface vs class for encapsulation",
            "question": "To implement encapsulation, should we use a class or abstract class or interface?",
            "answer": "Class: encapsulates concrete data/behavior. Abstract/Interface: define contracts, encapsulate behavior. Use concrete class for entities with state. Abstract for partial implementations.",
            "useCases": [
                "Architecture",
                "Design"
            ],
            "realTimeUseCases": [
                "class User (concrete), interface PaymentService (contract)"
            ]
        },
        {
            "id": 156,
            "name": "When to use encapsulation",
            "question": "When should we use encapsulation?",
            "answer": "Always: any class with mutable state should encapsulate. Hide fields, control access. Essential for data integrity, security, maintainability.",
            "useCases": [
                "Best practice",
                "Always"
            ],
            "realTimeUseCases": [
                "Every domain class"
            ]
        },
        {
            "id": 157,
            "name": "eCommerce encapsulation example",
            "question": "Real-time eCommerce example of encapsulation (User, Cart, Payment classes).",
            "answer": "Example: class User { private String email; private double balance; public void setBalance(double b) { if (b >= 0) this.balance = b; } } Prevents negative balance.",
            "useCases": [
                "Data validation",
                "State integrity"
            ],
            "realTimeUseCases": [
                "Ensuring valid user state"
            ]
        },
        {
            "id": 158,
            "name": "Encapsulation vs data hiding",
            "question": "What is the difference between encapsulation and data hiding?",
            "answer": "Data hiding: keeping fields private (technical). Encapsulation: bundling data + methods together, controlling access (principle). Encapsulation includes data hiding + behavior.",
            "useCases": [
                "Terminology",
                "Understanding"
            ],
            "realTimeUseCases": [
                "Design concepts"
            ]
        },
        {
            "id": 159,
            "name": "Abstraction",
            "question": "What is Abstraction in Java?",
            "answer": "Abstraction: hiding complex implementation details, exposing only essential interface. Reduces complexity, enables focus on 'what' not 'how'. Via abstract classes, interfaces.",
            "useCases": [
                "Simplification",
                "Interface design"
            ],
            "realTimeUseCases": [
                "List interface abstracts ArrayList, LinkedList"
            ]
        },
        {
            "id": 160,
            "name": "Why abstraction",
            "question": "Why do we use abstraction?",
            "answer": "Abstraction: reduces complexity, defines contracts, enables multiple implementations, decouples interface from implementation, improves code reuse.",
            "useCases": [
                "Design",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "Database abstraction: DAO interface"
            ]
        },
        {
            "id": 161,
            "name": "Problems abstraction solves",
            "question": "What problems does abstraction solve?",
            "answer": "Abstraction solves: tight coupling (loose via interface), complexity (hide details), inflexibility (enable multiple implementations), code understanding (focus on interface).",
            "useCases": [
                "Design pattern",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Swapping database implementations"
            ]
        },
        {
            "id": 162,
            "name": "Abstract class",
            "question": "What is an abstract class?",
            "answer": "Abstract class: class marked 'abstract', may have abstract methods (no body), cannot be instantiated, provides partial implementation. Extended by subclasses to provide full implementation.",
            "useCases": [
                "Partial implementation",
                "Inheritance"
            ],
            "realTimeUseCases": [
                "abstract class PaymentGateway { abstract void pay(); }"
            ]
        },
        {
            "id": 163,
            "name": "Abstract class syntax",
            "question": "What is the syntax of an abstract class?",
            "answer": "Syntax: abstract class ClassName { concrete methods; abstract methodName(); } Abstract methods have no body. Can have constructors, static members. Cannot instantiate.",
            "useCases": [
                "Definition",
                "Structure"
            ],
            "realTimeUseCases": [
                "abstract class Vehicle { abstract void start(); }"
            ]
        },
        {
            "id": 164,
            "name": "When to use abstract class",
            "question": "When should we use an abstract class?",
            "answer": "Use abstract: when multiple classes share common code (inheritance), when some methods are variable (abstract), when you want to define partial contract + provide defaults.",
            "useCases": [
                "Code reuse",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "PaymentGateway abstract for all payment providers"
            ]
        },
        {
            "id": 165,
            "name": "Use cases of abstract classes",
            "question": "What are the use cases of abstract classes in eCommerce?",
            "answer": "Use cases: PaymentGateway (Card, UPI, Wallet extend), Notification (Email, SMS extend), ShippingProvider (Courier, Local extend). Share common code, define variable behavior.",
            "useCases": [
                "Framework design",
                "Extension points"
            ],
            "realTimeUseCases": [
                "Payment processing abstraction"
            ]
        },
        {
            "id": 166,
            "name": "Abstract vs concrete class",
            "question": "What is the difference between abstract class and concrete class?",
            "answer": "Abstract: marked 'abstract', has abstract methods, cannot instantiate, partial implementation. Concrete: complete implementation, can instantiate, represents actual entity.",
            "useCases": [
                "Class types",
                "Inheritance"
            ],
            "realTimeUseCases": [
                "abstract PaymentGateway vs concrete StripePayment"
            ]
        },
        {
            "id": 167,
            "name": "Abstract class vs interface",
            "question": "What is the difference between abstract class and interface?",
            "answer": "Abstract: can have concrete methods, constructors, state (fields), access modifiers. Interface: only contracts (methods), no state (Java 8+ default methods). Use abstract for shared code, interface for contract.",
            "useCases": [
                "Design decision",
                "Architecture"
            ],
            "realTimeUseCases": [
                "abstract class has constructor, interface does not"
            ]
        },
        {
            "id": 168,
            "name": "Cannot instantiate abstract class",
            "question": "Can we create an instance of an abstract class? Why not?",
            "answer": "No. Abstract classes may have abstract methods without implementation. JVM cannot execute unimplemented methods. Must subclass and provide implementations.",
            "useCases": [
                "Design pattern",
                "Enforcement"
            ],
            "realTimeUseCases": [
                "abstract PaymentGateway p = new PaymentGateway(); // ERROR"
            ]
        },
        {
            "id": 169,
            "name": "Where abstraction used in eCommerce",
            "question": "Real-time example where you used abstraction in eCommerce (PaymentGateway, NotificationService, etc.)",
            "answer": "Example: interface PaymentService { void pay(Order o); } class StripePayment implements PaymentService { void pay(Order o) { stripe API call } } Abstracts payment details from Order.",
            "useCases": [
                "Loose coupling",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "Swapping payment providers without Order change"
            ]
        },
        {
            "id": 170,
            "name": "Interface",
            "question": "What is an Interface in Java?",
            "answer": "Interface: 100% abstract type, defines contract (method signatures), no implementation (Java 8+ default methods exception), enable multiple inheritance, enforces implementation.",
            "useCases": [
                "Contract definition",
                "Multiple inheritance"
            ],
            "realTimeUseCases": [
                "interface Serializable, Comparable, List"
            ]
        },
        {
            "id": 171,
            "name": "Interface syntax",
            "question": "What is the syntax of an interface?",
            "answer": "Syntax: [public] interface InterfaceName { methodSignature(); final static Type CONSTANT = value; default void method() { } } Implicitly public, abstract (except default/static).",
            "useCases": [
                "Definition",
                "Contract"
            ],
            "realTimeUseCases": [
                "public interface PaymentGateway { void pay(double amount); }"
            ]
        },
        {
            "id": 172,
            "name": "Why use interfaces",
            "question": "Why do we use interfaces?",
            "answer": "Interfaces: define contracts, enable multiple inheritance (class can implement many), loose coupling, polymorphism, plugin architecture, dependency injection.",
            "useCases": [
                "Design pattern",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "Swappable implementations"
            ]
        },
        {
            "id": 173,
            "name": "Problems interfaces solve",
            "question": "What problems do interfaces solve?",
            "answer": "Interfaces solve: single inheritance limitation (multiple interfaces), tight coupling (interface-based), inflexibility (multiple implementations), testing (mock implementations).",
            "useCases": [
                "Design pattern",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Easy to test with mock implementations"
            ]
        },
        {
            "id": 174,
            "name": "When to choose interface over abstract class",
            "question": "When to choose interface over abstract class?",
            "answer": "Choose interface: when defining pure contract (no shared implementation), need multiple inheritance, loose coupling required. Abstract: shared implementation, constructor, state needed.",
            "useCases": [
                "Design decision",
                "Architecture"
            ],
            "realTimeUseCases": [
                "PaymentService interface, abstract PaymentGateway base"
            ]
        },
        {
            "id": 175,
            "name": "Cannot create object of interface",
            "question": "Can we create an object of an interface? Why not?",
            "answer": "No. Interfaces are contracts without implementation (abstract). JVM cannot execute abstract methods. Must provide implementation via concrete class.",
            "useCases": [
                "Type system",
                "Design"
            ],
            "realTimeUseCases": [
                "interface List l = new ArrayList(); // OK, ArrayList implements"
            ]
        },
        {
            "id": 176,
            "name": "Call interface methods without instance",
            "question": "How do we call interface methods without creating an instance?",
            "answer": "Cannot call directly (no instance). Create implementation: List l = new ArrayList(); l.add(1); Or use static methods: Collections.sort(...). Or default methods in interface.",
            "useCases": [
                "Usage patterns",
                "Static methods"
            ],
            "realTimeUseCases": [
                "java.util.Collections static methods"
            ]
        },
        {
            "id": 177,
            "name": "eCommerce use cases for interfaces",
            "question": "What are real-time eCommerce use cases of interfaces (PaymentService, SMSProvider, etc.)?",
            "answer": "PaymentService: Card, UPI, Wallet. SMSProvider: Twilio, AWS SNS. Notification: Email, SMS. Shipping: Courier, Local. Each interface with multiple implementations.",
            "useCases": [
                "Provider abstraction",
                "Plugin architecture"
            ],
            "realTimeUseCases": [
                "Switching SMS provider without code change"
            ]
        },
        {
            "id": 178,
            "name": "Interface vs class",
            "question": "What is the difference between interface and class?",
            "answer": "Class: concrete type, instantiable, has state/constructors, single inheritance. Interface: contract type, not instantiable, no state/constructors, multiple inheritance, pure abstraction.",
            "useCases": [
                "Type system",
                "Design"
            ],
            "realTimeUseCases": [
                "class User implements Serializable"
            ]
        },
        {
            "id": 179,
            "name": "Interface vs abstract class diff",
            "question": "What is the difference between interface and abstract class?",
            "answer": "Interface: 100% abstract (default), no state/constructors, multiple inheritance. Abstract class: partial (concrete methods allowed), can have state/constructors, single inheritance.",
            "useCases": [
                "Design choice",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Use interface for contract, abstract for shared code"
            ]
        },
        {
            "id": 180,
            "name": "Inheritance",
            "question": "What is Inheritance in Java?",
            "answer": "Inheritance: mechanism for code reuse, child class extends parent, inherits fields/methods, adds/overrides behavior. Syntax: class Child extends Parent { }. Enables IS-A relationship.",
            "useCases": [
                "Code reuse",
                "Specialization"
            ],
            "realTimeUseCases": [
                "class Admin extends User { }"
            ]
        },
        {
            "id": 181,
            "name": "Why inheritance",
            "question": "Why do we use inheritance?",
            "answer": "Inheritance: reuse code (DRY), model relationships (IS-A), enable polymorphism, reduce duplication, create hierarchies. Essential for OOP flexibility.",
            "useCases": [
                "Code reuse",
                "Design"
            ],
            "realTimeUseCases": [
                "Avoiding duplicate code across related classes"
            ]
        },
        {
            "id": 182,
            "name": "Types of inheritance",
            "question": "What are the types of inheritance in Java?",
            "answer": "Single: class extends one class. Multilevel: Aâ†’Bâ†’C chain. Hierarchical: one class extended by many. Multiple (via interface): class implements many. Java doesn't support multiple class inheritance.",
            "useCases": [
                "Hierarchy design",
                "Type system"
            ],
            "realTimeUseCases": [
                "single: Userâ†’Admin, multi-level: Employeeâ†’Managerâ†’Director"
            ]
        },
        {
            "id": 183,
            "name": "Why no multiple inheritance",
            "question": "Why multiple inheritance is not supported in Java?",
            "answer": "Java avoids multiple inheritance (diamond problem): ambiguity if two parents have same method. Solution: interfaces (can implement many) + single class extension. Interfaces solve the problem.",
            "useCases": [
                "Language design",
                "Type safety"
            ],
            "realTimeUseCases": [
                "class Employee implements Comparable, Serializable"
            ]
        },
        {
            "id": 184,
            "name": "IS-A relationship",
            "question": "What is IS-A relationship?",
            "answer": "IS-A: inheritance relationship, 'is a' check. Example: Admin IS-A User, Car IS-A Vehicle. Enables polymorphism, type substitution. Child is type of parent.",
            "useCases": [
                "Type relationship",
                "Polymorphism"
            ],
            "realTimeUseCases": [
                "User user = new Admin(); // IS-A"
            ]
        },
        {
            "id": 185,
            "name": "HAS-A relationship",
            "question": "What is HAS-A relationship?",
            "answer": "HAS-A: composition relationship, 'has a' member. Example: Car HAS-A Engine, User HAS-A Address. Composition over inheritance. More flexible, avoids rigid hierarchies.",
            "useCases": [
                "Composition",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "class User { Address address; } // HAS-A"
            ]
        },
        {
            "id": 186,
            "name": "When to use inheritance",
            "question": "When should we use inheritance?",
            "answer": "Use inheritance: true IS-A relationship exists, child specializes parent, shared behavior (code reuse), need polymorphism. Don't use for unrelated 'has a' (use composition).",
            "useCases": [
                "Design decision",
                "Type relationships"
            ],
            "realTimeUseCases": [
                "Admin extends User (IS-A)"
            ]
        },
        {
            "id": 187,
            "name": "When to avoid inheritance",
            "question": "When should we avoid inheritance?",
            "answer": "Avoid inheritance: weak/false IS-A, just code reuse (use composition), multiple inheritance needed (use interface), tight coupling risk. Prefer composition for flexibility.",
            "useCases": [
                "Design antipattern",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "User should not extend Address (HAS-A)"
            ]
        },
        {
            "id": 188,
            "name": "Inheritance vs composition",
            "question": "What is the difference between inheritance and composition?",
            "answer": "Inheritance: IS-A, extends parent, inherits all behavior. Composition: HAS-A, wraps object, contains member. Composition more flexible, avoids rigid hierarchies. 'Favor composition over inheritance'.",
            "useCases": [
                "Design pattern",
                "Flexibility"
            ],
            "realTimeUseCases": [
                "User EXTENDS Person vs User HAS-A Address"
            ]
        },
        {
            "id": 189,
            "name": "Inheritance in eCommerce",
            "question": "Real-time eCommerce example of inheritance (User â†’ AdminUser, VendorUser).",
            "answer": "Example: class User { id, name, email } class AdminUser extends User { permissions[] } class VendorUser extends User { shop details }. Share common fields/methods.",
            "useCases": [
                "Type hierarchy",
                "Role specialization"
            ],
            "realTimeUseCases": [
                "Different user roles in eCommerce"
            ]
        },
        {
            "id": 190,
            "name": "Polymorphism",
            "question": "What is Polymorphism in Java?",
            "answer": "Polymorphism: many forms, same interface/method name, different implementations. Enables flexibility: use parent type to call child methods. Compile-time (overloading) + runtime (overriding).",
            "useCases": [
                "Flexibility",
                "Code reuse"
            ],
            "realTimeUseCases": [
                "List list = new ArrayList(); // Polymorphic reference"
            ]
        },
        {
            "id": 191,
            "name": "Static polymorphism",
            "question": "What is static (compile-time) polymorphism?",
            "answer": "Compile-time: resolved at compile time via method overloading. Same method name, different parameters (type/count/order). Compiler chooses right method. No runtime overhead.",
            "useCases": [
                "Convenience",
                "Type safety"
            ],
            "realTimeUseCases": [
                "println(int), println(String) â†’ compiler picks"
            ]
        },
        {
            "id": 192,
            "name": "Dynamic polymorphism",
            "question": "What is dynamic (runtime) polymorphism?",
            "answer": "Runtime: resolved at runtime via method overriding. Child overrides parent method. Parent reference calls child method (virtual method call). Enables flexible designs.",
            "useCases": [
                "Flexibility",
                "Design pattern"
            ],
            "realTimeUseCases": [
                "PaymentService payment = new StripePayment(); payment.pay();"
            ]
        },
        {
            "id": 193,
            "name": "Method overloading",
            "question": "What is method overloading?",
            "answer": "Overloading: same method name, different parameters (count, type, order). Compile-time resolution. Improves readability: abs(int), abs(double). Not true polymorphism.",
            "useCases": [
                "Convenience",
                "API consistency"
            ],
            "realTimeUseCases": [
                "Calculator.add(int, int), add(double, double)"
            ]
        },
        {
            "id": 194,
            "name": "Method overriding",
            "question": "What is method overriding?",
            "answer": "Overriding: child class redefines parent method with same signature. Runtime polymorphism. Enables specialization. @Override annotation. Must have IS-A relationship.",
            "useCases": [
                "Specialization",
                "Runtime flexibility"
            ],
            "realTimeUseCases": [
                "class StripePayment extends PaymentGateway { void pay() { ... } }"
            ]
        },
        {
            "id": 195,
            "name": "When to use overloading",
            "question": "When to use method overloading?",
            "answer": "Use overloading: same operation, different input types/counts (Calculator.add). Improves API usability. Don't overload for different logic (use different method names).",
            "useCases": [
                "API design",
                "Consistency"
            ],
            "realTimeUseCases": [
                "Collections.sort(List), sort(List, Comparator)"
            ]
        },
        {
            "id": 196,
            "name": "When to use overriding",
            "question": "When to use method overriding?",
            "answer": "Use overriding: child specializes parent behavior, need polymorphism, IS-A relationship. Enables flexible, extensible designs. Essential for template method pattern.",
            "useCases": [
                "Design pattern",
                "Specialization"
            ],
            "realTimeUseCases": [
                "Different payment methods overriding pay()"
            ]
        },
        {
            "id": 197,
            "name": "Cannot override static methods",
            "question": "Why static methods cannot be overridden?",
            "answer": "Static methods belong to class, not instance. Resolution is compile-time based on reference type, not runtime type. Java allows shadowing (same name, different class), not true overriding.",
            "useCases": [
                "Language design",
                "Understanding"
            ],
            "realTimeUseCases": [
                "Parent.method() vs Child.method() both callable"
            ]
        },
        {
            "id": 198,
            "name": "Cannot override private methods",
            "question": "Why private methods cannot be overridden?",
            "answer": "Private: hidden from subclass, not inherited. Subclass cannot access/override. Can declare same-name method in child (shadowing, not overriding). Breaks contract inheritance.",
            "useCases": [
                "Encapsulation",
                "Inheritance rules"
            ],
            "realTimeUseCases": [
                "Private methods isolated to class"
            ]
        },
        {
            "id": 199,
            "name": "Polymorphism in eCommerce",
            "question": "Real-time eCommerce example of polymorphism (Payment â†’ UPI, Card, Wallet).",
            "answer": "Example: interface Payment { void process(); } class UPI implements Payment { void process() { UPI logic } } class Card implements Payment { void process() { Card logic } } Runtime determines which process() to call based on actual type.",
            "useCases": [
                "Plugin architecture",
                "Multiple implementations"
            ],
            "realTimeUseCases": [
                "Same checkout flow for all payment methods"
            ]
        },
        {
            "id": 200,
            "name": "Constructors",
            "question": "What is a constructor in Java?",
            "answer": "Constructor: special method to initialize objects, same name as class, no return type, called with 'new'. Can have parameters (parameterized) or no params (default). Mandatory for initialization.",
            "useCases": [
                "Object initialization",
                "State setup"
            ],
            "realTimeUseCases": [
                "public User(String name) { this.name = name; }"
            ]
        },
        {
            "id": 201,
            "name": "Why constructors",
            "question": "Why do we use constructors?",
            "answer": "Constructors: initialize object state, ensure valid initial state, accept parameters for flexible creation, support constructor overloading, enforce setup logic.",
            "useCases": [
                "Initialization",
                "Design"
            ],
            "realTimeUseCases": [
                "Every object creation"
            ]
        },
        {
            "id": 202,
            "name": "Types of constructors",
            "question": "What are the types of constructors?",
            "answer": "Default (no params, auto-generated), Parameterized (custom params, initialization), Copy (clone objects). Default generated if none defined. Can overload constructors.",
            "useCases": [
                "Flexibility",
                "Initialization options"
            ],
            "realTimeUseCases": [
                "User() and User(String name)"
            ]
        },
        {
            "id": 203,
            "name": "Constructor overloading",
            "question": "What is constructor overloading?",
            "answer": "Constructor overloading: same name, different parameters. Enables multiple creation ways. Syntax: this(...) to call other constructor (constructor chaining).",
            "useCases": [
                "Flexibility",
                "Convenience"
            ],
            "realTimeUseCases": [
                "User(), User(String name), User(String name, String email)"
            ]
        },
        {
            "id": 204,
            "name": "Purpose of default constructor",
            "question": "What is the purpose of a default constructor?",
            "answer": "Default constructor: no parameters, auto-generated if none defined, initializes fields to defaults (0, false, null). Required for reflection-based creation (JPA, JSON deserialization).",
            "useCases": [
                "Framework compatibility",
                "Initialization"
            ],
            "realTimeUseCases": [
                "JPA entities require default constructor"
            ]
        },
        {
            "id": 205,
            "name": "Why constructors no return type",
            "question": "Why constructors do not have return type?",
            "answer": "Constructors return object itself (implicit), not needed to declare return type. Syntax design: differentiate from methods. Attempting to add return type causes compilation error.",
            "useCases": [
                "Language design",
                "Type safety"
            ],
            "realTimeUseCases": [
                "public User() { } not public User User()"
            ]
        },
        {
            "id": 206,
            "name": "When parameterized constructors",
            "question": "When should we use parameterized constructors?",
            "answer": "Use parameterized: accept essential data for initialization, avoid setters post-creation, enforce immutability (final fields), improve code clarity. Better than default + setters.",
            "useCases": [
                "Best practice",
                "Initialization"
            ],
            "realTimeUseCases": [
                "User(id, name, email) sets all essential fields"
            ]
        },
        {
            "id": 207,
            "name": "Constructors in eCommerce",
            "question": "Real-time example of constructors in eCommerce (Order, CartItem, Product).",
            "answer": "Example: class Order { Order(int id, Date date, List<CartItem> items) { this.id = id; this.date = date; this.items = items; } } Initializes order with all essential data.",
            "useCases": [
                "Initialization",
                "State setup"
            ],
            "realTimeUseCases": [
                "Creating orders in checkout"
            ]
        },
        {
            "id": 208,
            "name": "This keyword OOP",
            "question": "What is the \"this\" keyword?",
            "answer": "this: reference to current object, clarifies field/parameter ambiguity, calls other constructors (this()), passes object reference. Essential in constructors, setters.",
            "useCases": [
                "Disambiguation",
                "Constructor chaining"
            ],
            "realTimeUseCases": [
                "this.name = name; disambiguates parameter"
            ]
        },
        {
            "id": 209,
            "name": "Why use this",
            "question": "Why do we use this keyword?",
            "answer": "this: avoid variable name ambiguity, call other constructors, reference object in callbacks, pass to methods. Improves clarity when field names match parameters.",
            "useCases": [
                "Clarity",
                "Constructor chaining"
            ],
            "realTimeUseCases": [
                "setters with this.field = param"
            ]
        },
        {
            "id": 210,
            "name": "When to use this in constructors",
            "question": "When should we use this keyword in constructors?",
            "answer": "Use this: when parameter name matches field name (this.name = name), call other constructors (this(...)), reference current object. Always use for clarity in constructors.",
            "useCases": [
                "Best practice",
                "Clarity"
            ],
            "realTimeUseCases": [
                "public User(String name) { this.name = name; }"
            ]
        },
        {
            "id": 211,
            "name": "Super keyword OOP",
            "question": "What is the \"super\" keyword?",
            "answer": "super: reference to parent class, access parent methods (super.method()), call parent constructor (super(...)), access parent fields. Enables inheritance access.",
            "useCases": [
                "Inheritance",
                "Parent access"
            ],
            "realTimeUseCases": [
                "super.pay() to call parent implementation"
            ]
        },
        {
            "id": 212,
            "name": "Why use super",
            "question": "Why do we use super keyword?",
            "answer": "super: reuse parent implementation, call parent constructor explicitly, access overridden parent method. Essential when child extends/overrides parent.",
            "useCases": [
                "Code reuse",
                "Inheritance"
            ],
            "realTimeUseCases": [
                "super() in child constructor to initialize parent"
            ]
        },
        {
            "id": 213,
            "name": "How super works in chaining",
            "question": "How does super() work in constructor chaining?",
            "answer": "super() calls parent constructor, must be first statement in child constructor. Initializes parent state. Can pass params: super(id, name). Enables hierarchical initialization.",
            "useCases": [
                "Constructor chaining",
                "Initialization"
            ],
            "realTimeUseCases": [
                "class Admin extends User { Admin(String name) { super(name); } }"
            ]
        },
        {
            "id": 214,
            "name": "Super in eCommerce",
            "question": "Real-time example of using super() in eCommerce subclass models.",
            "answer": "Example: class AdminUser extends User { AdminUser(String name, String role) { super(name); this.role = role; } } super(name) initializes User, then AdminUser adds role.",
            "useCases": [
                "Inheritance initialization",
                "Specialization"
            ],
            "realTimeUseCases": [
                "Different user types initializing common User data"
            ]
        },
        {
            "id": 215,
            "name": "Object class",
            "question": "What is Object class in Java?",
            "answer": "Object: root class of all Java classes, every class implicitly extends Object. Provides methods: equals(), hashCode(), toString(), clone(), wait(), notify(). Foundation of OOP.",
            "useCases": [
                "Type hierarchy",
                "Inheritance"
            ],
            "realTimeUseCases": [
                "Every object is instance of Object"
            ]
        },
        {
            "id": 216,
            "name": "Why Object is root",
            "question": "Why Object is the root class of all classes in Java?",
            "answer": "Object as root: unified type system (all objects can be treated as Object), provides essential methods, enables polymorphism (Object[] array holds anything), ensures common interface.",
            "useCases": [
                "Type system",
                "Polymorphism"
            ],
            "realTimeUseCases": [
                "Object[] array, Object.equals() on any class"
            ]
        },
        {
            "id": 217,
            "name": "Methods of Object class",
            "question": "What are the methods of Object class?",
            "answer": "Methods: equals() (comparison), hashCode() (hash value), toString() (string representation), clone() (object copy), wait()/notify() (multithreading), finalize() (cleanup, deprecated).",
            "useCases": [
                "Common interface",
                "Utilities"
            ],
            "realTimeUseCases": [
                "All objects support these methods"
            ]
        },
        {
            "id": 218,
            "name": "Override equals() real projects",
            "question": "Why should we override equals() in real projects?",
            "answer": "Default equals() compares references (identity). Override to compare values (content). Essential for collections (contains(), indexOf() rely on equals()). Use == check first for performance.",
            "useCases": [
                "Equality semantics",
                "Collections"
            ],
            "realTimeUseCases": [
                "list.contains(user) compares via equals()"
            ]
        },
        {
            "id": 219,
            "name": "Override hashCode",
            "question": "Why should we override hashCode()?",
            "answer": "hashCode() required for hash-based collections (HashMap, HashSet). Contract: equal objects must have same hash. Override together with equals(). Poor hash = poor performance.",
            "useCases": [
                "Hash collections",
                "Performance"
            ],
            "realTimeUseCases": [
                "User in HashSet requires hashCode()"
            ]
        },
        {
            "id": 220,
            "name": "Override toString",
            "question": "Why should we override toString()?",
            "answer": "Default toString() returns class@hashCode. Override to return meaningful representation (fields). Improves debugging, logging, error messages. Called implicitly in String concatenation.",
            "useCases": [
                "Debugging",
                "Logging"
            ],
            "realTimeUseCases": [
                "System.out.println(user) shows readable output"
            ]
        },
        {
            "id": 221,
            "name": "toString in eCommerce",
            "question": "Real-time eCommerce example where overriding toString() helped in debugging logs.",
            "answer": "Example: class Order { toString() { return \"Order{\" + id + \", \" + date + \", \" + items.size() + \" items}\"; } } Logs show Order{123, 2025-01-01, 5 items} instead of Order@a2a3b",
            "useCases": [
                "Debugging",
                "Logging"
            ],
            "realTimeUseCases": [
                "Readable log messages"
            ]
        },
        {
            "id": 222,
            "name": "Coupling in OOPs",
            "question": "What is coupling in OOPs?",
            "answer": "Coupling: degree of interdependence between classes. Tight coupling: one change breaks many classes. Loose coupling: changes isolated. Goal: loose coupling for maintainability.",
            "useCases": [
                "Design quality",
                "Maintainability"
            ],
            "realTimeUseCases": [
                "Interface-based design enables loose coupling"
            ]
        },
        {
            "id": 223,
            "name": "Cohesion in OOPs",
            "question": "What is cohesion in OOPs?",
            "answer": "Cohesion: how closely related class members are. High cohesion: related methods/fields together. Low cohesion: scattered responsibilities. Goal: high cohesion for clarity.",
            "useCases": [
                "Design quality",
                "Code organization"
            ],
            "realTimeUseCases": [
                "Single Responsibility Principle"
            ]
        },
        {
            "id": 224,
            "name": "Loose coupling",
            "question": "What is loose coupling?",
            "answer": "Loose coupling: minimal dependencies between classes, use interfaces/abstraction, change in one class doesn't affect others. Achievable via dependency injection, strategy pattern.",
            "useCases": [
                "Design pattern",
                "Maintainability"
            ],
            "realTimeUseCases": [
                "Injecting payment service interface, not concrete class"
            ]
        },
        {
            "id": 225,
            "name": "Tight coupling",
            "question": "What is tight coupling?",
            "answer": "Tight coupling: strong dependencies, direct class references, change in one breaks many. Causes: direct instantiation (new), hard-coded dependencies. Avoid via abstraction.",
            "useCases": [
                "Antipattern",
                "Problems"
            ],
            "realTimeUseCases": [
                "OrderService creating StripePayment directly"
            ]
        },
        {
            "id": 226,
            "name": "Single Responsibility Principle",
            "question": "What is the Single Responsibility Principle (SRP)?",
            "answer": "SRP: class should have single reason to change, one responsibility. Example: PaymentService handles payments only, not logging/notifications. Improves cohesion, maintainability.",
            "useCases": [
                "Design principle",
                "Best practice"
            ],
            "realTimeUseCases": [
                "UserService â†’ user logic only, not email sending"
            ]
        },
        {
            "id": 227,
            "name": "Open Closed Principle",
            "question": "What is Open Closed Principle (OCP)?",
            "answer": "OCP: open for extension, closed for modification. Add new features without changing existing code. Achievable via abstraction, inheritance, interfaces. Enables maintainability.",
            "useCases": [
                "Design principle",
                "Extensibility"
            ],
            "realTimeUseCases": [
                "New payment method extends PaymentGateway, doesn't modify existing"
            ]
        },
        {
            "id": 228,
            "name": "Liskov Substitution Principle",
            "question": "What is Liskov Substitution Principle (LSP)?",
            "answer": "LSP: objects of parent type should be replaceable by child type without breaking. Child honors parent contract. Violating LSP: Square is not Liskov-substitutable for Rectangle (breaks area calculation).",
            "useCases": [
                "Design principle",
                "Type substitution"
            ],
            "realTimeUseCases": [
                "All PaymentGateway implementations interchangeable"
            ]
        },
        {
            "id": 229,
            "name": "Dependency Inversion Principle",
            "question": "What is Dependency Inversion Principle (DIP)?",
            "answer": "DIP: depend on abstractions, not concrete classes. High-level modules shouldn't depend on low-level modules; both depend on abstractions. Enables loose coupling, testability.",
            "useCases": [
                "Design principle",
                "Testability"
            ],
            "realTimeUseCases": [
                "OrderService depends on PaymentService interface, not StripePayment"
            ]
        },
        {
            "id": 230,
            "name": "OOP principles in eCommerce",
            "question": "Real-time eCommerce examples applying OOP principles.",
            "answer": "SRP: UserService (users only), PaymentService (payments only). OCP: PaymentGateway interface, extend for new providers. LSP: all PaymentGateway implementations substitutable. DIP: OrderService uses PaymentService interface, injected at runtime.",
            "useCases": [
                "Architecture",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Production eCommerce systems"
            ]
        },
        {
            "id": 231,
            "name": "String in Java",
            "question": "What is String in Java?",
            "answer": "String: sequence of characters, represents text data. Immutable object (once created, cannot be changed). Stored in String pool (memory optimization). Created via literal or new keyword. Essential for text processing.",
            "useCases": [
                "Text data",
                "Data structure"
            ],
            "realTimeUseCases": [
                "String name = \"John\";"
            ]
        },
        {
            "id": 232,
            "name": "Why immutable",
            "question": "Why is String immutable in Java?",
            "answer": "Immutability: security (passwords, URLs safe from modification), caching (shared references, memory efficient), thread safety (no synchronization needed), enables interning (String pool). Immutability is a feature.",
            "useCases": [
                "Design decision",
                "Memory optimization"
            ],
            "realTimeUseCases": [
                "Secure data handling"
            ]
        },
        {
            "id": 233,
            "name": "String immutability example",
            "question": "What happens internally when we modify a String?",
            "answer": "String immutable: modification creates new String object, original remains unchanged. Example: s = \"Hello\"; s = s + \" World\"; creates two String objects. Old reference may be garbage collected if no longer used.",
            "useCases": [
                "Understanding immutability",
                "Memory model"
            ],
            "realTimeUseCases": [
                "String concatenation creates new objects"
            ]
        },
        {
            "id": 234,
            "name": "String pool",
            "question": "What is String pool in Java?",
            "answer": "String pool: memory region storing unique String literals. If literal exists in pool, reference reused; otherwise new String created and added to pool. Saves memory for duplicate strings. Located in heap.",
            "useCases": [
                "Memory optimization",
                "Performance"
            ],
            "realTimeUseCases": [
                "String s1 = \"Java\"; String s2 = \"Java\"; // s1 == s2"
            ]
        },
        {
            "id": 235,
            "name": "String literals vs new",
            "question": "What is the difference between String literal and String created via new?",
            "answer": "Literal (\"Hello\"): goes to String pool, reused if duplicate. new String(\"Hello\"): creates new object on heap, not in pool (unless interned). Literal more memory efficient. Most strings should be created as literals.",
            "useCases": [
                "Memory optimization",
                "Best practice"
            ],
            "realTimeUseCases": [
                "String s1 = \"Hello\"; (pool) vs new String(\"Hello\") (heap)"
            ]
        },
        {
            "id": 236,
            "name": "String pool example",
            "question": "Explain String pool with practical example.",
            "answer": "Example: String s1 = \"Java\"; String s2 = \"Java\"; s1 == s2 returns true (same reference from pool). String s3 = new String(\"Java\"); s3 == s1 returns false (different object). pool optimizes memory.",
            "useCases": [
                "Demonstration",
                "Memory model"
            ],
            "realTimeUseCases": [
                "Reference comparison"
            ]
        },
        {
            "id": 237,
            "name": "String interning",
            "question": "What is String interning?",
            "answer": "Interning: manually adding String to pool via intern() method. String s = new String(\"Java\").intern(); ensures String is in pool. Useful when explicitly need pool membership. Improves memory if many duplicates expected.",
            "useCases": [
                "Memory optimization",
                "Control"
            ],
            "realTimeUseCases": [
                "Explicitly place strings in pool for caching"
            ]
        },
        {
            "id": 238,
            "name": "StringBuffer in Java",
            "question": "What is StringBuffer in Java?",
            "answer": "StringBuffer: mutable String (opposite of immutable String), synchronized (thread-safe), used for multi-threaded environments. Efficient for frequent modifications (no new objects). StringBuilder preferred for single-threaded.",
            "useCases": [
                "Mutable strings",
                "Multi-threading"
            ],
            "realTimeUseCases": [
                "StringBuffer sb = new StringBuffer(\"Hello\");"
            ]
        },
        {
            "id": 239,
            "name": "StringBuilder in Java",
            "question": "What is StringBuilder in Java?",
            "answer": "StringBuilder: mutable String, NOT synchronized (not thread-safe), faster than StringBuffer (no sync overhead). Preferred for single-threaded, frequent modifications. Java 5+ introduced StringBuilder.",
            "useCases": [
                "Mutable strings",
                "Performance"
            ],
            "realTimeUseCases": [
                "StringBuilder sb = new StringBuilder();"
            ]
        },
        {
            "id": 240,
            "name": "String vs StringBuffer vs StringBuilder",
            "question": "What is the difference between String, StringBuffer, and StringBuilder?",
            "answer": "String: immutable, thread-safe (immutability), slower for modifications. StringBuffer: mutable, synchronized, slower due to sync overhead. StringBuilder: mutable, NOT synchronized, fastest. Use String for constants, StringBuilder for frequent changes (single-threaded), StringBuffer for multi-threaded.",
            "useCases": [
                "Comparison",
                "Performance",
                "Threading"
            ],
            "realTimeUseCases": [
                "Choosing right type for task"
            ]
        },
        {
            "id": 241,
            "name": "When to use String",
            "question": "When should we use String in Java?",
            "answer": "Use String: constants, keys (HashMap), immutable data, thread safety required, security-sensitive (passwords), API contracts. String is default, immutability is benefit.",
            "useCases": [
                "Best practice",
                "Use cases"
            ],
            "realTimeUseCases": [
                "Database column names"
            ]
        },
        {
            "id": 242,
            "name": "When to use StringBuffer",
            "question": "When should we use StringBuffer?",
            "answer": "Use StringBuffer: multi-threaded code, frequent modifications required, thread safety essential. Example: shared StringBuilder across threads (rare). StringBuffer slower but thread-safe.",
            "useCases": [
                "Threading",
                "Multi-threaded applications"
            ],
            "realTimeUseCases": [
                "Shared mutable string in concurrent code"
            ]
        },
        {
            "id": 243,
            "name": "When to use StringBuilder",
            "question": "When should we use StringBuilder?",
            "answer": "Use StringBuilder: single-threaded code, frequent string modifications, building strings in loops, performance critical. Default choice for mutable strings. StringBuilder >StringBuffer>String (performance).",
            "useCases": [
                "Performance",
                "Mutable strings"
            ],
            "realTimeUseCases": [
                "Building URLs, SQL queries in methods"
            ]
        },
        {
            "id": 244,
            "name": "String concatenation",
            "question": "What is String concatenation in Java?",
            "answer": "Concatenation: combining strings via + operator or concat() method. '+' internally uses StringBuilder (Java 5+) for multiple concatenations. Avoid + in loops (creates many objects). Use StringBuilder for efficiency.",
            "useCases": [
                "String combining",
                "Performance"
            ],
            "realTimeUseCases": [
                "String result = \"Hello\" + \" \" + \"World\";"
            ]
        },
        {
            "id": 245,
            "name": "String concatenation performance",
            "question": "Why is String concatenation with + operator inefficient in loops?",
            "answer": "Concatenation '+' in loop: each iteration creates new String (immutability). Example: for(int i=0; i<1000; i++) s += \"x\"; creates 1000 String objects. Use StringBuilder outside loop: sb.append(\"x\") efficient, single final String created.",
            "useCases": [
                "Performance optimization",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Building large strings"
            ]
        },
        {
            "id": 246,
            "name": "String methods",
            "question": "What are common String methods in Java?",
            "answer": "Methods: length(), charAt(i), substring(start, end), indexOf(str), lastIndexOf(str), equals(), equalsIgnoreCase(), compareTo(), contains(), startsWith(), endsWith(), trim(), toUpperCase(), toLowerCase(), split(), replace(), concat().",
            "useCases": [
                "String manipulation",
                "APIs"
            ],
            "realTimeUseCases": [
                "String processing"
            ]
        },
        {
            "id": 247,
            "name": "Equals vs ==",
            "question": "What is the difference between equals() and == for String comparison?",
            "answer": "==: compares references (identity), checks if both point to same object. equals(): compares content (values). Example: s1==\"Java\" checks reference; s1.equals(\"Java\") checks value. Use equals() for content, == for identity (rare).",
            "useCases": [
                "String comparison",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Comparing user input to constants"
            ]
        },
        {
            "id": 248,
            "name": "String.valueOf vs toString",
            "question": "What is the difference between String.valueOf() and toString()?",
            "answer": "valueOf(): static method, converts any type to String, handles null (returns \"null\"). toString(): instance method, object-specific, throws NullPointerException on null. valueOf() safer for objects that may be null.",
            "useCases": [
                "Type conversion",
                "Null safety"
            ],
            "realTimeUseCases": [
                "String.valueOf(null) vs null.toString()"
            ]
        },
        {
            "id": 249,
            "name": "String.format",
            "question": "What is String.format() in Java?",
            "answer": "format(): creates formatted String using template + arguments. Syntax: String.format(\"Hello %s, age %d\", name, age). Similar to printf. Supports %s (string), %d (int), %f (float), %b (boolean). Useful for templates.",
            "useCases": [
                "String formatting",
                "Templating"
            ],
            "realTimeUseCases": [
                "Logging messages, reports"
            ]
        },
        {
            "id": 250,
            "name": "String split method",
            "question": "What does String.split() method do?",
            "answer": "split(regex): splits String into array using regex delimiter. Example: \"a,b,c\".split(\",\") â†’ [\"a\",\"b\",\"c\"]. Useful for CSV parsing, tokenization. Regex support (not just literal strings).",
            "useCases": [
                "String parsing",
                "Tokenization"
            ],
            "realTimeUseCases": [
                "Parsing CSV data"
            ]
        },
        {
            "id": 251,
            "name": "String memory allocation",
            "question": "How is String memory allocated in Java?",
            "answer": "String literals: stored in String pool (heap). new String(): creates on heap (not in pool unless interned). String immutable: single string object can be referenced multiple times (memory efficient). Pool reduces duplicate strings in memory.",
            "useCases": [
                "Memory model",
                "Optimization"
            ],
            "realTimeUseCases": [
                "Understanding memory usage"
            ]
        },
        {
            "id": 252,
            "name": "String buffer size",
            "question": "What is StringBuilder initial capacity and how does it grow?",
            "answer": "StringBuilder default capacity: 16 chars. Growth: when capacity exceeded, new array created with double capacity (plus some margin). Example: append 100 chars â†’ capacity grows to 34â†’70â†’142. Specify initial capacity to avoid growth: new StringBuilder(100).",
            "useCases": [
                "Performance tuning",
                "Memory"
            ],
            "realTimeUseCases": [
                "Optimizing string building"
            ]
        },
        {
            "id": 253,
            "name": "String intern() method",
            "question": "What does String.intern() method do?",
            "answer": "intern(): returns reference to String in pool. If String exists in pool, returns existing reference. If not, adds to pool and returns reference. Example: s = new String(\"Hello\").intern(); ensures s points to pool String.",
            "useCases": [
                "String pool",
                "Memory optimization"
            ],
            "realTimeUseCases": [
                "Controlling pool membership"
            ]
        },
        {
            "id": 254,
            "name": "String performance String vs StringBuilder",
            "question": "Compare performance: String concatenation vs StringBuilder in loops.",
            "answer": "String concatenation in loop (1000 iterations): ~10000ms (10000 objects). StringBuilder: ~1ms (1 object). StringBuilder 10,000x faster. Rule: for loops/frequent modifications, use StringBuilder; for one-time concatenation, String is fine.",
            "useCases": [
                "Performance optimization",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Building large logs, reports"
            ]
        },
        {
            "id": 255,
            "name": "String immutability benefits",
            "question": "What are the benefits of String immutability?",
            "answer": "Benefits: thread safety (no synchronization), security (passwords, URLs), caching (String pool, hash caching), predictability (state never changes), enables optimizations (compiler, JVM). Immutability is design feature, not limitation.",
            "useCases": [
                "Design principles",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Safe concurrent access"
            ]
        },
        {
            "id": 256,
            "name": "String in HashMap",
            "question": "Why String is preferred as HashMap key?",
            "answer": "String preferred for keys: immutable (hash never changes), good hash function, equals() compares values. Hash-based collections rely on hashCode() and equals() consistency. Mutable objects as keys risky (if modified, lookup fails).",
            "useCases": [
                "HashMap design",
                "Best practice"
            ],
            "realTimeUseCases": [
                "String keys in caches, configs"
            ]
        },
        {
            "id": 257,
            "name": "String case insensitive comparison",
            "question": "How to compare Strings ignoring case?",
            "answer": "Use equalsIgnoreCase() method. Example: \"JAVA\".equalsIgnoreCase(\"java\") returns true. Useful for user input, case-insensitive matching. Also compareToIgnoreCase() for ordering.",
            "useCases": [
                "String comparison",
                "User input handling"
            ],
            "realTimeUseCases": [
                "Username comparison (case-insensitive)"
            ]
        },
        {
            "id": 258,
            "name": "String substring",
            "question": "What does String.substring() do?",
            "answer": "substring(start, end): returns substring from start (inclusive) to end (exclusive). Example: \"Hello\".substring(1, 4) returns \"ell\". substring(start): returns from start to end. Useful for string extraction.",
            "useCases": [
                "String extraction",
                "Manipulation"
            ],
            "realTimeUseCases": [
                "Extracting email domain"
            ]
        },
        {
            "id": 259,
            "name": "String indexOf and lastIndexOf",
            "question": "What is difference between indexOf() and lastIndexOf()?",
            "answer": "indexOf(str): returns first occurrence position (-1 if not found). lastIndexOf(str): returns last occurrence position. Example: \"hello hello\".indexOf(\"l\") returns 2, lastIndexOf(\"l\") returns 9.",
            "useCases": [
                "String searching",
                "Text processing"
            ],
            "realTimeUseCases": [
                "Finding characters in strings"
            ]
        },
        {
            "id": 260,
            "name": "String replace vs replaceAll",
            "question": "What is difference between replace() and replaceAll()?",
            "answer": "replace(oldChar, newChar): replaces all occurrences of character (not regex). replaceAll(regex, replacement): replaces all matches of regex pattern. Example: \"hello\".replaceAll(\"l+\", \"x\") â†’ \"hexo\". replaceAll supports regex.",
            "useCases": [
                "String replacement",
                "Pattern matching"
            ],
            "realTimeUseCases": [
                "Text processing, validation"
            ]
        },
        {
            "id": 261,
            "name": "String trim method",
            "question": "What does String.trim() do?",
            "answer": "trim(): removes leading and trailing whitespace (spaces, tabs, newlines). Example: \"  hello  \".trim() returns \"hello\". Useful for cleaning user input. Returns new String (original unchanged).",
            "useCases": [
                "Input cleaning",
                "Text processing"
            ],
            "realTimeUseCases": [
                "Cleaning form input from users"
            ]
        },
        {
            "id": 262,
            "name": "String eCommerce example",
            "question": "Real-time eCommerce example using String operations.",
            "answer": "Example: String email = \"user@example.com\".trim().toLowerCase(); domain = email.substring(email.indexOf(\"@\")+1); String product = \"Product ID: 12345\"; productId = product.replaceAll(\"\\\\D\", \"\"); Extracting data from strings for processing.",
            "useCases": [
                "Data extraction",
                "Cleaning"
            ],
            "realTimeUseCases": [
                "Email parsing, product ID extraction"
            ]
        },
        {
            "id": 263,
            "name": "String thread safety",
            "question": "Is String thread-safe in Java?",
            "answer": "Yes, String is thread-safe due to immutability. Multiple threads can safely access same String (no changes). No synchronization needed. StringBuffer also thread-safe (synchronized methods). StringBuilder not thread-safe (no synchronization).",
            "useCases": [
                "Threading",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Concurrent access to strings"
            ]
        },
        {
            "id": 264,
            "name": "String creation via literal vs constructor",
            "question": "Why create String via literal instead of constructor?",
            "answer": "Literal (\"Hello\"): in pool, reused, memory efficient, idiomatic Java. Constructor (new String(\"Hello\")): on heap, not pooled unless interned, creates unnecessary object. Literal is recommended (best practice).",
            "useCases": [
                "Best practice",
                "Performance"
            ],
            "realTimeUseCases": [
                "Constants should be literals"
            ]
        },
        {
            "id": 265,
            "name": "String and security",
            "question": "Why String is better than char[] for passwords?",
            "answer": "String: immutable (cannot modify/overwrite after creation). char[] array: mutable (can overwrite with zeros after use). For passwords: char[] preferred (can explicitly clear after use). String problematic (stays in memory, garbage collected unpredictably).",
            "useCases": [
                "Security",
                "Sensitive data"
            ],
            "realTimeUseCases": [
                "Password handling in applications"
            ]
        },
        {
            "id": 266,
            "name": "String builder eCommerce",
            "question": "Real-time eCommerce example where StringBuilder improved performance.",
            "answer": "Example: building invoice PDF from many items. String invoice = \"\"; for(Item item : items) invoice += item.getName(); // slow. Better: StringBuilder sb = new StringBuilder(); for(Item item : items) sb.append(item.getName()); String invoice = sb.toString(); // fast. Avoids 1000s of String objects.",
            "useCases": [
                "Performance optimization",
                "Reports"
            ],
            "realTimeUseCases": [
                "Generating large documents"
            ]
        },
        {
            "id": 267,
            "name": "String concatenation with +",
            "question": "What happens internally when using + for String concatenation?",
            "answer": "Internally: Java compiler converts String s = \"Hello\" + \" World\" to StringBuilder. String s = new StringBuilder(\"Hello\").append(\" World\").toString(); One-time concatenation acceptable. Loops problematic (new StringBuilder each iteration in older Java).",
            "useCases": [
                "Understanding optimization",
                "Performance"
            ],
            "realTimeUseCases": [
                "Compiler optimization"
            ]
        },
        {
            "id": 268,
            "name": "StringBuffer append method",
            "question": "What does StringBuilder.append() method do?",
            "answer": "append(obj): adds object (converted to String) to end. Returns StringBuilder (enables chaining). Syntax: sb.append(\"Hello\").append(\" \").append(\"World\"). Efficient (modifies existing object). Supports all types: int, double, boolean, objects.",
            "useCases": [
                "String building",
                "Chaining"
            ],
            "realTimeUseCases": [
                "Building complex strings"
            ]
        },
        {
            "id": 269,
            "name": "String compareTo method",
            "question": "What does String.compareTo() do?",
            "answer": "compareTo(str): compares two Strings lexicographically. Returns: negative (less), 0 (equal), positive (greater). Useful for sorting. compareToIgnoreCase() ignores case. Example: \"abc\".compareTo(\"def\") returns negative.",
            "useCases": [
                "String comparison",
                "Sorting"
            ],
            "realTimeUseCases": [
                "Sorting strings, collation"
            ]
        },
        {
            "id": 270,
            "name": "String charAt method",
            "question": "What does String.charAt() do?",
            "answer": "charAt(index): returns character at specified index (0-based). Throws StringIndexOutOfBoundsException if index invalid. Useful for character-by-character processing. Example: \"Hello\".charAt(1) returns 'e'.",
            "useCases": [
                "Character access",
                "Processing"
            ],
            "realTimeUseCases": [
                "Iterating through characters"
            ]
        },
        {
            "id": 271,
            "name": "Collections Framework in Java",
            "question": "What is Collections Framework in Java?",
            "answer": "Collections Framework: set of classes and interfaces for storing and manipulating groups of objects. Provides data structures (List, Set, Queue, Map), algorithms (sort, search, shuffle), and iterators. Unified architecture for collection handling. Part of java.util package. Enables efficient data management.",
            "useCases": [
                "Data structure handling",
                "Object grouping"
            ],
            "realTimeUseCases": [
                "Storing products, users, orders in eCommerce"
            ]
        },
        {
            "id": 272,
            "name": "Why use Collections Framework",
            "question": "Why do we use Collections Framework?",
            "answer": "Framework provides: reusable data structures (avoid writing custom lists), performance optimization (tuned algorithms), consistency (standardized interface), thread safety options (synchronized collections), polymorphism (work with Collection interface). Simplifies code, improves maintainability, reduces bugs.",
            "useCases": [
                "Code reuse",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Using ArrayList instead of custom array management"
            ]
        },
        {
            "id": 273,
            "name": "Problems Collections Framework solves",
            "question": "What problems does Collections Framework solve?",
            "answer": "Solves: manual array management (size issues), code duplication (reusable collections), algorithm implementation (built-in sort/search), memory inefficiency (optimized structures), synchronization complexity (thread-safe versions), iteration complexity (Iterator pattern provided). Framework eliminates these pain points.",
            "useCases": [
                "Problem solving",
                "Architecture"
            ],
            "realTimeUseCases": [
                "Managing dynamic product inventory"
            ]
        },
        {
            "id": 274,
            "name": "Advantages of Java Collections",
            "question": "What are the advantages of using Java Collections?",
            "answer": "Advantages: dynamic sizing (auto-grow), memory efficient (optimized algorithms), type safety (generics support), ready-made algorithms (sort, binarySearch), polymorphism (Collection interface), performance tuned (tested implementation), iterator pattern (consistent traversal), fail-fast behavior (detect concurrent modifications), ecosystem integration (widely supported).",
            "useCases": [
                "Framework benefits",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Using generics: List<Product> prevents type errors"
            ]
        },
        {
            "id": 275,
            "name": "Major interfaces of Java Collections",
            "question": "What are the major interfaces of Java Collections?",
            "answer": "Major interfaces: Collection (root), List (ordered, duplicates allowed), Set (unique elements), Queue (FIFO ordering), Deque (double-ended queue), Map (key-value pairs). Iterable (enables foreach loop). Each provides specific contract and implementations.",
            "useCases": [
                "Type hierarchy",
                "Interface design"
            ],
            "realTimeUseCases": [
                "Using List for cart items, Set for unique product IDs"
            ]
        },
        {
            "id": 276,
            "name": "Difference between Collections and Collection",
            "question": "What is the difference between Collections and Collection?",
            "answer": "Collection: interface (java.util.Collection), defines contract for collection types (add, remove, contains). Collections: utility class (java.util.Collections), provides static methods (sort, reverse, shuffle, binarySearch, synchronizedList). Collection is blueprint, Collections is toolkit.",
            "useCases": [
                "Type distinction",
                "Utility",
                "Interface"
            ],
            "realTimeUseCases": [
                "Collections.sort(list) vs List.add(element)"
            ]
        },
        {
            "id": 277,
            "name": "Iterable interface",
            "question": "What is Iterable interface?",
            "answer": "Iterable: interface enabling foreach loop (for-each). Classes implementing Iterable provide iterator() method returning Iterator. Enables: enhanced for loops, stream operations, method reference iteration. Every Collection implements Iterable. Fundamental for collection traversal.",
            "useCases": [
                "Iteration pattern",
                "Foreach loops"
            ],
            "realTimeUseCases": [
                "for(Product p : products) requires Iterable"
            ]
        },
        {
            "id": 278,
            "name": "Root of Collection hierarchy",
            "question": "What is the root of the Collection hierarchy?",
            "answer": "Root: Iterable interface (top-level for iteration). Directly below: Collection interface (defines common operations: add, remove, contains, size). Below Collection: List, Set, Queue interfaces. Map is separate hierarchy (not extends Collection). Iterable â†’ Collection â†’ List/Set/Queue.",
            "useCases": [
                "Type hierarchy",
                "Architecture"
            ],
            "realTimeUseCases": [
                "All collections inherit common contract from Collection"
            ]
        },
        {
            "id": 279,
            "name": "Core Collection interfaces",
            "question": "What are the core Collection interfaces (List, Set, Queue, Map)?",
            "answer": "List: ordered, duplicates allowed, indexed access. Set: unique elements, no guaranteed order (except TreeSet, LinkedHashSet). Queue: FIFO ordering, designed for queueing. Map: key-value pairs, keys unique. Each with specific use case and implementations (ArrayList, HashSet, PriorityQueue, HashMap).",
            "useCases": [
                "Interface types",
                "Data structures"
            ],
            "realTimeUseCases": [
                "List for orders, Set for unique categories, Map for user sessions"
            ]
        },
        {
            "id": 280,
            "name": "Why Map not part of Collection",
            "question": "Why Map is not part of the Collection interface?",
            "answer": "Map doesn't extend Collection because: structural difference (key-value pairs vs single elements), different contract (entrySet(), keySet(), values() vs add(), remove()), iteration differs (entry iteration vs element iteration), semantic mismatch (not a collection of elements, collection of mappings). Separate hierarchy makes sense architecturally.",
            "useCases": [
                "Design decision",
                "Type hierarchy"
            ],
            "realTimeUseCases": [
                "HashMap.entrySet() differs from ArrayList iteration"
            ]
        },
        {
            "id": 281,
            "name": "Collection interface definition",
            "question": "What is Collection interface?",
            "answer": "Collection: root interface defining contract for all collections (except Map). Methods: add(), remove(), contains(), size(), isEmpty(), iterator(), addAll(), removeAll(), retainAll(), clear(). Generic: Collection<E>. Foundation for List, Set, Queue. Defines standard operations for grouping objects.",
            "useCases": [
                "Interface contract",
                "Foundation"
            ],
            "realTimeUseCases": [
                "Any List/Set/Queue implements Collection operations"
            ]
        },
        {
            "id": 282,
            "name": "Main methods of Collection interface",
            "question": "What are the main methods of Collection interface?",
            "answer": "Main methods: add(E) - add element, remove(Object) - remove element, contains(Object) - check existence, size() - element count, isEmpty() - check empty, iterator() - get Iterator, clear() - remove all, addAll(Collection) - bulk add, removeAll(Collection) - bulk remove, retainAll(Collection) - keep only specified, toArray() - convert to array.",
            "useCases": [
                "API methods",
                "Basic operations"
            ],
            "realTimeUseCases": [
                "collection.add(product), collection.remove(product)"
            ]
        },
        {
            "id": 283,
            "name": "Difference between Collection and Collections class",
            "question": "Difference between Collection and Collections class?",
            "answer": "Collection: interface, declares contract (add, remove, contains). Collections: utility class, provides static helper methods (sort, reverse, shuffle, binarySearch, synchronizedList, unmodifiableList). Collection is what you implement; Collections is what you use to manipulate collections. One is type, other is toolkit.",
            "useCases": [
                "Interface vs Utility",
                "Distinction"
            ],
            "realTimeUseCases": [
                "List<String> implements Collection; Collections.sort(list) uses utility"
            ]
        },
        {
            "id": 284,
            "name": "When to use Collection interface",
            "question": "When to use Collection interface?",
            "answer": "Use Collection interface: when writing generic code (Collection<T> parameter), supporting multiple collection types (List, Set, Queue), when specific type unknown at design time, for polymorphism (work with interface not implementation). Use concrete type (ArrayList, HashSet) when specific behavior needed.",
            "useCases": [
                "Generic programming",
                "Polymorphism"
            ],
            "realTimeUseCases": [
                "public void processItems(Collection<Product> items)"
            ]
        },
        {
            "id": 285,
            "name": "List interface definition",
            "question": "What is List interface?",
            "answer": "List: ordered Collection, allows duplicates, elements accessed by index (0-based). Extends Collection interface. Methods: add(index, E), get(index), remove(index), set(index, E), indexOf(), lastIndexOf(), subList(). Preserves insertion order. Suitable when order and indexed access matter.",
            "useCases": [
                "Ordered data",
                "Index access"
            ],
            "realTimeUseCases": [
                "Shopping cart items in order, product list by price"
            ]
        },
        {
            "id": 286,
            "name": "List interface features",
            "question": "What features does List provide?",
            "answer": "Features: indexed access (get/set by position), positional insertion (add at index), positional removal (remove at index), range view (subList), duplicates allowed, iteration preservation (insertion order), search methods (indexOf, lastIndexOf), list operations (addAll, removeAll at positions). Comprehensive for ordered collections.",
            "useCases": [
                "Feature set",
                "Operations"
            ],
            "realTimeUseCases": [
                "Accessing cart item at position 0, removing item at index 2"
            ]
        },
        {
            "id": 287,
            "name": "Why List allows duplicates",
            "question": "Why List allows duplicates?",
            "answer": "Design decision: List represents sequences where duplicates are meaningful (scores, purchases, logs). Index-based access allows tracking multiple instances. No uniqueness constraint needed. Duplicates support use cases like: shopping cart (multiple same products), log entries (repeated events). Set chosen for uniqueness requirement.",
            "useCases": [
                "Design rationale",
                "Use cases"
            ],
            "realTimeUseCases": [
                "Cart with 3 laptops and 2 phones (duplicates allowed)"
            ]
        },
        {
            "id": 288,
            "name": "Implementations of List",
            "question": "What are the implementations of List?",
            "answer": "Implementations: ArrayList (dynamic array, fast random access), LinkedList (doubly-linked list, fast add/remove), Vector (synchronized ArrayList, legacy), Stack (LIFO, extends Vector, legacy), CopyOnWriteArrayList (thread-safe, concurrent). Choose based on access patterns and threading needs.",
            "useCases": [
                "Implementation choices",
                "Type selection"
            ],
            "realTimeUseCases": [
                "ArrayList for product catalog, LinkedList for undo queue"
            ]
        },
        {
            "id": 289,
            "name": "When to use List",
            "question": "When to use List?",
            "answer": "Use List: when order matters (sequences), need indexed access (fast get/set), allow duplicates, iterate frequently, manage variable-size collections. Use Set if uniqueness required. Use Map for key-value pairs. List is default for ordered data.",
            "useCases": [
                "Collection selection",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Customer order items, search results by ranking"
            ]
        },
        {
            "id": 290,
            "name": "Difference between List and Set",
            "question": "What is the difference between List and Set?",
            "answer": "List: ordered, duplicates allowed, indexed access (get/set), insertion order preserved. Set: unordered (except TreeSet, LinkedHashSet), no duplicates, no index access, uniqueness enforced. List for sequences (cart items), Set for unique values (categories, tags). Different semantics and performance characteristics.",
            "useCases": [
                "Type comparison",
                "Selection"
            ],
            "realTimeUseCases": [
                "List<Item> for orders, Set<String> for product categories"
            ]
        },
        {
            "id": 291,
            "name": "ArrayList definition",
            "question": "What is ArrayList in Java?",
            "answer": "ArrayList: implementation of List using resizable array. Dynamic sizing (grows as needed). Fast random access O(1). Slower insert/remove O(n). Allows duplicates and null. Not synchronized (not thread-safe). Most commonly used List implementation. Preferred over Vector for new code.",
            "useCases": [
                "Common data structure",
                "General purpose"
            ],
            "realTimeUseCases": [
                "Storing product list, customer searches"
            ]
        },
        {
            "id": 292,
            "name": "ArrayList interface",
            "question": "What is the interface of ArrayList?",
            "answer": "ArrayList implements: List<E> (primary), Collection<E>, Iterable<E>, Serializable, Cloneable. Class declaration: public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable. RandomAccess marks it for fast indexed access optimization.",
            "useCases": [
                "Interface hierarchy",
                "Type contract"
            ],
            "realTimeUseCases": [
                "List<Product> list = new ArrayList<>();"
            ]
        },
        {
            "id": 293,
            "name": "ArrayList syntax",
            "question": "What is the syntax of ArrayList?",
            "answer": "Syntax: List<Type> name = new ArrayList<>(); or ArrayList<Type> name = new ArrayList<>();. Type: element type (Product, String, Integer). Generic<E>: type parameter. With capacity: new ArrayList<>(10). Copy constructor: new ArrayList<>(collection). Examples: List<String> names = new ArrayList<>();",
            "useCases": [
                "Declaration",
                "Creation"
            ],
            "realTimeUseCases": [
                "List<Product> products = new ArrayList<>();"
            ]
        },
        {
            "id": 294,
            "name": "ArrayList internal working",
            "question": "How does ArrayList work internally?",
            "answer": "ArrayList internally: maintains Object[] array, tracks size (elements count) and capacity (array length). Adding element: checks capacity, adds if space, otherwise resizes. Removing: shifts elements left. Random access: direct index lookup O(1). Resizing: creates larger array, copies elements. Doubly indexed: element position and array position same.",
            "useCases": [
                "Internal mechanism",
                "Performance"
            ],
            "realTimeUseCases": [
                "Understanding add/remove performance"
            ]
        },
        {
            "id": 295,
            "name": "ArrayList internal data structure",
            "question": "What internal data structure does ArrayList use?",
            "answer": "Data structure: Object[] array (elementData field, private). Resizable: starts with capacity 10 (default). Tracks: size (actual count), modCount (modification count for fail-fast). Array stores references. Null-safe (can store null). Type-erased at runtime (generics removed, all Object).",
            "useCases": [
                "Memory model",
                "Data structure"
            ],
            "realTimeUseCases": [
                "Internally: Object[] array holds 10 initial elements"
            ]
        },
        {
            "id": 296,
            "name": "ArrayList resizing mechanism",
            "question": "What is resizing or dynamic array mechanism?",
            "answer": "Resizing: when size reaches capacity, ArrayList grows. Growth formula: newCapacity = oldCapacity + (oldCapacity >> 1) (1.5x). Example: 10 â†’ 15 â†’ 22 â†’ 33. Process: create new larger array, copy elements using System.arraycopy(), update reference. Expensive operation O(n), but amortized O(1) per add.",
            "useCases": [
                "Memory management",
                "Performance"
            ],
            "realTimeUseCases": [
                "Adding 15th element to ArrayList with capacity 10"
            ]
        },
        {
            "id": 297,
            "name": "ArrayList duplicate values",
            "question": "Does ArrayList allow duplicate values?",
            "answer": "Yes, ArrayList allows duplicates. No uniqueness constraint. Multiple objects with same value: List<Integer> list = new ArrayList<>(Arrays.asList(1,1,2,2,3)); list has size 5. Duplicates stored at different indices. Useful for counts, frequencies, sequences where duplicates meaningful.",
            "useCases": [
                "Data duplicates",
                "Use cases"
            ],
            "realTimeUseCases": [
                "Shopping cart: [Laptop, Mouse, Laptop, Phone]"
            ]
        },
        {
            "id": 298,
            "name": "ArrayList null values",
            "question": "Does ArrayList allow null values?",
            "answer": "Yes, ArrayList allows null. Can store null at any position. Example: list.add(null); list.add(\"hello\"); valid. size() counts null. Useful for optional values. However, careful with null - can cause NullPointerException. Best practice: avoid null when possible, use Optional<T> alternatively.",
            "useCases": [
                "Null handling",
                "Safety"
            ],
            "realTimeUseCases": [
                "Optional middle name: [\"John\", null, \"Doe\"]"
            ]
        },
        {
            "id": 299,
            "name": "ArrayList thread safety",
            "question": "Is ArrayList thread-safe or not?",
            "answer": "No, ArrayList is NOT thread-safe. No synchronization on operations (add, remove, get). Concurrent modifications: one thread adds while another iterates â†’ ConcurrentModificationException. If multi-threaded: use Vector (synchronized, legacy), CopyOnWriteArrayList (modern), Collections.synchronizedList(), or explicit synchronization (synchronized block).",
            "useCases": [
                "Threading",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Multi-threaded order processing needs thread safety"
            ]
        },
        {
            "id": 300,
            "name": "ArrayList initial capacity",
            "question": "What is the initial capacity of ArrayList?",
            "answer": "Initial capacity: 10 (default, empty constructor). Constructor with capacity: new ArrayList<>(20) sets initial capacity 20. First add at empty ArrayList: size becomes 1, capacity remains 10. When size 11, resizes to 15. Capacity vs size: capacity is array length, size is actual elements.",
            "useCases": [
                "Memory allocation",
                "Optimization"
            ],
            "realTimeUseCases": [
                "new ArrayList<>(100) for known large collection"
            ]
        },
        {
            "id": 301,
            "name": "ArrayList grow method",
            "question": "How does grow() method work internally during resizing?",
            "answer": "grow(minCapacity): called when capacity exceeded. Steps: 1) calculate newCapacity = oldCapacity * 1.5, 2) check overflow (minCapacity > newCapacity), 3) allocate new array, 4) copy elements: System.arraycopy(elementData, 0, newArray, 0, size), 5) update elementData reference. Returns newCapacity. Private method, invoked internally by add().",
            "useCases": [
                "Memory growth",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Adding 11th element triggers grow()"
            ]
        },
        {
            "id": 302,
            "name": "ArrayList load factor",
            "question": "What is load factor in ArrayList?",
            "answer": "Load factor (not explicit in ArrayList): ratio of size to capacity. Resizing at 100% capacity (size == capacity). Trigger: when adding element and size == capacity, grows before adding. Growth factor: 1.5x (not configurable, unlike HashMap's 0.75). ArrayList maintains high load factor for efficiency.",
            "useCases": [
                "Capacity management",
                "Performance"
            ],
            "realTimeUseCases": [
                "ArrayList resizes when completely full"
            ]
        },
        {
            "id": 303,
            "name": "When to use ArrayList",
            "question": "When should we use ArrayList?",
            "answer": "Use ArrayList: single-threaded code, frequent random access (get by index), small number of removals, need dynamic array, no specific ordering required (order preservation automatic). Avoid: heavy insert/remove in middle, thread-safety needed, need sorted data. Default choice for List.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Product catalog, search results, sorting needed"
            ]
        },
        {
            "id": 304,
            "name": "Best scenarios for ArrayList",
            "question": "What are the best scenarios to use ArrayList?",
            "answer": "Best scenarios: read-heavy operations (frequent get), dataset size known/changing, cache/buffer (temporary storage), list for iteration, batch operations (addAll), when performance critical and access pattern is sequential/random. Examples: search results, product listings, user followers, shopping history.",
            "useCases": [
                "Use scenarios",
                "Real-world"
            ],
            "realTimeUseCases": [
                "Top 10 products by rating, user purchase history"
            ]
        },
        {
            "id": 305,
            "name": "Problems ArrayList solves",
            "question": "What problems does ArrayList solve?",
            "answer": "Solves: manual array management (resize logic), fixed-size arrays (dynamic sizing), slow iteration (Iterator support), null handling (allows null), type safety (generics), polymorphism (Collection interface). Avoids: writing custom array-based collections, memory waste, code complexity. Simplifies list operations.",
            "useCases": [
                "Problem solution",
                "Benefits"
            ],
            "realTimeUseCases": [
                "No need to write custom List implementation"
            ]
        },
        {
            "id": 306,
            "name": "Advantages of ArrayList",
            "question": "What are the advantages of ArrayList?",
            "answer": "Advantages: fast random access O(1), simple implementation, memory efficient (tightly packed array), cache-friendly (contiguous memory), Iterator support, Collections algorithm support, Serializable (store/transmit), Cloneable, type-safe (generics), widely adopted and tested, good for most use cases.",
            "useCases": [
                "Strengths",
                "Benefits"
            ],
            "realTimeUseCases": [
                "Accessing product at index 5 in milliseconds"
            ]
        },
        {
            "id": 307,
            "name": "Disadvantages of ArrayList",
            "question": "What are the disadvantages or drawbacks of ArrayList?",
            "answer": "Disadvantages: slow insert/remove in middle O(n) (element shifting), resize cost (copying array), not thread-safe (synchronization needed), contiguous memory required (fragmentation issues), waste space if over-sized, poor for frequent insert/remove. For insertion-heavy: use LinkedList instead.",
            "useCases": [
                "Weaknesses",
                "Limitations"
            ],
            "realTimeUseCases": [
                "Removing from middle of 1000-item list is slow"
            ]
        },
        {
            "id": 308,
            "name": "ArrayList vs LinkedList comparison",
            "question": "Which one is better: ArrayList or LinkedList? Why?",
            "answer": "ArrayList better for: random access (O(1) vs O(n)), memory (contiguous), cache performance. LinkedList better for: insert/remove (O(1) vs O(n)), no resizing. ArrayList preferred ~80% (most code is read-heavy). Choose based on: access pattern (random â†’ ArrayList), modification pattern (heavy middle insertion â†’ LinkedList). ArrayList default choice.",
            "useCases": [
                "Comparison",
                "Selection"
            ],
            "realTimeUseCases": [
                "ArrayList for product search, LinkedList for undo queue"
            ]
        },
        {
            "id": 309,
            "name": "Use cases of ArrayList",
            "question": "What are the use cases of ArrayList?",
            "answer": "Use cases: caching (temporary data), buffering (hold items), searching (iterate/find), sorting (Collections.sort), batch processing (addAll), pagination (subList), counting frequencies (duplicates), leaderboards (sorted lists), shopping carts (ordered items), customer lists, transaction logs.",
            "useCases": [
                "Real-world applications",
                "Examples"
            ],
            "realTimeUseCases": [
                "Product recommendations, top sellers, user activity log"
            ]
        },
        {
            "id": 310,
            "name": "ArrayList in eCommerce project",
            "question": "Where did you use ArrayList in your real-time NMG eCommerce project?",
            "answer": "ArrayList usage: storing product list (ArrayList<Product> products), shopping cart items (ArrayList<CartItem>), user search results, order history (ArrayList<Order>), delivery addresses, notifications, wishlist. Iterated for filtering, sorting by price/rating, pagination. Performance optimized for catalog queries.",
            "useCases": [
                "Project experience",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Dynamic product catalog management"
            ]
        },
        {
            "id": 311,
            "name": "ArrayList eCommerce example",
            "question": "Provide real-time eCommerce example of using ArrayList (e.g., product list, cart items).",
            "answer": "Example: List<Product> cart = new ArrayList<>(); for(Product p : selected) { cart.add(p); } double total = 0; for(Product p : cart) { total += p.getPrice(); } Collections.sort(cart, (p1,p2) -> Double.compare(p1.getPrice(), p2.getPrice())); Dynamic shopping cart managing products, calculating total, sorting by price.",
            "useCases": [
                "Code example",
                "Real-world"
            ],
            "realTimeUseCases": [
                "E-commerce cart implementation"
            ]
        },
        {
            "id": 312,
            "name": "LinkedList definition",
            "question": "What is LinkedList in Java?",
            "answer": "LinkedList: doubly-linked list implementation. Each node holds data + references (next, previous node). No fixed size (grows dynamically). Fast add/remove at beginning/end O(1). Slow random access O(n). Allows duplicates and null. Implements List and Deque. Not synchronized. Good for queue-like operations.",
            "useCases": [
                "Data structure",
                "Linked list"
            ],
            "realTimeUseCases": [
                "Undo queue, messaging queue"
            ]
        },
        {
            "id": 313,
            "name": "LinkedList interface",
            "question": "What interface does LinkedList implement?",
            "answer": "LinkedList implements: List<E> (primary), Deque<E> (double-ended queue), Collection<E>, Iterable<E>, Serializable, Cloneable. Class: public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable. Dual interface: can use as List or Deque.",
            "useCases": [
                "Interface implementation",
                "Type contract"
            ],
            "realTimeUseCases": [
                "List<String> queue = new LinkedList<>();"
            ]
        },
        {
            "id": 314,
            "name": "LinkedList internal mechanism",
            "question": "What is the internal working mechanism of LinkedList?",
            "answer": "Internal mechanism: nodes (inner class Node<E>) with element, next, previous references. head points to first node, tail to last. Adding: creates new node, updates previous/next links. Removing: updates links, skips node. Traversal: follows next/previous pointers. No array, no resizing. Performance depends on position (start/end O(1), middle O(n)).",
            "useCases": [
                "Internal structure",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Understanding add/remove performance"
            ]
        },
        {
            "id": 315,
            "name": "Why LinkedList doubly linked",
            "question": "Why LinkedList uses doubly linked list internally?",
            "answer": "Doubly-linked: each node has next AND previous reference. Benefits: traverse both directions (forward/backward), efficient removal (don't traverse from head), supports Deque operations (add/remove from both ends), bidirectional iteration. Single-linked would require traversal from head for removal. Doubly-linked enables O(1) operations at both ends.",
            "useCases": [
                "Design rationale",
                "Performance"
            ],
            "realTimeUseCases": [
                "Removing last element is O(1) with previous pointer"
            ]
        },
        {
            "id": 316,
            "name": "LinkedList duplicates",
            "question": "Does LinkedList allow duplicates?",
            "answer": "Yes, LinkedList allows duplicates. No uniqueness constraint. Multiple nodes with same value: List<Integer> list = new LinkedList<>(Arrays.asList(1,1,2,2,3)); valid. Duplicates stored in separate nodes. Useful for sequences, queues, logs where duplicates meaningful.",
            "useCases": [
                "Data duplicates",
                "Use cases"
            ],
            "realTimeUseCases": [
                "Message queue with duplicate messages"
            ]
        },
        {
            "id": 317,
            "name": "LinkedList null values",
            "question": "Does LinkedList allow null values?",
            "answer": "Yes, LinkedList allows null. Can insert null at any position. Example: list.add(null); valid. Useful for optional values. However, operations like contains(null), remove(null) work but can be ambiguous. Best practice: avoid null, use Optional<T> or dedicated null-safe structure.",
            "useCases": [
                "Null handling",
                "Safety"
            ],
            "realTimeUseCases": [
                "Optional middle names in contact list"
            ]
        },
        {
            "id": 318,
            "name": "LinkedList thread safety",
            "question": "Is LinkedList thread-safe?",
            "answer": "No, LinkedList is NOT thread-safe. No synchronization on operations (add, remove, get). Concurrent modifications during iteration â†’ ConcurrentModificationException. Multi-threaded use: wrap with Collections.synchronizedList(new LinkedList<>()), use explicit synchronization (synchronized block), or use thread-safe alternative. LinkedList inherently not concurrent-friendly.",
            "useCases": [
                "Threading",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Single-threaded undo queue"
            ]
        },
        {
            "id": 319,
            "name": "When to use LinkedList",
            "question": "When to use LinkedList?",
            "answer": "Use LinkedList: frequent insert/remove at beginning/end (O(1)), implement queue/deque, remove from middle without array copying, memory flexibility (no contiguous requirement), don't need random access. Avoid: frequent random access (slow O(n)), small datasets (overhead), when ArrayList sufficient. LinkedList for specific patterns.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Task queue, browser history (back/forward)"
            ]
        },
        {
            "id": 320,
            "name": "LinkedList advantages",
            "question": "What are the advantages of LinkedList?",
            "answer": "Advantages: fast insert/remove at ends O(1), dynamic sizing, no resizing cost, memory flexible (non-contiguous), good for queue operations, Deque capabilities, no wasted capacity, supports bidirectional iteration. Efficient for queue-like access patterns where elements added/removed frequently.",
            "useCases": [
                "Strengths",
                "Benefits"
            ],
            "realTimeUseCases": [
                "Fast task removal from queue"
            ]
        },
        {
            "id": 321,
            "name": "LinkedList drawbacks",
            "question": "What are the drawbacks of LinkedList?",
            "answer": "Drawbacks: slow random access O(n) (traversal needed), memory overhead (extra references per node), cache-unfriendly (scattered nodes), traversal slower than array, remove from middle slow O(n), not good for indexed access. Poor alternative to ArrayList for most cases. Use only when add/remove at ends critical.",
            "useCases": [
                "Weaknesses",
                "Limitations"
            ],
            "realTimeUseCases": [
                "Accessing item at index 500 requires 500 hops"
            ]
        },
        {
            "id": 322,
            "name": "ArrayList vs LinkedList which better",
            "question": "ArrayList vs LinkedList â€” which one is better and why?",
            "answer": "ArrayList better overall (use 80% time): O(1) random access, memory efficient, cache-friendly. LinkedList better for: queue operations (add/remove ends O(1)), specific patterns where middle removal frequent. Rule: start with ArrayList; switch to LinkedList only if profiling shows bottleneck in insert/remove at ends. ArrayList safer default.",
            "useCases": [
                "Comparison",
                "Best practice"
            ],
            "realTimeUseCases": [
                "ArrayList for product list, LinkedList for message queue"
            ]
        },
        {
            "id": 323,
            "name": "LinkedList eCommerce use case",
            "question": "Real-time eCommerce use case where LinkedList is used.",
            "answer": "Use case: order processing queue. LinkedList<Order> queue = new LinkedList<>(); queue.add(newOrder); // O(1) Order processedOrder = queue.removeFirst(); // O(1) undo/redo (add/remove from both ends). Browser history (back/forward buttons). Printer queue (FIFO). Chat message queue (latest messages at end).",
            "useCases": [
                "Real-world application",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Order queue management, print queue"
            ]
        },
        {
            "id": 324,
            "name": "Vector definition",
            "question": "What is Vector?",
            "answer": "Vector: synchronized ArrayList, legacy class (Java 1.0), implements List<E>. Similar to ArrayList but all methods synchronized (thread-safe). Dynamic array with capacity growing by doubleCapacity (100% growth, not 1.5x). Deprecated: ArrayList + manual synchronization or CopyOnWriteArrayList preferred. Rarely used in modern code.",
            "useCases": [
                "Legacy",
                "Threading"
            ],
            "realTimeUseCases": [
                "Legacy system support only"
            ]
        },
        {
            "id": 325,
            "name": "Vector internal working",
            "question": "How Vector works internally?",
            "answer": "Internal: Object[] array (similar to ArrayList). ALL public methods: synchronized (Thread-safety). Growth: when capacity exceeded, capacity doubles (not 1.5x). Performance: synchronization overhead on every operation. Implementation nearly identical to ArrayList but with locks. Capacity and size tracking similar.",
            "useCases": [
                "Internal mechanism",
                "Threading"
            ],
            "realTimeUseCases": [
                "Thread-safe list operations in legacy code"
            ]
        },
        {
            "id": 326,
            "name": "Why Vector thread-safe",
            "question": "Why Vector is thread-safe?",
            "answer": "Thread-safe: all public methods synchronized (lock on object). Example: synchronized void add(E element). Only one thread can execute method at time. Protection: concurrent add/remove/iteration safe. Cost: performance penalty (synchronization overhead). Modern: CopyOnWriteArrayList better for read-heavy, explicit synchronization flexible.",
            "useCases": [
                "Threading",
                "Synchronization"
            ],
            "realTimeUseCases": [
                "Multi-threaded list access"
            ]
        },
        {
            "id": 327,
            "name": "Why Vector performance slow",
            "question": "Why Vector performance is slow?",
            "answer": "Slow because: synchronization on every method call (overhead), locking mechanism cost, memory barrier flush (happens per sync), contention if many threads (blocking), growth is 100% (more resizing), legacy implementation not optimized. ArrayList + manual sync or CopyOnWriteArrayList faster alternatives. Synchronization always has cost.",
            "useCases": [
                "Performance",
                "Threading"
            ],
            "realTimeUseCases": [
                "Legacy systems accept slowness for safety"
            ]
        },
        {
            "id": 328,
            "name": "Stack definition",
            "question": "What is Stack in Java?",
            "answer": "Stack: LIFO (Last-In-First-Out) collection, extends Vector (inherits synchronization). Methods: push(E) add to top, pop() remove from top, peek() view top, empty() check empty, search(Object). Legacy class, used for: function call stack, undo operations, parsing. Modern: use Deque<E> interface with LinkedList or ArrayDeque instead.",
            "useCases": [
                "LIFO data structure",
                "Legacy"
            ],
            "realTimeUseCases": [
                "Browser back button, undo functionality"
            ]
        },
        {
            "id": 329,
            "name": "Stack internal working",
            "question": "How does Stack work internally (LIFO)?",
            "answer": "Internal: extends Vector, uses Object[] array. LIFO: push adds to end, pop removes from end. push(E): calls Vector.addElement(E). pop(): removes last element. peek(): views last element. Internally: tracks top pointer (index). Inherits Vector's synchronization (thread-safe but slow). Logical structure: LIFO, Physical: array-based.",
            "useCases": [
                "Internal mechanism",
                "LIFO"
            ],
            "realTimeUseCases": [
                "Understanding LIFO behavior"
            ]
        },
        {
            "id": 330,
            "name": "Why Stack outdated",
            "question": "Why Stack is outdated?",
            "answer": "Outdated because: extends Vector (synchronization overhead unnecessary for many uses), legacy (Java 1.0), inflexible (only Vector base), modern Deque better alternative. Deque<E> stack = new ArrayDeque<>(); stack.push(e); more flexible, faster, cleaner API. Stack still works but not recommended for new code.",
            "useCases": [
                "Legacy",
                "Modern alternatives"
            ],
            "realTimeUseCases": [
                "Use ArrayDeque instead of Stack"
            ]
        },
        {
            "id": 331,
            "name": "Stack replacement class",
            "question": "Which class replaces Stack now?",
            "answer": "Deque<E> with ArrayDeque<E> or LinkedList<E> replaces Stack. Deque<Integer> stack = new ArrayDeque<>(); stack.push(1); // LIFO int top = stack.pop(); // LIFO Methods: push(), pop(), peek(), pollFirst(), pollLast(). ArrayDeque preferred (faster, better memory). LinkedList also valid. Deque interface more flexible than Stack.",
            "useCases": [
                "Modern alternative",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Deque<Item> stack = new ArrayDeque<>();"
            ]
        },
        {
            "id": 332,
            "name": "Set interface definition",
            "question": "What is Set interface?",
            "answer": "Set: Collection of unique elements, no duplicates enforced. Extends Collection<E>. Unordered (except TreeSet, LinkedHashSet). No indexed access (no get(index)). Methods: add(), remove(), contains(), size(), iterator(). Models mathematical set (uniqueness). Three main implementations: HashSet, TreeSet, LinkedHashSet.",
            "useCases": [
                "Unique data",
                "Mathematical set"
            ],
            "realTimeUseCases": [
                "Unique product IDs, user tags"
            ]
        },
        {
            "id": 333,
            "name": "Why Set no duplicates",
            "question": "Why Set does not allow duplicates?",
            "answer": "Design principle: Set models mathematical set (uniqueness). Enforced: add() returns false if element exists. Implementation: HashSet uses hashCode()/equals(), TreeSet uses compareTo(). Duplicate add silently ignored: set.add(1); set.add(1); set size remains 1. Semantics: Set for unique values, List for sequences with duplicates.",
            "useCases": [
                "Design rationale",
                "Uniqueness"
            ],
            "realTimeUseCases": [
                "Unique email addresses, product categories"
            ]
        },
        {
            "id": 334,
            "name": "Implementations of Set",
            "question": "What are the implementations of Set?",
            "answer": "Implementations: HashSet (unordered, fast O(1) add/remove), LinkedHashSet (insertion-order, maintains linked list), TreeSet (sorted, Red-Black tree, O(logn)), CopyOnWriteArraySet (thread-safe, concurrent). EnumSet specialized for enums. Choose: HashSet (general), TreeSet (sorted), LinkedHashSet (order matters), CopyOnWriteArraySet (multi-threaded).",
            "useCases": [
                "Implementation choices",
                "Selection"
            ],
            "realTimeUseCases": [
                "HashSet for tags, TreeSet for sorted categories"
            ]
        },
        {
            "id": 335,
            "name": "When use Set over List",
            "question": "When should we use Set instead of List?",
            "answer": "Use Set: uniqueness critical (no duplicates), order irrelevant, membership checking (contains O(1) vs O(n)), mathematical set operations (union, intersection), removing duplicates. Use List: order matters, allow duplicates, indexed access needed, maintain sequence. Rule: if 'unique' is requirement, Set; if 'order' or 'duplicates', List.",
            "useCases": [
                "Selection",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Set for unique followers, List for timeline"
            ]
        },
        {
            "id": 336,
            "name": "HashSet definition",
            "question": "What is HashSet?",
            "answer": "HashSet: implementation of Set using HashMap internally. Unordered collection (no guaranteed order). Fast add/remove/contains O(1) average. Allows one null. Not thread-safe. Not synchronized. Best general-purpose Set. Preferred over TreeSet unless sorted required.",
            "useCases": [
                "General-purpose Set",
                "Performance"
            ],
            "realTimeUseCases": [
                "Unique product tags, deduplication"
            ]
        },
        {
            "id": 337,
            "name": "HashSet interface implementation",
            "question": "What interface does HashSet implement?",
            "answer": "HashSet implements: Set<E> (primary), Collection<E>, Iterable<E>, Serializable, Cloneable. Class: public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable. Internally uses HashMap<E, Object>. No RandomAccess (no indexed access). Generic: HashSet<Type>.",
            "useCases": [
                "Interface hierarchy",
                "Type contract"
            ],
            "realTimeUseCases": [
                "Set<String> tags = new HashSet<>();"
            ]
        },
        {
            "id": 338,
            "name": "HashSet internal working",
            "question": "How HashSet works internally?",
            "answer": "Internal: uses HashMap<E, Object> (each element is key, dummy Object is value). add(E): calls hashCode(), equals() to check duplicates, adds to HashMap. Performance O(1) average, O(n) worst (many collisions). No order guarantee (depends on hash distribution). Resize when load factor exceeded (0.75).",
            "useCases": [
                "Internal mechanism",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Understanding HashSet performance"
            ]
        },
        {
            "id": 339,
            "name": "HashSet data structure",
            "question": "What data structure HashSet uses internally?",
            "answer": "Data structure: HashMap<E, Object>. Underlying: Node<K,V>[] array (hash table). Each Node: hash, key (element), value (dummy Object.class), next (for chaining). Buckets store chains of collided elements. Load factor tracks fill ratio. Capacity starts at 16, doubles when exceeded.",
            "useCases": [
                "Memory model",
                "Data structure"
            ],
            "realTimeUseCases": [
                "Internally: HashMap with element keys"
            ]
        },
        {
            "id": 340,
            "name": "HashSet hashCode equals role",
            "question": "What is hashCode() and equals() role in HashSet?",
            "answer": "hashCode(): returns bucket index (hash distribution). equals(): checks element equality within bucket. Flow: hashCode() finds bucket, equals() checks duplicates. Contract: equal objects must have same hash. If not implemented: default implementation used (reference equality). Must override both for custom objects.",
            "useCases": [
                "Object identity",
                "Duplicate detection"
            ],
            "realTimeUseCases": [
                "Custom class must override hashCode() and equals()"
            ]
        },
        {
            "id": 341,
            "name": "HashSet duplicates",
            "question": "Does HashSet allow duplicates?",
            "answer": "No, HashSet enforces uniqueness. add(element): checks duplicates via equals(). If exists, add returns false, element not added. Size doesn't change. Example: set.add(1); set.add(1); set.size() remains 1. Duplicates silently rejected. HashSet maintains mathematical set property.",
            "useCases": [
                "Uniqueness",
                "Deduplication"
            ],
            "realTimeUseCases": [
                "Only unique products in wishlist"
            ]
        },
        {
            "id": 342,
            "name": "HashSet null values",
            "question": "Does HashSet allow null values?",
            "answer": "Yes, HashSet allows ONE null (null is valid key in HashMap). set.add(null) works. Adding second null: add returns false (duplicate). Useful for optional values. However, null in set can cause issues (NullPointerException in operations). Best practice: avoid null, use Optional<T>.",
            "useCases": [
                "Null handling",
                "Safety"
            ],
            "realTimeUseCases": [
                "Optional middle name in user set"
            ]
        },
        {
            "id": 343,
            "name": "HashSet thread safety",
            "question": "Is HashSet thread-safe?",
            "answer": "No, HashSet is NOT thread-safe. No synchronization on operations. Concurrent modifications â†’ ConcurrentModificationException. Multi-threaded: use Collections.synchronizedSet(new HashSet<>()), CopyOnWriteArraySet (small sets), or explicit synchronization. HashSet designed for single-threaded or externally synchronized use.",
            "useCases": [
                "Threading",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Single-threaded tag deduplication"
            ]
        },
        {
            "id": 344,
            "name": "When to use HashSet",
            "question": "When to use HashSet?",
            "answer": "Use HashSet: uniqueness required, order irrelevant, fast contains/add/remove needed, general-purpose set. Avoid: need sorted data (use TreeSet), need insertion order (use LinkedHashSet), frequent iteration of small set (overhead). Default choice for Set unless specific requirement.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Product categories, email addresses, user IDs"
            ]
        },
        {
            "id": 345,
            "name": "HashSet advantages disadvantages",
            "question": "Advantages & disadvantages of HashSet?",
            "answer": "Advantages: O(1) fast operations, unordered (no sort overhead), memory efficient, simple API. Disadvantages: no order guarantee, null safe but awkward, not thread-safe, iteration order unpredictable, hashCode/equals overhead, collision resolution cost. Trade-off: speed for order.",
            "useCases": [
                "Strengths & weaknesses",
                "Analysis"
            ],
            "realTimeUseCases": [
                "Fast tag deduplication vs unpredictable order"
            ]
        },
        {
            "id": 346,
            "name": "HashSet eCommerce usage",
            "question": "Where did you use HashSet in real-time eCommerce?",
            "answer": "HashSet usage: deduplicating product tags (Set<String> tags = new HashSet<>(tagList)), storing unique categories, customer wishlist (Set<Product>), tracking viewed products, unique promo codes, user email validation (check duplicates). Performance: O(1) contains() fast for membership checks.",
            "useCases": [
                "Project experience",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Wishlist management, tag deduplication"
            ]
        },
        {
            "id": 347,
            "name": "LinkedHashSet definition",
            "question": "What is LinkedHashSet?",
            "answer": "LinkedHashSet: extends HashSet, maintains insertion order using doubly-linked list. Combines HashSet's speed O(1) with LinkedList's order preservation. Slightly slower than HashSet (linked list overhead). Allows one null. Not thread-safe. Use when insertion order matters but uniqueness critical.",
            "useCases": [
                "Ordered Set",
                "Insertion order"
            ],
            "realTimeUseCases": [
                "Browse history (unique URLs in order)"
            ]
        },
        {
            "id": 348,
            "name": "LinkedHashSet internal working",
            "question": "How LinkedHashSet works internally?",
            "answer": "Internal: extends HashSet, uses HashMap + doubly-linked list (header node). HashMap provides O(1) operations, linked list maintains insertion order. add(E): stores in HashMap bucket, adds to list end. Iteration follows list order (not hash table). Performance: slightly slower than HashSet (list maintenance).",
            "useCases": [
                "Internal mechanism",
                "Ordering"
            ],
            "realTimeUseCases": [
                "Understanding order preservation"
            ]
        },
        {
            "id": 349,
            "name": "LinkedHashSet preserves insertion order",
            "question": "Why LinkedHashSet preserves insertion order?",
            "answer": "Order preservation: doubly-linked list (not HashMap hash buckets). First add: element added to hash table, linked to list tail. Iteration: follows list order (insertion order), not hash table. Cost: extra memory (pointers), slower than HashSet. Benefit: predictable iteration order.",
            "useCases": [
                "Order preservation",
                "Design"
            ],
            "realTimeUseCases": [
                "Maintaining add sequence"
            ]
        },
        {
            "id": 350,
            "name": "LinkedHashSet over HashSet",
            "question": "When to use LinkedHashSet over HashSet?",
            "answer": "Use LinkedHashSet: insertion order matters (unique items in order), predictable iteration required, slight performance hit acceptable. Examples: browser history, undo stack (unique items), playlist (unique songs in order). Use HashSet: order irrelevant, speed critical. Rule: if order needed, LinkedHashSet; else HashSet.",
            "useCases": [
                "Selection",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Recently viewed products in order"
            ]
        },
        {
            "id": 351,
            "name": "TreeSet definition",
            "question": "What is TreeSet?",
            "answer": "TreeSet: sorted Set using Red-Black tree (binary search tree). Unique elements stored in ascending order (natural or custom Comparator). O(logn) add/remove/contains. No null (compareTo needs order). Not thread-safe. Use when sorted data required. More overhead than HashSet.",
            "useCases": [
                "Sorted Set",
                "Ordering"
            ],
            "realTimeUseCases": [
                "Sorted product prices, alphabetical tags"
            ]
        },
        {
            "id": 352,
            "name": "TreeSet internal working",
            "question": "How TreeSet works internally (Red-Black Tree)?",
            "answer": "Internal: NavigableMap<E, Object> (TreeMap) backed by Red-Black tree. Red-Black tree: self-balancing BST with color properties (red/black nodes). add(E): maintains tree balance, calls compareTo() for ordering. Iteration: in-order traversal (sorted order). O(logn) operations guaranteed by tree balance.",
            "useCases": [
                "Internal mechanism",
                "Tree structure"
            ],
            "realTimeUseCases": [
                "Understanding sorted ordering"
            ]
        },
        {
            "id": 353,
            "name": "TreeSet sorted order",
            "question": "Why TreeSet stores data in sorted order?",
            "answer": "Sorted order: Red-Black tree structure inherently maintains order via compareTo(). Left subtree < root < right subtree. In-order traversal yields sorted elements. Natural sort: Comparable<E> implementation. Custom sort: Comparator passed to constructor. Overhead: sorting during add() (O(logn)). Benefit: always sorted, range queries easy.",
            "useCases": [
                "Sorting",
                "Order guarantee"
            ],
            "realTimeUseCases": [
                "Leaderboard scores in order"
            ]
        },
        {
            "id": 354,
            "name": "TreeSet null",
            "question": "Does TreeSet allow null?",
            "answer": "No, TreeSet does NOT allow null. Throws NullPointerException on add(null). Reason: compareTo() needed for ordering, null.compareTo() invalid. Different from HashSet (allows null). Use Optional<T> for optional values. TreeSet must maintain order, null breaks ordering logic.",
            "useCases": [
                "Null safety",
                "Ordering"
            ],
            "realTimeUseCases": [
                "All values must be comparable"
            ]
        },
        {
            "id": 355,
            "name": "When to use TreeSet",
            "question": "When should we use TreeSet?",
            "answer": "Use TreeSet: sorted data required, range queries needed (subSet), iteration in order important, natural ordering available. Avoid: order irrelevant (use HashSet, faster), frequent updates (O(logn) vs O(1)), null values (not allowed). TreeSet for sorted scenarios.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Top 10 products by rating, student scores sorted"
            ]
        },
        {
            "id": 356,
            "name": "TreeSet disadvantages",
            "question": "What are the disadvantages of TreeSet?",
            "answer": "Disadvantages: slower than HashSet (O(logn) vs O(1)), no null support, tree overhead (memory, rebalancing), complex comparison logic needed, not thread-safe, iteration slower (tree traversal). Use only when sorting critical. HashSet preferred for general use.",
            "useCases": [
                "Weaknesses",
                "Limitations"
            ],
            "realTimeUseCases": [
                "Higher overhead for simple deduplication"
            ]
        },
        {
            "id": 357,
            "name": "Queue interface definition",
            "question": "What is Queue in Java?",
            "answer": "Queue: Collection designed for holding elements prior to processing. FIFO (First-In-First-Out) ordering. Methods: add(E)/offer(E) add, remove()/poll() remove from front, element()/peek() view front. Extends Collection. Implementations: PriorityQueue, LinkedList, ArrayDeque, Deque (double-ended). Core abstraction for task processing.",
            "useCases": [
                "FIFO data structure",
                "Task processing"
            ],
            "realTimeUseCases": [
                "Order queue, message queue"
            ]
        },
        {
            "id": 358,
            "name": "Queue FIFO ordering",
            "question": "How does Queue follow FIFO?",
            "answer": "FIFO (First-In-First-Out): first element added is first removed. add(1), add(2), add(3) â†’ remove returns 1, then 2, then 3. Front of queue (head): next to be removed. Back of queue (tail): next insertion point. Methods enforce FIFO: poll() always removes head, add() always adds to tail.",
            "useCases": [
                "FIFO order",
                "Logic"
            ],
            "realTimeUseCases": [
                "Printer queue, task scheduler"
            ]
        },
        {
            "id": 359,
            "name": "Queue implementations",
            "question": "What are the implementations of Queue?",
            "answer": "Implementations: PriorityQueue (priority-based), LinkedList (FIFO linked list), ArrayDeque (FIFO array deque), Deque implementations (double-ended). ConcurrentLinkedQueue (thread-safe, unbounded), BlockingQueue variants (blocking operations). Choose: PriorityQueue (priority), LinkedList (basic FIFO), ArrayDeque (fast FIFO with deque ops).",
            "useCases": [
                "Implementation choices",
                "Selection"
            ],
            "realTimeUseCases": [
                "LinkedList for FIFO, PriorityQueue for priority tasks"
            ]
        },
        {
            "id": 360,
            "name": "PriorityQueue definition",
            "question": "What is PriorityQueue?",
            "answer": "PriorityQueue: Queue where elements removed by priority, not FIFO. Uses min-heap (by default). Priority via Comparable or Comparator. poll() returns highest priority (smallest). Useful for: task scheduling, Dijkstra's algorithm, event processing. O(logn) add/remove. Not thread-safe. Null not allowed.",
            "useCases": [
                "Priority queue",
                "Heap-based"
            ],
            "realTimeUseCases": [
                "Task scheduler, CPU scheduling"
            ]
        },
        {
            "id": 361,
            "name": "PriorityQueue internal working",
            "question": "How PriorityQueue works internally?",
            "answer": "Internal: binary heap (array-based tree). add(E): inserts at end, bubbles up (maintains heap property). poll(): removes root (min), replaces with last, bubbles down. peek(): returns root without removal. O(logn) add/remove, O(1) peek. Heap ensures priority order. Not strictly sorted (only root is min).",
            "useCases": [
                "Internal mechanism",
                "Heap structure"
            ],
            "realTimeUseCases": [
                "Understanding priority ordering"
            ]
        },
        {
            "id": 362,
            "name": "PriorityQueue binary heap",
            "question": "What is a heap (binary heap) in PriorityQueue?",
            "answer": "Binary heap: complete binary tree where parent â‰¤ children (min-heap). Array representation: parent at index i, left child at 2i+1, right at 2i+2. Min-heap ensures: root is minimum. Operations: bubbleUp (add), bubbleDown (remove). Efficient: O(logn) operations. Not sorted array (heap property weaker).",
            "useCases": [
                "Data structure",
                "Ordering"
            ],
            "realTimeUseCases": [
                "Heap operations"
            ]
        },
        {
            "id": 363,
            "name": "PriorityQueue insertion order",
            "question": "Does PriorityQueue maintain insertion order?",
            "answer": "No, PriorityQueue does NOT maintain insertion order. Elements ordered by priority (min at root). Example: add(3), add(1), add(2) â†’ iterator yields 1, 2, 3 (priority order), not 3, 1, 2 (insertion). FIFO guarantee not given. Only guarantee: poll() returns min (highest priority first).",
            "useCases": [
                "Order guarantee",
                "Priority"
            ],
            "realTimeUseCases": [
                "Task execution by priority, not arrival order"
            ]
        },
        {
            "id": 364,
            "name": "When to use PriorityQueue",
            "question": "When to use PriorityQueue?",
            "answer": "Use PriorityQueue: priority matters (not FIFO), task scheduling, Dijkstra's algorithm, min/max heap needed. Examples: process high-priority orders first, medical emergency triage, CPU scheduling. Avoid: simple FIFO (use LinkedList/ArrayDeque, faster O(1)), maintain insertion order (use Queue).",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "VIP order processing, urgent request handling"
            ]
        },
        {
            "id": 365,
            "name": "Deque interface definition",
            "question": "What is Deque in Java?",
            "answer": "Deque (Double-Ended Queue): allows insertion/removal from both ends. Extends Queue. Methods: addFirst(E), addLast(E), removeFirst(), removeLast(), getFirst(), getLast(), pollFirst(), pollLast(). Supports both FIFO (Queue) and LIFO (Stack) operations. Implementations: LinkedList, ArrayDeque. Flexible for various patterns.",
            "useCases": [
                "Double-ended queue",
                "Flexible operations"
            ],
            "realTimeUseCases": [
                "Browser history, undo/redo"
            ]
        },
        {
            "id": 366,
            "name": "Deque implementations",
            "question": "What are the implementations of Deque (ArrayDeque, LinkedList)?",
            "answer": "Implementations: ArrayDeque (resizable array, preferred, faster), LinkedList (doubly-linked, supports both List and Deque ops), ConcurrentLinkedDeque (thread-safe). ArrayDeque preferred for most cases (performance). LinkedList better if need List methods (get, set by index) alongside Deque. Both support FIFO, LIFO, bidirectional access.",
            "useCases": [
                "Implementation choices",
                "Selection"
            ],
            "realTimeUseCases": [
                "Deque<Item> stack = new ArrayDeque<>();"
            ]
        },
        {
            "id": 367,
            "name": "When to use Deque",
            "question": "When to use Deque?",
            "answer": "Use Deque: need both FIFO and LIFO operations, or flexible insertion/removal from ends. Undo/redo (add to both ends), sliding window (remove from front), palindrome check (add/remove ends). Prefer ArrayDeque over Stack (outdated). LinkedList if also need List methods. Flexible compared to Queue or Stack alone.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Browser navigation, undo queue"
            ]
        },
        {
            "id": 368,
            "name": "ArrayDeque definition",
            "question": "What is ArrayDeque?",
            "answer": "ArrayDeque: resizable array implementation of Deque. Combines array efficiency with deque flexibility. O(1) add/remove at both ends. O(1) random access (like ArrayList). Faster than LinkedList for most operations. Not thread-safe. Null not allowed. Preferred Deque implementation.",
            "useCases": [
                "Deque implementation",
                "Performance"
            ],
            "realTimeUseCases": [
                "Stack operations, sliding window"
            ]
        },
        {
            "id": 369,
            "name": "ArrayDeque internal working",
            "question": "How ArrayDeque works internally?",
            "answer": "Internal: circular array (head and tail pointers). Wraps around: tail wraps to start, head wraps to end. addFirst(E): adds before head. addLast(E): adds after tail. removeFirst/removeLast: updates pointers. Resizes when full: doubles capacity. O(1) amortized for add/remove. Circular design enables efficient both-end operations.",
            "useCases": [
                "Internal mechanism",
                "Circular array"
            ],
            "realTimeUseCases": [
                "Understanding deque efficiency"
            ]
        },
        {
            "id": 370,
            "name": "ArrayDeque faster than Stack LinkedList",
            "question": "Why ArrayDeque is faster than Stack and LinkedList for deque operations?",
            "answer": "Faster because: array access O(1) vs linked list traversal O(n) for random access, no object allocation per node (linked list), cache-friendly (contiguous memory), circular array enables efficient both-end ops. Stack (extends Vector) has synchronization overhead. ArrayDeque: speed + flexibility. Preferred modern replacement.",
            "useCases": [
                "Performance",
                "Comparison"
            ],
            "realTimeUseCases": [
                "Bulk undo operations, sliding window"
            ]
        },
        {
            "id": 371,
            "name": "When use ArrayDeque",
            "question": "When should we use ArrayDeque?",
            "answer": "Use ArrayDeque: need deque operations (both ends), performance critical (O(1) operations), stack/queue needed (replaces Stack, LinkedList for these), bidirectional iteration. Avoid: need List methods (use LinkedList if necessary), thread-safety (use ConcurrentLinkedDeque), null values (not allowed). Default Deque choice.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Task undo/redo, sliding window algorithm"
            ]
        },
        {
            "id": 372,
            "name": "Map interface definition",
            "question": "What is Map interface?",
            "answer": "Map: interface for key-value pairs. Keys must be unique (mapped to one value each). Values can be duplicated. Does NOT extend Collection (different hierarchy). Methods: put(K,V), get(K), remove(K), keySet(), values(), entrySet(), size(), containsKey(K). Implementations: HashMap, TreeMap, LinkedHashMap, ConcurrentHashMap, Hashtable.",
            "useCases": [
                "Key-value mapping",
                "Association"
            ],
            "realTimeUseCases": [
                "User sessions, product catalog lookup"
            ]
        },
        {
            "id": 373,
            "name": "Why Map key-value pairs",
            "question": "Why Map stores data in key-value pairs?",
            "answer": "Key-value pairs: represent associations/relationships. Key identifies value uniquely. Example: userId â†’ User object, email â†’ password hash, productId â†’ Product. Enables: fast lookup by key O(1), semantic meaning (key explains value), natural data model (domain objects have identifiers). Maps suit many real-world scenarios.",
            "useCases": [
                "Design rationale",
                "Modeling"
            ],
            "realTimeUseCases": [
                "Database records: id â†’ entity"
            ]
        },
        {
            "id": 374,
            "name": "Map vs Collection difference",
            "question": "What is the difference between Map and Collection?",
            "answer": "Collection: single values (List, Set, Queue). Map: key-value pairs. Collection indexed by position/hash, Map indexed by key. Collection extends Iterable, Map doesn't (entrySet iteration). Different semantics: Collection for groups, Map for associations. Size meaning different: Map size is entries (key-value), Collection size is elements.",
            "useCases": [
                "Type distinction",
                "Semantics"
            ],
            "realTimeUseCases": [
                "List<String> names vs Map<String, String> nameToEmail"
            ]
        },
        {
            "id": 375,
            "name": "Map implementations",
            "question": "What are the implementations of Map?",
            "answer": "Implementations: HashMap (hash table, unordered, fast O(1)), TreeMap (Red-Black tree, sorted, O(logn)), LinkedHashMap (insertion-order, maintains linked list), ConcurrentHashMap (thread-safe, segment locking), Hashtable (legacy, synchronized), WeakHashMap (weak references), IdentityHashMap (reference equality). Choose: HashMap (general), TreeMap (sorted), ConcurrentHashMap (multi-threaded).",
            "useCases": [
                "Implementation choices",
                "Selection"
            ],
            "realTimeUseCases": [
                "HashMap for sessions, TreeMap for sorted prices"
            ]
        },
        {
            "id": 376,
            "name": "Map null keys values",
            "question": "Can Map have null keys and null values?",
            "answer": "Depends on implementation: HashMap allows one null key and multiple null values. TreeMap allows null values but NO null keys (compareTo fails). ConcurrentHashMap allows null values but NO null keys. Hashtable allows no nulls (legacy, synchronized). Best practice: avoid nulls, use meaningful keys/values. Check implementation docs.",
            "useCases": [
                "Null safety",
                "Implementation specific"
            ],
            "realTimeUseCases": [
                "Optional values: use Optional<V> instead of null"
            ]
        },
        {
            "id": 377,
            "name": "When use Map in real-time",
            "question": "When to use Map in real-time?",
            "answer": "Use Map: need key-value associations, fast lookup by key, one-to-one mapping, caching (key â†’ cached value), configuration (key â†’ setting), indexing (id â†’ object), session storage (sessionId â†’ user). Examples: user sessions, product prices, customer profiles, configuration properties.",
            "useCases": [
                "Best practice",
                "Real-world"
            ],
            "realTimeUseCases": [
                "Shopping cart: productId â†’ quantity"
            ]
        },
        {
            "id": 378,
            "name": "HashMap definition",
            "question": "What is HashMap?",
            "answer": "HashMap: implementation of Map using hash table. Unordered (no insertion/sort order). Fast add/get/remove O(1) average. Allows null key (one) and null values (many). Not thread-safe. Not synchronized. General-purpose Map. Most used Map implementation.",
            "useCases": [
                "General-purpose map",
                "Performance"
            ],
            "realTimeUseCases": [
                "User session storage, product lookup"
            ]
        },
        {
            "id": 379,
            "name": "HashMap interface implementation",
            "question": "What interface does HashMap implement?",
            "answer": "HashMap implements: Map<K,V> (primary), Cloneable, Serializable. Class: public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable. AbstractMap provides default implementations. Generic: HashMap<KeyType, ValueType>. No RandomAccess (no indexed access).",
            "useCases": [
                "Interface hierarchy",
                "Type contract"
            ],
            "realTimeUseCases": [
                "Map<String, User> users = new HashMap<>();"
            ]
        },
        {
            "id": 380,
            "name": "HashMap syntax",
            "question": "What is the syntax of HashMap?",
            "answer": "Syntax: Map<K,V> map = new HashMap<>(); or HashMap<K,V> map = new HashMap<>();. K: key type, V: value type. With capacity: new HashMap<>(20). Load factor: new HashMap<>(16, 0.75f). Copy constructor: new HashMap<>(otherMap). Examples: Map<String, Integer> map = new HashMap<>();",
            "useCases": [
                "Declaration",
                "Creation"
            ],
            "realTimeUseCases": [
                "Map<String, User> userMap = new HashMap<>();"
            ]
        },
        {
            "id": 381,
            "name": "HashMap internal working",
            "question": "How HashMap works internally?",
            "answer": "Internal: Node<K,V>[] array (hash table). put(K,V): computes hash, finds bucket, adds node (or updates existing key). get(K): computes hash, finds bucket, returns value. Collision: linked list (or balanced tree in Java 8+). Resize when load factor exceeded. O(1) average, O(n) worst (many collisions).",
            "useCases": [
                "Internal mechanism",
                "Performance"
            ],
            "realTimeUseCases": [
                "Understanding HashMap performance"
            ]
        },
        {
            "id": 382,
            "name": "HashMap internal data structure",
            "question": "What internal data structure HashMap uses?",
            "answer": "Data structure: Node<K,V>[] array (hash table). Each Node: hash, key, value, next (for linked list). Buckets (array slots) store node chains. Load factor tracks fill ratio. Capacity starts at 16, doubles on resize. Java 8+: tree (Red-Black) if bucket chain >8 (performance optimization).",
            "useCases": [
                "Memory model",
                "Data structure"
            ],
            "realTimeUseCases": [
                "Internally: array of linked lists/trees"
            ]
        },
        {
            "id": 383,
            "name": "Hashing definition",
            "question": "What is hashing?",
            "answer": "Hashing: converting input (any object) to hash code (integer). Hash function deterministic: same input â†’ same hash. Distributes values across buckets (arrays). Goal: minimize collisions (different keys â†’ different hashes). Hash function quality affects performance (poor hash = many collisions). Used for: HashSet, HashMap, hashtables.",
            "useCases": [
                "Algorithm",
                "Distribution"
            ],
            "realTimeUseCases": [
                "HashMap bucket selection via hash()"
            ]
        },
        {
            "id": 384,
            "name": "HashMap hashCode equals role",
            "question": "What is hashCode() and equals() role in HashMap?",
            "answer": "hashCode(): determines bucket index (hash distribution). equals(): checks key equality within bucket. Flow: hashCode() finds bucket, equals() finds exact key. Contract: equal keys must have same hash. If not implemented: default used (reference equality). Must override both for custom keys.",
            "useCases": [
                "Key identity",
                "Lookup"
            ],
            "realTimeUseCases": [
                "Custom User class must override hashCode() and equals()"
            ]
        },
        {
            "id": 385,
            "name": "HashMap bucket definition",
            "question": "What is a bucket in HashMap?",
            "answer": "Bucket: array slot holding nodes (key-value pairs). Hash code determines bucket index: index = hashCode() % capacity. Multiple keys can hash to same bucket (collision). Bucket contains: null (empty), single node (no collision), linked list/tree (collision chain). Ideal: each bucket has ~1 node (distribution matters).",
            "useCases": [
                "Hash table structure",
                "Collision handling"
            ],
            "realTimeUseCases": [
                "Understanding bucket distribution"
            ]
        },
        {
            "id": 386,
            "name": "HashMap collision",
            "question": "What is collision? How collisions are resolved?",
            "answer": "Collision: two keys hash to same bucket. Resolution: separate chaining (Java 8+). Before Java 8: linked list. Java 8+: linked list if chain â‰¤8, converts to Red-Black tree if >8 (balances tree when tree size >6). cost: O(1) to O(logn) depending on chain length. Good hash function minimizes collisions.",
            "useCases": [
                "Collision handling",
                "Performance"
            ],
            "realTimeUseCases": [
                "Poor hash = many collisions = slow lookup"
            ]
        },
        {
            "id": 387,
            "name": "HashMap separate chaining",
            "question": "What is separate chaining?",
            "answer": "Separate chaining: collision resolution storing all colliding nodes in same bucket (linked list). put(k1, v1), put(k2, v2) hash to same bucket â†’ chain forms. Lookup: iterate chain checking equals(). Trade-off: simple but chain can grow (O(n) worst). Java 8+: tree conversion for >8 nodes improves worst-case to O(logn).",
            "useCases": [
                "Collision resolution",
                "Algorithm"
            ],
            "realTimeUseCases": [
                "Multiple users same city code"
            ]
        },
        {
            "id": 388,
            "name": "HashMap load factor",
            "question": "What is load factor in HashMap?",
            "answer": "Load factor: ratio of entries to capacity (size / capacity). Default: 0.75. Threshold: when load factor â‰¥ 0.75, HashMap resizes (doubles capacity). Example: capacity 16, 12 entries â†’ resize to 32. Resizing prevents chain growth (keeps load factor reasonable). Lower load factor = faster lookup, higher memory. 0.75 balances speed/memory.",
            "useCases": [
                "Capacity management",
                "Performance"
            ],
            "realTimeUseCases": [
                "HashMap resizes at 12/16 entries"
            ]
        },
        {
            "id": 389,
            "name": "HashMap duplicates",
            "question": "Does HashMap allow duplicates?",
            "answer": "Keys: NO duplicates (uniqueness enforced). put(k1, v1), put(k1, v2) â†’ second overwrites first. Values: YES duplicates allowed. Multiple keys can map to same value. Duplicate key: put() returns old value, updates map. Useful: values often duplicated (multiple keys same value).",
            "useCases": [
                "Key uniqueness",
                "Value duplicates"
            ],
            "realTimeUseCases": [
                "Multiple users same role"
            ]
        },
        {
            "id": 390,
            "name": "HashMap null support",
            "question": "Does HashMap allow null keys and null values?",
            "answer": "Yes, HashMap allows: one null key (unique), multiple null values. put(null, value) valid. get(null) returns value or null. Useful for optional mappings. However, null handling can be tricky (null in lookup ambiguous: key missing vs value is null). Best practice: avoid nulls, use meaningful keys/values.",
            "useCases": [
                "Null handling",
                "Safety"
            ],
            "realTimeUseCases": [
                "Optional: User.getMiddleName() â†’ null possible"
            ]
        },
        {
            "id": 391,
            "name": "HashMap thread safety",
            "question": "Is HashMap thread-safe?",
            "answer": "No, HashMap is NOT thread-safe. No synchronization on operations. Concurrent modifications â†’ ConcurrentModificationException. Multi-threaded: use ConcurrentHashMap (preferred, segment locking), Collections.synchronizedMap(new HashMap<>()), Hashtable (legacy). HashMap designed for single-threaded or externally synchronized use.",
            "useCases": [
                "Threading",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Single-threaded user sessions"
            ]
        },
        {
            "id": 392,
            "name": "HashMap same hash keys",
            "question": "What happens if two keys generate the same hash?",
            "answer": "Hash collision: both keys hash to same bucket index. Resolution: separate chaining (linked list). Both nodes stored in same bucket. Lookup: hashCode() finds bucket, equals() finds exact key. Performance degrades if many collisions (long chains). Hash collision inevitable (pigeonhole principle), good hash minimizes.",
            "useCases": [
                "Collision handling",
                "Performance"
            ],
            "realTimeUseCases": [
                "John and Jane both hash to bucket 5"
            ]
        },
        {
            "id": 393,
            "name": "HashMap default capacity",
            "question": "What is the default capacity of HashMap?",
            "answer": "Default capacity: 16. Load factor threshold: 0.75 (12 entries). First resize: capacity 32 at 13th entry. Capacity always power of 2 (optimization). Can specify: new HashMap<>(100) sets initial capacity 100. Larger initial capacity avoids resizing (if size known). Too large: waste memory.",
            "useCases": [
                "Memory allocation",
                "Optimization"
            ],
            "realTimeUseCases": [
                "new HashMap<>(1000) for known large map"
            ]
        },
        {
            "id": 394,
            "name": "When should use HashMap",
            "question": "When should we use HashMap?",
            "answer": "Use HashMap: fast key-value lookups (O(1)), order irrelevant, general-purpose map, caching, session storage. Avoid: need sorted keys (use TreeMap), insertion order matters (use LinkedHashMap), multi-threaded (use ConcurrentHashMap). Default choice for Map.",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "User sessions, product catalog, caching"
            ]
        },
        {
            "id": 395,
            "name": "HashMap advantages disadvantages",
            "question": "Advantages & disadvantages of HashMap?",
            "answer": "Advantages: O(1) fast operations, simple API, null support, flexible, widely used. Disadvantages: no order guarantee, null handling awkward, not thread-safe, collision overhead (poor hash), iteration order unpredictable. Trade-off: speed for order.",
            "useCases": [
                "Strengths & weaknesses",
                "Analysis"
            ],
            "realTimeUseCases": [
                "Fast caching vs unpredictable order"
            ]
        },
        {
            "id": 396,
            "name": "HashMap vs Hashtable",
            "question": "HashMap vs HashTable?",
            "answer": "HashMap: unsynchronized, fast, allows null, modern (Java 1.2+). Hashtable: synchronized (all methods), slow, no null, legacy (Java 1.0). Performance: HashMap 2-3x faster (no sync overhead). Hashtable obsolete (ConcurrentHashMap preferred for threading). Use HashMap unless legacy compatibility required.",
            "useCases": [
                "Comparison",
                "History"
            ],
            "realTimeUseCases": [
                "Use HashMap, not Hashtable"
            ]
        },
        {
            "id": 397,
            "name": "HashMap vs ConcurrentHashMap",
            "question": "HashMap vs ConcurrentHashMap?",
            "answer": "HashMap: unsynchronized, fast single-threaded. ConcurrentHashMap: synchronized (segment locking, finer granularity), safe multi-threaded. Performance: ConcurrentHashMap slower than HashMap (locking), faster than Hashtable (not all-method sync). Use HashMap single-threaded, ConcurrentHashMap multi-threaded.",
            "useCases": [
                "Comparison",
                "Threading"
            ],
            "realTimeUseCases": [
                "HashMap for API, ConcurrentHashMap for shared cache"
            ]
        },
        {
            "id": 398,
            "name": "HashMap eCommerce project",
            "question": "Where did you use HashMap in your real-time NMG eCommerce project?",
            "answer": "HashMap usage: user sessions (sessionId â†’ User), product catalog (productId â†’ Product), shopping cart (productId â†’ CartItem quantity), order lookup (orderId â†’ Order), caching (userId â†’ UserProfile cache), configuration (setting name â†’ value). Performance: O(1) lookups fast for frequent access.",
            "useCases": [
                "Project experience",
                "Implementation"
            ],
            "realTimeUseCases": [
                "Session storage, product lookup cache"
            ]
        },
        {
            "id": 399,
            "name": "HashMap eCommerce example",
            "question": "Real-time eCommerce use case example (caching, product lookup, sessions, cart).",
            "answer": "Example: Map<String, User> userSessions = new HashMap<>(); sessionId â†’ User mapping. userSessions.put(sessionId, user); userSessions.get(sessionId); Map<Integer, Product> catalog = new HashMap<>(); productId â†’ Product cache. Fast lookup O(1). Cart: Map<Integer, Integer> cart; productId â†’ quantity. Total = 0; for(int qty : cart.values()) total += qty;",
            "useCases": [
                "Code example",
                "Real-world"
            ],
            "realTimeUseCases": [
                "Session management, product catalog"
            ]
        },
        {
            "id": 400,
            "name": "LinkedHashMap definition",
            "question": "What is LinkedHashMap?",
            "answer": "LinkedHashMap: extends HashMap, maintains insertion order using doubly-linked list. Combines HashMap's O(1) speed with insertion order preservation. Slightly slower than HashMap (list overhead). Two modes: insertion-order (default), access-order (LRU cache). Allows null key/values like HashMap. Thread-safe: No.",
            "useCases": [
                "Ordered map",
                "Insertion order"
            ],
            "realTimeUseCases": [
                "Recent searches, LRU cache"
            ]
        },
        {
            "id": 401,
            "name": "LinkedHashMap insertion order preservation",
            "question": "Why LinkedHashMap preserves insertion order?",
            "answer": "Order preservation: doubly-linked list (not HashMap buckets). First put: stored in HashMap bucket, linked to list tail. Iteration: follows list order (insertion order), not hash table. Insertion order guaranteed across iterators. Access-order mode: LRU cache (move accessed element to tail). Cost: extra memory (pointers), slower than HashMap.",
            "useCases": [
                "Order preservation",
                "Design"
            ],
            "realTimeUseCases": [
                "Maintaining insertion sequence"
            ]
        },
        {
            "id": 402,
            "name": "LinkedHashMap internal working",
            "question": "How LinkedHashMap works internally?",
            "answer": "Internal: extends HashMap, uses doubly-linked list (header node). HashMap provides O(1) operations, linked list maintains insertion order. put(K,V): stores in HashMap, adds to list tail. get(K): retrieves from HashMap, optionally updates list position (access-order). Iteration follows list, not hash table.",
            "useCases": [
                "Internal mechanism",
                "Ordering"
            ],
            "realTimeUseCases": [
                "Understanding order maintenance"
            ]
        },
        {
            "id": 403,
            "name": "LinkedHashMap over HashMap",
            "question": "When should we use LinkedHashMap instead of HashMap?",
            "answer": "Use LinkedHashMap: insertion order important (FIFO), predictable iteration required, access-order LRU cache needed. Examples: configuration (maintain key order), recent searches (newest last), LRU cache (evict least recently used). Use HashMap: order irrelevant, speed critical (no list overhead). LinkedHashMap slight performance trade-off for order.",
            "useCases": [
                "Selection",
                "Best practice"
            ],
            "realTimeUseCases": [
                "Recently visited products, FIFO processing"
            ]
        },
        {
            "id": 404,
            "name": "LinkedHashMap access-order insertion-order",
            "question": "What are access-order and insertion-order maps?",
            "answer": "Insertion-order (default): new LinkedHashMap<>() maintains insertion order. put() adds to tail. Access-order: new LinkedHashMap<>(capacity, loadFactor, true) moves accessed element to tail. LRU cache: removeEldestEntry() override evicts least recently used. Useful: cache eviction (remove oldest/least-used entry when full).",
            "useCases": [
                "Ordering modes",
                "Caching"
            ],
            "realTimeUseCases": [
                "LRU cache implementation"
            ]
        },
        {
            "id": 405,
            "name": "TreeMap definition",
            "question": "What is TreeMap?",
            "answer": "TreeMap: sorted Map using Red-Black tree (binary search tree). Keys stored in ascending order (natural or custom Comparator). O(logn) put/get/remove. No null keys (compareTo fails). Sorted iteration, range queries. Not thread-safe. Use when sorted keys required.",
            "useCases": [
                "Sorted map",
                "Ordering"
            ],
            "realTimeUseCases": [
                "Sorted prices, product categories"
            ]
        },
        {
            "id": 406,
            "name": "TreeMap internal working",
            "question": "How TreeMap works internally? (Red-Black Tree)",
            "answer": "Internal: NavigableMap implementation backed by Red-Black tree (balanced BST). put(K,V): calls compareTo() for insertion position, maintains tree balance. get(K): traverses tree via compareTo(). Iteration: in-order traversal (sorted order). O(logn) operations guaranteed by tree balance. Complex rebalancing on insert/delete.",
            "useCases": [
                "Internal mechanism",
                "Tree structure"
            ],
            "realTimeUseCases": [
                "Understanding sorted ordering"
            ]
        },
        {
            "id": 407,
            "name": "TreeMap sorted keys",
            "question": "Why TreeMap stores keys in sorted order?",
            "answer": "Sorted order: Red-Black tree structure inherently maintains order via compareTo(). Left subtree < root < right subtree. In-order traversal yields sorted keys. Natural sort: Comparable<K>. Custom: Comparator passed to constructor. Overhead: sorting during put() (O(logn)). Benefit: always sorted, range queries (subMap) efficient.",
            "useCases": [
                "Sorting",
                "Order guarantee"
            ],
            "realTimeUseCases": [
                "Leaderboard scores in order"
            ]
        },
        {
            "id": 408,
            "name": "TreeMap null support",
            "question": "Does TreeMap allow null?",
            "answer": "No null keys (NullPointerException on put(null, v)). Reason: compareTo() needed for ordering, null.compareTo() invalid. Null values allowed (associated with valid key). Different from HashMap (allows null key). TreeMap must maintain order, null breaks ordering logic.",
            "useCases": [
                "Null safety",
                "Ordering"
            ],
            "realTimeUseCases": [
                "All keys must be comparable"
            ]
        },
        {
            "id": 409,
            "name": "When choose TreeMap",
            "question": "When should we choose TreeMap?",
            "answer": "Use TreeMap: sorted keys required, range queries needed (subMap, headMap, tailMap), iteration in order important, natural ordering available. Avoid: order irrelevant (use HashMap, faster), frequent updates (O(logn) vs O(1)), null keys needed, large dataset (overhead).",
            "useCases": [
                "Best practice",
                "Selection"
            ],
            "realTimeUseCases": [
                "Top 10 products by rating, salary ranges"
            ]
        },
        {
            "id": 410,
            "name": "ConcurrentHashMap definition",
            "question": "What is ConcurrentHashMap?",
            "answer": "ConcurrentHashMap: thread-safe Map using segment locking (not synchronized). Divides map into segments (buckets), each with lock. Multiple threads can access different segments concurrently. O(1) average operations. No null keys/values (NPE checked at compile). Preferred over Hashtable for multi-threaded code.",
            "useCases": [
                "Concurrent map",
                "Threading"
            ],
            "realTimeUseCases": [
                "Shared cache, thread-safe sessions"
            ]
        },
        {
            "id": 411,
            "name": "ConcurrentHashMap thread safety",
            "question": "How does ConcurrentHashMap achieve thread safety?",
            "answer": "Thread safety: segment locking (bucket-level locks). Map divided into 16 segments (default, Java 7), each segment locked independently. Thread 1 locks segment 1, Thread 2 can lock segment 2 (concurrent access). Java 8+: node-level locking (finer granularity). No need to lock entire map. Trade-off: complexity for concurrency.",
            "useCases": [
                "Thread safety",
                "Locking"
            ],
            "realTimeUseCases": [
                "Multiple threads accessing different keys"
            ]
        },
        {
            "id": 412,
            "name": "ConcurrentHashMap segment locking",
            "question": "What is segment locking?",
            "answer": "Segment locking: dividing map into independent segments, each with lock. Concurrent access: different threads lock different segments (no contention). Same segment: serialized (one thread at time). Finer granularity than full map lock. Java 7: 16 default segments. Java 8+: node-level locking (better). Trade-off: memory vs concurrency.",
            "useCases": [
                "Locking strategy",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Parallel processing of map entries"
            ]
        },
        {
            "id": 413,
            "name": "ConcurrentHashMap faster than Hashtable",
            "question": "Why ConcurrentHashMap is faster than Hashtable?",
            "answer": "Faster because: segment locking (allow concurrent access), not synchronized (no method-level sync overhead). Hashtable: synchronized (locks entire map per method). ConcurrentHashMap: multiple threads access different segments in parallel. Throughput: ConcurrentHashMap much better under contention. Both thread-safe but ConcurrentHashMap preferred.",
            "useCases": [
                "Performance",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "Multi-threaded cache with high throughput"
            ]
        },
        {
            "id": 414,
            "name": "ConcurrentHashMap null support",
            "question": "Does ConcurrentHashMap allow null?",
            "answer": "No null keys, no null values (strict no-null policy). Throws NullPointerException on null put/get. Design: null ambiguous in concurrent context (null return: key missing vs value null). HashMap/Hashtable differ (null handling confusing). Best practice: avoid nulls, use meaningful data.",
            "useCases": [
                "Null safety",
                "Design"
            ],
            "realTimeUseCases": [
                "All keys/values must be non-null"
            ]
        },
        {
            "id": 415,
            "name": "ConcurrentHashMap eCommerce usage",
            "question": "When to use ConcurrentHashMap in real-time eCommerce?",
            "answer": "Use ConcurrentHashMap: shared cache (multi-threaded access), session store (many users), product inventory (concurrent updates), order queue (multiple processors), analytics cache (threads reading/updating). Examples: user sessions, product availability, order processing queue. Lock-free reads (visibility guaranteed).",
            "useCases": [
                "Real-world application",
                "Threading"
            ],
            "realTimeUseCases": [
                "Shared user session cache"
            ]
        },
        {
            "id": 416,
            "name": "Collections class definition",
            "question": "What is Collections class?",
            "answer": "Collections: utility class (java.util.Collections) providing static methods for collections. Methods: sort(List), reverse(List), shuffle(List), binarySearch(), min(), max(), copy(), fill(), disjoint(), synchronizedList(), unmodifiableList(). Algorithms working with Collection interface (polymorphic). Not instance creation (static methods only).",
            "useCases": [
                "Utility methods",
                "Algorithms"
            ],
            "realTimeUseCases": [
                "Collections.sort(list), Collections.shuffle(list)"
            ]
        },
        {
            "id": 417,
            "name": "Collections commonly used methods",
            "question": "What are the commonly used methods of Collections (sort, reverse, shuffle)?",
            "answer": "Methods: sort(List<T>) - sorts ascending using natural/Comparator. reverse(List) - reverses order. shuffle(List) - random order. min(Collection), max(Collection) - finds extremes. binarySearch(List, element) - fast search (list must be sorted). copy(destList, srcList) - copies elements. synchronizedList(List) - thread-safe wrapper.",
            "useCases": [
                "Collection operations",
                "Algorithms"
            ],
            "realTimeUseCases": [
                "Sorting products, shuffling options"
            ]
        },
        {
            "id": 418,
            "name": "Collections synchronizedList",
            "question": "What is synchronizedList()?",
            "answer": "synchronizedList(List<T>): wraps list in synchronized wrapper. All methods synchronized (thread-safe). Syntax: List<T> syncList = Collections.synchronizedList(new ArrayList<>()); Single lock on entire list (unlike ConcurrentHashMap segments). Slower than unsynchronized (lock overhead). Use when thread-safety needed, simpler than manual sync.",
            "useCases": [
                "Thread safety",
                "Wrapper"
            ],
            "realTimeUseCases": [
                "Multi-threaded list access"
            ]
        },
        {
            "id": 419,
            "name": "Collections unmodifiableList",
            "question": "What is unmodifiableList()?",
            "answer": "unmodifiableList(List<T>): returns immutable wrapper (read-only). Throws UnsupportedOperationException on add/remove/set. Syntax: List<T> immutable = Collections.unmodifiableList(list). Protects backing list from modification. Useful: API contracts (prevent client modification), constant lists. View backed by original (changes reflected).",
            "useCases": [
                "Immutability",
                "API design"
            ],
            "realTimeUseCases": [
                "Returning constant list from method"
            ]
        },
        {
            "id": 420,
            "name": "Iterator definition",
            "question": "What is Iterator?",
            "answer": "Iterator: interface for traversing collections. Methods: hasNext() - check existence, next() - return and advance, remove() - delete current element. Obtained: collection.iterator(). Fail-fast: detects concurrent modifications (throws ConcurrentModificationException). Standard way to iterate (works for all collections).",
            "useCases": [
                "Traversal pattern",
                "Iteration"
            ],
            "realTimeUseCases": [
                "for(Iterator<String> it = list.iterator(); it.hasNext();)"
            ]
        },
        {
            "id": 421,
            "name": "ListIterator definition",
            "question": "What is ListIterator?",
            "answer": "ListIterator: extends Iterator for List. Additional methods: hasPrevious() - backward check, previous() - backward navigation, nextIndex()/previousIndex() - get position, set(E) - replace current, add(E) - insert before next. Bidirectional traversal. Fail-fast. Obtained: list.listIterator().",
            "useCases": [
                "Bidirectional iteration",
                "List-specific"
            ],
            "realTimeUseCases": [
                "for(ListIterator<Item> it = list.listIterator(); ...)"
            ]
        },
        {
            "id": 422,
            "name": "Iterator vs ListIterator difference",
            "question": "What is the difference between Iterator and ListIterator?",
            "answer": "Iterator: forward only, all collections. ListIterator: bidirectional, List only. ListIterator additional methods: previous(), set(), add(), index access. Iterator simpler (fewer methods). Choose: Iterator for general traversal, ListIterator for Lists needing backward/modification. ListIterator more powerful but List-specific.",
            "useCases": [
                "Comparison",
                "Feature sets"
            ],
            "realTimeUseCases": [
                "Iterator for Set, ListIterator for ArrayList"
            ]
        },
        {
            "id": 423,
            "name": "Iterator remove support",
            "question": "Why does Iterator support remove()?",
            "answer": "remove() support: safe element removal during iteration. Caller: iter.remove() after next(). Iterator updates internal state (index/position). Direct list.remove() during iteration causes ConcurrentModificationException (fail-fast). Iterator.remove() allowed (maintains iteration integrity). Example: filter list while iterating.",
            "useCases": [
                "Concurrent modification",
                "Safe removal"
            ],
            "realTimeUseCases": [
                "Removing inactive items during iteration"
            ]
        },
        {
            "id": 424,
            "name": "Fail-fast fail-safe behavior",
            "question": "What is fail-fast and fail-safe behavior?",
            "answer": "Fail-fast: Iterator detects concurrent list modifications (add/remove by others), throws ConcurrentModificationException. Examples: ArrayList, HashMap iterators. Fail-safe: Iterator immune to concurrent modifications (iterates copy/snapshot). Examples: CopyOnWriteArrayList. Trade-off: fail-fast detects bugs, fail-safe slower (copy overhead).",
            "useCases": [
                "Error detection",
                "Concurrency"
            ],
            "realTimeUseCases": [
                "ArrayList throws exception, CopyOnWriteArrayList safe"
            ]
        },
        {
            "id": 425,
            "name": "HashMap iterator fail-fast",
            "question": "Why HashMap iterator is fail-fast?",
            "answer": "Fail-fast: HashMap tracks modCount (modification count). Iterator checks: during next(), if modCount changed â†’ throws ConcurrentModificationException. Detects: add/remove/put by other threads/code. Prevents: undefined behavior (iteration over changing map). Cost: O(1) modCount check. Purpose: fail-fast prevents silent bugs.",
            "useCases": [
                "Modification detection",
                "Integrity"
            ],
            "realTimeUseCases": [
                "Throws exception if map modified during iteration"
            ]
        },
        {
            "id": 426,
            "name": "Fail-safe iterator examples",
            "question": "What are examples of fail-safe iterators?",
            "answer": "Examples: CopyOnWriteArrayList iterator (iterates snapshot), ConcurrentHashMap iterator (weak consistency), snapshot-based (Collections.synchronizedList with manual iteration), Unmodifiable views (no modification possible). Mechanism: iterate copy (not live view) or weakly-consistent (eventual consistency). Cost: memory (copy) or weaker semantics.",
            "useCases": [
                "Concurrency",
                "Safety"
            ],
            "realTimeUseCases": [
                "CopyOnWriteArrayList for multi-threaded listeners"
            ]
        },
        {
            "id": 427,
            "name": "HashMap vs TreeMap performance",
            "question": "Why is HashMap faster than TreeMap?",
            "answer": "Faster: O(1) average operations vs O(logn). HashMap: hash-based (direct bucket access), no comparison. TreeMap: tree-based (traversal needed, compareTo() calls). No sorting overhead in HashMap (unordered). Millions of operations: HashMap significantly faster. Trade-off: speed for order.",
            "useCases": [
                "Performance comparison",
                "Analysis"
            ],
            "realTimeUseCases": [
                "HashMap for cache, TreeMap for sorted data"
            ]
        },
        {
            "id": 428,
            "name": "ArrayList random access faster",
            "question": "Why ArrayList is faster than LinkedList for random access?",
            "answer": "Faster: O(1) indexed access (array[index]) vs O(n) linked list traversal. ArrayList: direct memory lookup (contiguous). LinkedList: must follow pointers (cache misses). Example: accessing 1000th element â†’ ArrayList instant, LinkedList 1000 hops. Random access: ArrayList significantly faster. Trade-off: insertion speed.",
            "useCases": [
                "Performance comparison",
                "Indexing"
            ],
            "realTimeUseCases": [
                "Getting product at index 500"
            ]
        },
        {
            "id": 429,
            "name": "LinkedList faster insert delete",
            "question": "Why LinkedList is faster for insert/delete?",
            "answer": "Faster: O(1) insert/delete at position vs ArrayList O(n). LinkedList: update pointers. ArrayList: shift array elements (expensive at middle). Example: remove from middle â†’ LinkedList updates 2 pointers, ArrayList shifts N-1 elements. Trade-off: random access slow. Use LinkedList for frequent insert/delete at ends.",
            "useCases": [
                "Performance comparison",
                "Insertion"
            ],
            "realTimeUseCases": [
                "Removing orders from queue"
            ]
        },
        {
            "id": 430,
            "name": "Choose right collection based on scenario",
            "question": "How to choose the right collection based on scenario?",
            "answer": "Decision tree: Duplicates allowed? â†’ YES (List), NO (Set). Ordered? â†’ YES (sorted? â†’ TreeMap/TreeSet), NO (HashMap/HashSet). Key-value pairs? â†’ Map. Add/remove at ends? â†’ Deque/LinkedList. Random access? â†’ ArrayList. Thread-safe? â†’ ConcurrentHashMap/CopyOnWriteArrayList. Summary: match requirements to collection type and implementation.",
            "useCases": [
                "Selection guide",
                "Decision tree"
            ],
            "realTimeUseCases": [
                "Product list (ArrayList), categories (HashSet), rankings (TreeMap)"
            ]
        },
        {
            "id": 431,
            "name": "HashMap complete definition",
            "question": "Question: - What is HashMap? Syntax of it? What it Implements Interface like Map? How It works Internally? What mechanism will it follows to store or delete the key value pairs data in HashMap? Will It Allow Duplicates Keys , Values , Null values , Null Keyes or not? Will It Follow Thread Safety or Not? What Problems will it solves ? What are the Advantages and Disadvantages of it? When to use it means in which scenarios or for what purpose do we have to use it? What is the Time and Space Complexity of it? What is the default load factor of it? Use Cases of it? Real Time Use Cases of it in your real time eCommerce Project?",
            "answer": "HashMap is one of the most commonly used keyâ€“value pair data structures in Java and is a part of the Java Collections Framework. We use it when we need very fast insertion, deletion, and lookup of data using keys. Since it implements the Map interface, it stores data strictly in the form of keyâ€“value pairs. The syntax for creating a HashMap is simply: Map<K, V> map = new HashMap<>();. Internally, HashMap works based on a hashing mechanism. Whenever we put a key into the HashMap, Java first calls the hashCode() method on that key, then converts the hash value into a bucket index, and finally stores the keyâ€“value pair inside that bucket. These buckets are essentially arrays where each bucket internally stores its elements either as a LinkedList (in Java 7) or as a Red-Black Tree (in Java 8 and above, if too many collisions occur). When two different keys map to the same bucket indexâ€”a situation called collisionâ€”HashMap stores these entries together inside the same bucket using the list or tree structure. During deletion, HashMap again calculates the bucket index using the key's hashCode and removes the corresponding node from the list or tree. The core mechanism HashMap follows includes hashing for calculating the bucket index, collision handling using LinkedList or Red-Black Tree, load factor evaluation (with the default being 0.75) to decide when rehashing is required, and the rehashing process itself, which triggers when the map becomes 75% full and needs to increase its internal capacity. HashMap does not allow duplicate keys; if a new value is put with an existing key, the old value is simply replaced. However, it does allow duplicate values. HashMap also allows only one null key, but it can store any number of null values. HashMap is not thread-safe. This means that if multiple threads try to modify a HashMap simultaneously, it may lead to data inconsistency, lost updates, or even infinite loops in worst-case scenarios (such as Java 7 bucket corruption). To use a thread-safe version, we typically choose either ConcurrentHashMap or Collections.synchronizedMap(). HashMap solves several common programming problems such as fast searching using keys, efficient lookups without scanning a list, structured storage of data as keyâ€“value pairs, avoiding duplicate keys, and enabling quick caching and retrieval. It offers many advantages, such as very fast operations with an average time complexity of O(1), ease of use, allowance of null keys and null values, excellent performance in non-threaded environments, and efficient memory management through rehashing. However, it also has disadvantages such as the lack of thread safety, absence of ordered storage, the cost of rehashing operations, and memory overhead due to buckets and internal structures. The time complexity of HashMap is O(1) on average for insertion, search, and deletion, but in the worst case, due to excessive collisions, these operations may degrade to O(n). Space complexity is O(n), where n is the number of keyâ€“value pairs stored. The default load factor is 0.75, meaning that when the HashMap becomes 75% full, it automatically resizes and rehashes its contents. We use HashMap in situations where we need extremely fast access to data, where ordering does not matter, where we need to store keyâ€“value pairs, and where the environment is single-threaded. It is also ideal for caching, building lookup tables, avoiding duplicate keys, or storing configurations. Some general use cases of HashMap include caching frequently-used data, storing configuration values, counting occurrences, building dictionaries, storing session information, creating lookup tables, and mapping IDs to objects. In my real-time eCommerce project, HashMap was used in multiple critical areas. We used it to map Product IDs to Product Details, which allowed very fast lookups when rendering product pages. We stored User IDs mapped to Cart Items, making cart retrieval instantaneous. We also used it to map Categories to their Product Lists for quick filtering. Coupon Codes were mapped to their discount values, enabling fast validation during checkout. Additionally, we used it for mapping Session Tokens to logged-in user information to authenticate users quickly. Overall, HashMap played an essential role because its speed helped maintain millisecond-level response time in performance-sensitive areas of the system.",
            "useCases": [
                "Fast lookup of objects using unique keys (Example: ProductID â†’ ProductDetails)",
                "Storing user-related data for quick access (Example: UserID â†’ UserCartItems)",
                "Creating lookup tables or dictionaries (Example: CategoryName â†’ ListOfProducts)",
                "Caching frequently accessed data (Example: Best-selling products, price lists, shipping charges)",
                "Configuration and settings storage (Example: PaymentConfigName â†’ PaymentConfigValue)"
            ],
            "realTimeUseCases": [
                "Product ID â†’ Product Details Cacheâ€”Used to instantly fetch product details while showing product listing and product detail pages",
                "User ID â†’ Cart Items Mappingâ€”Used to store and retrieve each user's cart contents quickly without hitting the database repeatedly",
                "Category â†’ Product List Mappingâ€”Used to load all category products in milliseconds for filtering, home page sections, and recommendations",
                "Coupon Code â†’ Discount Value Mappingâ€”Used during checkout to quickly validate coupons and apply discounts",
                "Session Token â†’ Logged-in User Informationâ€”Used to authenticate users and load user details quickly for checkout, profile update, and order placement flows"
            ]
        },
        {
            "id": 432,
            "name": "LinkedHashMap complete definition",
            "question": "What is LinkedHashMap? Complete Definition with all aspects.",
            "answer": "LinkedHashMap is a HashMap variant that preserves a predictable iteration order by maintaining an internal doubly-linked list of entries alongside the hash table. By default it preserves insertion order; when constructed with access-order it behaves like an LRU cache by moving accessed entries to the tail. Internally lookups are still O(1) via hashing, but each entry carries extra pointers for the linked list which adds memory overhead. It implements Map, Cloneable and Serializable. Characteristics: allows one null key and multiple null values, not thread-safe, average time O(1) for get/put/remove, higher memory due to link pointers. Use LinkedHashMap when iteration order matters (recently viewed lists, audit trails) or to implement simple LRU caches. Trade-offs: predictable order and simple LRU support at the cost of slightly more memory and marginally slower writes compared to HashMap.",
            "useCases": [
                "Maintain insertion or access order for iteration",
                "Implement simple LRU caches using access-order mode",
                "Preserve predictable ordering for serialization or logging",
                "Maintain deterministic testable maps in business logic"
            ],
            "realTimeUseCases": [
                "Recently viewed products â€” show items in the exact order a user viewed them for personalization",
                "LRU product details cache â€” keep hot product data in memory and evict least-recently-used items",
                "Checkout step tracker â€” keep the sequence of checkout steps for UI flow and recovery",
                "Audit trail ordering â€” preserve the exact order of user actions for compliance logs"
            ]
        },
        {
            "id": 433,
            "name": "TreeMap complete definition",
            "question": "What is TreeMap? Complete Definition with all aspects.",
            "answer": "TreeMap is a sorted Map implementation backed by a self-balancing Red-Black tree. Keys are ordered either by their natural ordering (Comparable) or by a provided Comparator, which makes TreeMap ideal for tasks that require sorted iteration or efficient range queries. Operations such as get/put/remove run in O(log n) time because they navigate the tree structure, and the map provides useful APIs like subMap, headMap, tailMap, floorKey, and ceilingKey. TreeMap disallows null keys (because comparisons would fail) but permits null values. It implements NavigableMap, SortedMap and Map interfaces. Use TreeMap when you need consistent sorted ordering, range queries, or ranking (leaderboards, price ranges, date-range reports). Trade-offs: higher latency than hash-based maps (O(log n) vs O(1)) and higher memory overhead for tree nodes.",
            "useCases": [
                "Sorted key iteration and range queries",
                "Leaderboards and rankings",
                "Time-range reports and date-based lookups",
                "Threshold/ceiling/floor lookups (nearest key operations)"
            ],
            "realTimeUseCases": [
                "Product price range queries â€” return all products in a $50â€“$100 range using subMap()",
                "Top-seller leaderboard â€” keep sellers ordered by sales or rating for quick top-N queries",
                "Discount tier lookup â€” find the appropriate discount bracket using ceilingKey()",
                "Date-based order reports â€” fetch orders between two dates without extra sorting"
            ]
        },
        {
            "id": 432,
            "name": "LinkedHashMap complete definition",
            "question": "What is LinkedHashMap? Complete Definition with all aspects.",
            "answer": "LinkedHashMap is a HashMap variant that preserves a predictable iteration order by maintaining an internal doubly-linked list of entries alongside the hash table. By default it preserves insertion order; when constructed with access-order it behaves like an LRU cache by moving accessed entries to the tail. Internally lookups are still O(1) via hashing, but each entry carries extra pointers for the linked list which adds memory overhead. It implements Map, Cloneable and Serializable. Characteristics: allows one null key and multiple null values, not thread-safe, average time O(1) for get/put/remove, higher memory due to link pointers. Use LinkedHashMap when iteration order matters (recently viewed lists, audit trails) or to implement simple LRU caches. Trade-offs: predictable order and simple LRU support at the cost of slightly more memory and marginally slower writes compared to HashMap.",
            "useCases": [
                "Maintain insertion or access order for iteration",
                "Implement simple LRU caches using access-order mode",
                "Preserve predictable ordering for serialization or logging",
                "Maintain deterministic testable maps in business logic"
            ],
            "realTimeUseCases": [
                "Recently viewed products â€” show items in the exact order a user viewed them for personalization",
                "LRU product details cache â€” keep hot product data in memory and evict least-recently-used items",
                "Checkout step tracker â€” keep the sequence of checkout steps for UI flow and recovery",
                "Audit trail ordering â€” preserve the exact order of user actions for compliance logs"
            ]
        },
        {
            "id": 434,
            "name": "ConcurrentHashMap complete definition",
            "question": "What is ConcurrentHashMap? Complete Definition with all aspects.",
            "answer": "ConcurrentHashMap is a concurrent, thread-safe implementation of Map designed for highly concurrent environments. Instead of synchronizing whole-map operations it uses fine-grained concurrency control (segment-level historically, and more advanced node-level/CAS and striped locking in modern JVMs) to allow multiple threads to read and write distinct parts of the map with minimal contention. Reads are often lock-free and updates lock only small regions, providing excellent throughput under contention. It does not permit null keys or null values to avoid ambiguity in concurrent operations. Typical uses include shared caches, session stores, and counters in multithreaded services. Trade-offs: slightly higher memory usage and some operations (size, iteration) may be weakly consistent snapshots rather than atomic views. API-wise it implements ConcurrentMap and Map, supports atomic methods like putIfAbsent, computeIfPresent, and merge, which are essential for safe concurrent patterns.",
            "useCases": [
                "Thread-safe shared caches and session stores",
                "Concurrent counters and analytics collectors",
                "High-throughput update maps used by worker threads",
                "Concurrent aggregation and stateful operations using atomic map methods"
            ],
            "realTimeUseCases": [
                "Inventory decrements during flash sales â€” many threads safely decrement stock without global locking",
                "Global session store â€” many web threads add/read sessions concurrently",
                "Per-product view counters â€” thread-safe high-frequency counters using AtomicInteger values",
                "Concurrent order processing â€” multiple workers update order status without contention"
            ]
        },
        {
            "id": 433,
            "name": "TreeMap complete definition",
            "question": "What is TreeMap? Complete Definition with all aspects.",
            "answer": "TreeMap is a sorted Map implementation backed by a self-balancing Red-Black tree. Keys are ordered either by their natural ordering (Comparable) or by a provided Comparator, which makes TreeMap ideal for tasks that require sorted iteration or efficient range queries. Operations such as get/put/remove run in O(log n) time because they navigate the tree structure, and the map provides useful APIs like subMap, headMap, tailMap, floorKey, and ceilingKey. TreeMap disallows null keys (because comparisons would fail) but permits null values. It implements NavigableMap, SortedMap and Map interfaces. Use TreeMap when you need consistent sorted ordering, range queries, or ranking (leaderboards, price ranges, date-range reports). Trade-offs: higher latency than hash-based maps (O(log n) vs O(1)) and higher memory overhead for tree nodes.",
            "useCases": [
                "Sorted key iteration and range queries",
                "Leaderboards and rankings",
                "Time-range reports and date-based lookups",
                "Threshold/ceiling/floor lookups (nearest key operations)"
            ],
            "realTimeUseCases": [
                "Product price range queries â€” return all products in a $50â€“$100 range using subMap()",
                "Top-seller leaderboard â€” keep sellers ordered by sales or rating for quick top-N queries",
                "Discount tier lookup â€” find the appropriate discount bracket using ceilingKey()",
                "Date-based order reports â€” fetch orders between two dates without extra sorting"
            ]
        },
        {
            "id": 435,
            "name": "Hashtable complete definition",
            "question": "What is Hashtable? Complete Definition with all aspects.",
            "answer": "Hashtable is a legacy synchronized Map from early Java (pre-Collections framework). It provides thread-safety by synchronizing nearly every method with a single object-level lock, which leads to heavy contention and poor scalability under concurrent access. It also disallows null keys and values. Modern code should avoid Hashtable: prefer HashMap for single-threaded scenarios and ConcurrentHashMap for concurrent scenarios. Hashtable's internals resemble HashMap (hashing + buckets) but synchronization semantics make it inefficient. If you encounter Hashtable in legacy code, migrate to ConcurrentHashMap to regain throughput and scalability.",
            "useCases": [
                "Legacy compatibility and historical understanding",
                "Migration planning from old codebases",
                "Performance comparison and anti-pattern detection"
            ],
            "realTimeUseCases": [
                "Legacy migration â€” replace Hashtable-backed session or cache with ConcurrentHashMap to reduce latency and increase throughput",
                "Code review â€” flag Hashtable usage as an immediate modernization task",
                "Performance debugging â€” identify Hashtable as a contention hotspot during load tests"
            ]
        },
        {
            "id": 447,
            "name": "ArrayList complete definition",
            "question": "What is ArrayList? Complete Definition with all aspects.",
            "answer": "ArrayList is a resizable array implementation of the List interface. It stores elements in an internal Object[] that grows when capacity is exceeded (default initial capacity 10), typically by ~1.5Ã—. It implements List, RandomAccess, Cloneable and Serializable. Access by index is O(1), append is amortized O(1), and removal or insertion in the middle is O(n) because elements must be shifted. It allows duplicates and nulls and is not thread-safe (use Collections.synchronizedList or CopyOnWriteArrayList for concurrency). Use ArrayList when you need fast random access and mostly append/iterate operations; avoid when frequent insertions/removals in the middle are common.",
            "useCases": [
                "Random-access collections",
                "Dynamic arrays for read-heavy workloads",
                "Caches and buffers where index access matters"
            ],
            "realTimeUseCases": [
                "Product detail image lists â€” direct index access when rendering gallery",
                "Order item lists in an order summary â€” maintain stable index-based access",
                "Local per-request aggregation â€” temporary arrays built during request handling"
            ]
        },
        {
            "id": 448,
            "name": "LinkedList complete definition",
            "question": "What is LinkedList? Complete Definition with all aspects.",
            "answer": "LinkedList is a doubly-linked list implementation of List and Deque. It stores elements as nodes linked via prev/next pointers. It implements List, Deque, Cloneable and Serializable. Add/remove at head or tail are O(1); random access (get by index) is O(n). It allows duplicates and nulls and is not thread-safe. Use LinkedList for queue/deque semantics, frequent insertions/removals at ends, or when you need constant-time insertions with an iterator. Avoid LinkedList when you need frequent random access.",
            "useCases": [
                "Queue/deque implementations",
                "Frequent insert/remove at ends",
                "Efficient iteration with many insertions via iterator"
            ],
            "realTimeUseCases": [
                "Processing pipelines and task queues â€” use as a deque for FIFO processing",
                "Session event timeline where events are appended/consumed frequently",
                "Streaming ingestion buffers where elements are consumed from head"
            ]
        },
        {
            "id": 449,
            "name": "HashSet complete definition",
            "question": "What is HashSet? Complete Definition with all aspects.",
            "answer": "HashSet is a Set implementation backed by a HashMap (using the set element as the map key). It implements Set, Cloneable and Serializable. It provides O(1) average-time add/contains/remove operations, disallows duplicate elements, and allows a single null element. It is not thread-safe (use Collections.synchronizedSet or concurrent wrappers for concurrency). Internally HashSet uses hashing and the Map's default load factor of 0.75 and default initial capacity 16. Use HashSet for fast membership tests and deduplication.",
            "useCases": [
                "Membership testing and deduplication",
                "Unique collections of IDs or keys",
                "Fast set operations (union/intersection)"
            ],
            "realTimeUseCases": [
                "Unique product SKU collection for batch processing",
                "Seen-product filters â€” avoid reprocessing same product in feed generation",
                "Deduplicate user emails during bulk imports"
            ]
        },
        {
            "id": 450,
            "name": "LinkedHashSet complete definition",
            "question": "What is LinkedHashSet? Complete Definition with all aspects.",
            "answer": "LinkedHashSet preserves insertion order while providing Set semantics. It is implemented as a HashSet with a linked list that records insertion order, so iteration is predictable. It allows one null, disallows duplicates, and is not thread-safe. Use LinkedHashSet when you need uniqueness plus deterministic iteration order (e.g., preserve first-seen ordering).",
            "useCases": [
                "Ordered unique collections",
                "Preserve first-seen elements while deduplicating",
                "Deterministic iteration for UI or export"
            ],
            "realTimeUseCases": [
                "Recently-seen unique products list â€” show unique recently viewed items in the order seen",
                "Ordered set of applied coupon codes â€” preserve apply order",
                "Ordered feature flag list for deterministic rollout"
            ]
        },
        {
            "id": 451,
            "name": "TreeSet complete definition",
            "question": "What is TreeSet? Complete Definition with all aspects.",
            "answer": "TreeSet is a NavigableSet implementation backed by a TreeMap (Red-Black tree). It stores elements in sorted order (natural or via Comparator), provides O(log n) add/remove/contains and supports range operations (subSet, headSet, tailSet). It disallows null elements when natural ordering is used (comparator or compareTo would fail), and is not thread-safe. Use TreeSet when you need sorted unique elements and efficient range queries.",
            "useCases": [
                "Sorted unique collections",
                "Range queries on a set",
                "Leaderboards and ordered index sets"
            ],
            "realTimeUseCases": [
                "Price thresholds â€” maintain sorted set of price buckets",
                "Top-N unique product IDs by score â€” use sorted set semantics",
                "Date-ordered unique event timestamps for range queries"
            ]
        },
        {
            "id": 452,
            "name": "ConcurrentHashSet (thread-safe set) definition",
            "question": "What is Concurrent HashSet? Complete Definition with all aspects.",
            "answer": "Java has no direct ConcurrentHashSet class; thread-safe sets are typically created via ConcurrentHashMap.newKeySet() or Collections.newSetFromMap(new ConcurrentHashMap<>()). Such sets provide concurrent add/contains/remove semantics backed by ConcurrentHashMap's concurrency behavior. They do not allow nulls (because ConcurrentHashMap denies null keys). Use these when many threads must safely update a shared set with high throughput. Alternatively ConcurrentSkipListSet provides a concurrent sorted set.",
            "useCases": [
                "Thread-safe membership sets",
                "High-concurrency deduplication",
                "Concurrent caches of keys or IDs"
            ],
            "realTimeUseCases": [
                "Shared in-memory set of active order IDs â€” multiple workers mark orders processed without locking global state",
                "Concurrent seen-product set used by crawler/harvester threads",
                "Global concurrent feature flags set updated by multiple threads"
            ]
        },
        {
            "id": 436,
            "name": "HashMap vs LinkedHashMap detailed comparison",
            "question": "What are the main differences between HashMap and LinkedHashMap?",
            "answer": "HashMap and LinkedHashMap provide identical core functionality as hash-based maps, but LinkedHashMap preserves a predictable iteration order by maintaining an internal doubly-linked list of entries. Use HashMap when raw performance and minimal memory are the priority; use LinkedHashMap when you need deterministic iteration (insertion or access order) or to implement simple LRU caches. The API and complexity (average O(1) for operations) are the same; the trade-offs are slight memory overhead and insertion/list maintenance in LinkedHashMap. Both are not thread-safe by default.",
            "useCases": [
                "Choose HashMap for raw speed and minimal memory",
                "Choose LinkedHashMap for ordered iteration or simple LRU cache implementations",
                "Prefer HashMap for general-purpose maps where order doesn't matter"
            ],
            "realTimeUseCases": [
                "Product catalog lookup â€” HashMap for fastest lookups",
                "Recently viewed products â€” LinkedHashMap to render items in viewing order",
                "LRU cache for product details â€” LinkedHashMap(access-order) to evict least recently used entries"
            ]
        },
        {
            "id": 440,
            "name": "All Map implementations comparison table",
            "question": "Comparison table of all Map implementations (HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap, Hashtable)?",
            "answer": "This comparison summarizes common Map implementations: HashMap is an unsynchronized hash table optimized for fast average-case O(1) access; LinkedHashMap adds a doubly-linked list to preserve insertion or access order (useful for LRU caches); TreeMap stores entries in a Red-Black tree to provide sorted ordering and O(log n) operations plus range queries; ConcurrentHashMap provides a scalable thread-safe map with fine-grained locking and lock-free reads (no nulls allowed); Hashtable is a legacy synchronized map (avoid in new code). Choose based on ordering, concurrency needs, and performance trade-offs: HashMap for speed, LinkedHashMap for ordered iteration or LRU, TreeMap for sorted/range queries, ConcurrentHashMap for concurrent shared state, and never choose Hashtable for new development.",
            "useCases": [
                "Reference for choosing the right Map implementation",
                "Quick trade-off summary for interviews",
                "Design decision guidance based on ordering and concurrency"
            ],
            "realTimeUseCases": [
                "Pick HashMap for internal per-request caches",
                "Pick LinkedHashMap for recently viewed lists or LRU caches",
                "Pick TreeMap for leaderboards and price-range queries",
                "Pick ConcurrentHashMap for shared session or inventory stores under concurrency"
            ]
        },
        {
            "id": 441,
            "name": "When use HashMap eCommerce",
            "question": "In which scenarios did you use HashMap in real-time eCommerce project?",
            "answer": "In our eCommerce platform we used HashMap wherever we needed the fastest possible key-based lookups in a single-threaded or request-scoped context. Typical examples: product catalog caches keyed by productId, per-request session or context maps, price and configuration caches, coupon-code lookup tables, and simple in-memory counters. HashMap is the right choice when ordering is irrelevant and you want O(1) average-time performance with minimal memory overhead. Avoid it for shared mutable state across threads unless externally synchronized or confined to a single thread.",
            "useCases": [
                "Product catalog caching",
                "Per-request/session-scoped data",
                "Price and configuration caches",
                "Lightweight lookup tables (coupon codes, feature flags)"
            ],
            "realTimeUseCases": [
                "ProductId â†’ ProductDetails cache â€” fast in-memory lookup for rendering product pages",
                "Session-scoped cart context â€” transient Map used during a single user request",
                "CouponCode â†’ Discount lookup â€” validate coupons quickly during checkout",
                "PriceCache â€” reduce DB hits by caching recent price values"
            ]
        },
        {
            "id": 442,
            "name": "When use LinkedHashMap eCommerce",
            "question": "In which scenarios did you use LinkedHashMap in real-time eCommerce project?",
            "answer": "We use LinkedHashMap when the insertion or access order matters. It is ideal for recently viewed lists, audit logs that must retain chronological order, and simple LRU caches (use access-order). LinkedHashMap gives O(1) average lookups with an additional linked-list overhead to preserve order, making it a pragmatic choice when deterministic iteration matters but full sorting is not required.",
            "useCases": [
                "Recently viewed lists",
                "Ordered processing queues",
                "Simple LRU caches using access-order mode",
                "Ordered audit logs and timelines"
            ],
            "realTimeUseCases": [
                "RecentlyViewedProducts â€” maintain viewing order for each user to build personalization UI",
                "LRU product cache â€” evict least recently used product detail entries",
                "Checkout step sequence â€” preserve the expected step order during multi-step checkouts",
                "Audit trail â€” store user actions in exact chronological order for compliance and debugging"
            ]
        },
        {
            "id": 443,
            "name": "When use TreeMap eCommerce",
            "question": "In which scenarios did you use TreeMap in real-time eCommerce project?",
            "answer": "TreeMap is used when sorted keys or efficient range queries are required. In eCommerce that typically means price-based lookups, leaderboards by sales or rating, and time-series or date-based reports. TreeMap guarantees sorted traversal and provides subMap/headMap/tailMap helpers so you can efficiently query ranges without additional sorting. Accept the O(log n) cost when sorted order or nearest-key operations are business-critical.",
            "useCases": [
                "Price and range queries",
                "Leaderboards and rankings",
                "Date-ordered reports",
                "Threshold/ceiling/floor lookups"
            ],
            "realTimeUseCases": [
                "Price range filter â€” return products priced between X and Y using subMap()",
                "Top-seller leaderboard â€” maintain sellers ordered by sales for quick top-N queries",
                "Discount tiers â€” find the right discount bracket using ceilingKey()",
                "Date-range reports â€” fetch transactions between two dates efficiently"
            ]
        },
        {
            "id": 444,
            "name": "When use ConcurrentHashMap eCommerce",
            "question": "In which scenarios did you use ConcurrentHashMap in real-time eCommerce project?",
            "answer": "ConcurrentHashMap is the default choice for maps that must be safely shared and mutated by many threads. We used it for global session stores, product inventory maps with concurrent decrements, high-frequency analytics counters, and shared caches populated by background workers. It scales well under contention because it avoids full-map locking and supports atomic operations like putIfAbsent and merge to build correct concurrent algorithms.",
            "useCases": [
                "Shared session and cache stores",
                "Concurrent counters and analytics aggregations",
                "State maps used by multiple worker threads",
                "High-throughput updateable maps"
            ],
            "realTimeUseCases": [
                "Inventory map during flash sales â€” multiple order handlers decrement stock concurrently",
                "Global session store â€” many web threads read/write session info",
                "Per-product view counters â€” update counters concurrently with minimal contention",
                "Background cache warms â€” multiple threads populate and refresh cached entries safely"
            ]
        },
        {
            "id": 445,
            "name": "When NEVER use Hashtable",
            "question": "In which scenarios you should NEVER use Hashtable in eCommerce?",
            "answer": "Hashtable is obsolete for modern code and should never be used in new eCommerce systems. Its coarse-grained synchronization serializes all access and creates severe contention under load. Replace Hashtable with ConcurrentHashMap for concurrent needs, or HashMap for single-threaded scenarios. In short: encountering Hashtable in code is a red flag â€” schedule an immediate migration.",
            "useCases": [
                "Anti-pattern detection",
                "Legacy migration planning",
                "Code modernization guidance"
            ],
            "realTimeUseCases": [
                "Replace Hashtable-backed caches/sessions with ConcurrentHashMap during refactors",
                "Treat Hashtable occurrences as urgent PR comments in code reviews",
                "Document migration steps when onboarding legacy services"
            ]
        },
        {
            "id": 446,
            "name": "Which Map choose decision logic",
            "question": "Decision logic: which Map to choose in eCommerce scenario?",
            "answer": "Choose a Map by asking a few questions: Do you need concurrency? If yes, use ConcurrentHashMap. If not, do you need ordering? If insertion or recent-access order matters, use LinkedHashMap (access-order for LRU). If sorted keys and range queries are required, use TreeMap. If neither order nor concurrency is required, HashMap is the fastest option. Never use Hashtable. Also consider null-key support (HashMap/LinkedHashMap allow it; TreeMap and ConcurrentHashMap do not) and memory trade-offs.",
            "useCases": [
                "Decision tree for selecting Map implementations",
                "Interview-friendly selection guide",
                "Engineers' checklist for map trade-offs"
            ],
            "realTimeUseCases": [
                "Product catalog (shared across threads) â†’ ConcurrentHashMap",
                "Recently viewed list (per-user order) â†’ LinkedHashMap",
                "Price-range queries and leaderboards â†’ TreeMap",
                "Fast request-scoped cache â†’ HashMap"
            ]
        },
        {
            "id": 447,
            "name": "ArrayList complete definition",
            "question": "What is ArrayList? Complete Definition with all aspects.",
            "answer": "ArrayList is a resizable array implementation of the List interface. It stores elements in an internal Object[] that grows when capacity is exceeded (default initial capacity 10), typically by ~1.5Ã—. It implements List, RandomAccess, Cloneable and Serializable. Access by index is O(1), append is amortized O(1), and removal or insertion in the middle is O(n) because elements must be shifted. It allows duplicates and nulls and is not thread-safe (use Collections.synchronizedList or CopyOnWriteArrayList for concurrency). Use ArrayList when you need fast random access and mostly append/iterate operations; avoid when frequent insertions/removals in the middle are common.",
            "useCases": [
                "Random-access collections",
                "Dynamic arrays for read-heavy workloads",
                "Caches and buffers where index access matters"
            ],
            "realTimeUseCases": [
                "Product detail image lists â€” direct index access when rendering gallery",
                "Order item lists in an order summary â€” maintain stable index-based access",
                "Local per-request aggregation â€” temporary arrays built during request handling"
            ]
        },
        {
            "id": 448,
            "name": "LinkedList complete definition",
            "question": "What is LinkedList? Complete Definition with all aspects.",
            "answer": "LinkedList is a doubly-linked list implementation of List and Deque. It stores elements as nodes linked via prev/next pointers. It implements List, Deque, Cloneable and Serializable. Add/remove at head or tail are O(1); random access (get by index) is O(n). It allows duplicates and nulls and is not thread-safe. Use LinkedList for queue/deque semantics, frequent insertions/removals at ends, or when you need constant-time insertions with an iterator. Avoid LinkedList when you need frequent random access.",
            "useCases": [
                "Queue/deque implementations",
                "Frequent insert/remove at ends",
                "Efficient iteration with many insertions via iterator"
            ],
            "realTimeUseCases": [
                "Processing pipelines and task queues â€” use as a deque for FIFO processing",
                "Session event timeline where events are appended/consumed frequently",
                "Streaming ingestion buffers where elements are consumed from head"
            ]
        },
        {
            "id": 449,
            "name": "HashSet complete definition",
            "question": "What is HashSet? Complete Definition with all aspects.",
            "answer": "HashSet is a Set implementation backed by a HashMap (using the set element as the map key). It implements Set, Cloneable and Serializable. It provides O(1) average-time add/contains/remove operations, disallows duplicate elements, and allows a single null element. It is not thread-safe (use Collections.synchronizedSet or concurrent wrappers for concurrency). Internally HashSet uses hashing and the Map's default load factor of 0.75 and default initial capacity 16. Use HashSet for fast membership tests and deduplication.",
            "useCases": [
                "Membership testing and deduplication",
                "Unique collections of IDs or keys",
                "Fast set operations (union/intersection)"
            ],
            "realTimeUseCases": [
                "Unique product SKU collection for batch processing",
                "Seen-product filters â€” avoid reprocessing same product in feed generation",
                "Deduplicate user emails during bulk imports"
            ]
        },
        {
            "id": 450,
            "name": "LinkedHashSet complete definition",
            "question": "What is LinkedHashSet? Complete Definition with all aspects.",
            "answer": "LinkedHashSet preserves insertion order while providing Set semantics. It is implemented as a HashSet with a linked list that records insertion order, so iteration is predictable. It allows one null, disallows duplicates, and is not thread-safe. Use LinkedHashSet when you need uniqueness plus deterministic iteration order (e.g., preserve first-seen ordering).",
            "useCases": [
                "Ordered unique collections",
                "Preserve first-seen elements while deduplicating",
                "Deterministic iteration for UI or export"
            ],
            "realTimeUseCases": [
                "Recently-seen unique products list â€” show unique recently viewed items in the order seen",
                "Ordered set of applied coupon codes â€” preserve apply order",
                "Ordered feature flag list for deterministic rollout"
            ]
        },
        {
            "id": 451,
            "name": "TreeSet complete definition",
            "question": "What is TreeSet? Complete Definition with all aspects.",
            "answer": "TreeSet is a NavigableSet implementation backed by a TreeMap (Red-Black tree). It stores elements in sorted order (natural or via Comparator), provides O(log n) add/remove/contains and supports range operations (subSet, headSet, tailSet). It disallows null elements when natural ordering is used (comparator or compareTo would fail), and is not thread-safe. Use TreeSet when you need sorted unique elements and efficient range queries.",
            "useCases": [
                "Sorted unique collections",
                "Range queries on a set",
                "Leaderboards and ordered index sets"
            ],
            "realTimeUseCases": [
                "Price thresholds â€” maintain sorted set of price buckets",
                "Top-N unique product IDs by score â€” use sorted set semantics",
                "Date-ordered unique event timestamps for range queries"
            ]
        },
        {
            "id": 452,
            "name": "ConcurrentHashSet (thread-safe set) definition",
            "question": "What is Concurrent HashSet? Complete Definition with all aspects.",
            "answer": "Java has no direct ConcurrentHashSet class; thread-safe sets are typically created via ConcurrentHashMap.newKeySet() or Collections.newSetFromMap(new ConcurrentHashMap<>()). Such sets provide concurrent add/contains/remove semantics backed by ConcurrentHashMap's concurrency behavior. They do not allow nulls (because ConcurrentHashMap denies null keys). Use these when many threads must safely update a shared set with high throughput. Alternatively ConcurrentSkipListSet provides a concurrent sorted set.",
            "useCases": [
                "Thread-safe membership sets",
                "High-concurrency deduplication",
                "Concurrent caches of keys or IDs"
            ],
            "realTimeUseCases": [
                "Shared in-memory set of active order IDs â€” multiple workers mark orders processed without locking global state",
                "Concurrent seen-product set used by crawler/harvester threads",
                "Global concurrent feature flags set updated by multiple threads"
            ]
        },
        {
            "id": 453,
            "name": "Collections vs Collection",
            "question": "Collections vs Collection â€” what is the difference?",
            "answer": "`Collection` is the root interface in the Java Collections Framework that represents a group of objects (List, Set, Queue). `Collections` is a utility class that provides static helper methods (sorting, searching, synchronized wrappers, etc.). In interviews: say 'Collection' describes types you implement/choose; 'Collections' provides library helpers to work with those types. Understand both: one is an API contract, the other a utility toolbox.",
            "useCases": [
                "Choose the right Collection subtype",
                "Use Collections utility methods for common algorithms",
                "Wrap collections with synchronized/immutable views"
            ],
            "realTimeUseCases": [
                "Collections.sort(productList) during reporting",
                "Collections.synchronizedList(...) when adapting legacy single-threaded lists",
                "Collections.unmodifiableMap(...) to expose read-only configuration"
            ]
        },
        {
            "id": 454,
            "name": "Iterable vs Iterator vs ListIterator vs Enumeration",
            "question": "Explain Iterable vs Iterator vs ListIterator vs Enumeration",
            "answer": "`Iterable` is a simple interface enabling 'for-each' loops by exposing an `iterator()`. `Iterator` enables forward traversal with remove() support. `ListIterator` (for Lists) adds bi-directional traversal, index access, and set/add operations during iteration. `Enumeration` is an older legacy interface (Vector-era) similar to Iterator but without remove(). For interviews: prefer Iterator/ListIterator for modern code; Enumeration only appears in legacy APIs.",
            "useCases": [
                "Use Iterable to make a type for-each compatible",
                "Use Iterator when removing elements safely during traversal",
                "Use ListIterator for list-specific bidirectional edits",
                "Avoid Enumeration except when interfacing with legacy APIs"
            ],
            "realTimeUseCases": [
                "Use Iterator to remove expired sessions from a collection while iterating",
                "Use ListIterator to walk and modify a user's ordered activity list",
                "Implement Iterable on domain collections to simplify controllers and templates"
            ]
        },
        {
            "id": 455,
            "name": "Map vs Set vs List",
            "question": "Map vs Set vs List â€” when to use each?",
            "answer": "`List` is an ordered collection allowing duplicates and indexed access (ArrayList/LinkedList). `Set` enforces uniqueness (HashSet/TreeSet) and is great for membership checks. `Map` stores keyâ†’value pairs and is ideal for lookups by key (HashMap/TreeMap). Interview tip: translate requirements into these primitives â€” ordered sequence, unique membership, or key-based lookup â€” and pick the right API accordingly.",
            "useCases": [
                "List for ordered sequences and positional access",
                "Set for deduplication and fast membership tests",
                "Map for associative lookups and caches"
            ],
            "realTimeUseCases": [
                "Cart items â€” List when order matters",
                "Unique SKUs â€” Set for deduplication in batch imports",
                "ProductIdâ†’ProductDetails â€” Map for fast page rendering"
            ]
        },
        {
            "id": 456,
            "name": "Map implementations differences (summary)",
            "question": "Differences: HashMap vs LinkedHashMap vs TreeMap vs ConcurrentHashMap vs Hashtable",
            "answer": "Short summary: HashMap â€” unsynchronized hash table, allows nulls, best for raw speed. LinkedHashMap â€” HashMap + predictable iteration (insertion or access-order), useful for LRU. TreeMap â€” sorted map (Red-Black tree), O(log n) ops, useful for range queries. ConcurrentHashMap â€” scalable concurrent map, no nulls, fine-grained locking/CAS. Hashtable â€” legacy synchronized map, avoid in new code. Use based on ordering, concurrency, and range query needs.",
            "useCases": [
                "Pick HashMap for fast single-threaded caches",
                "Pick LinkedHashMap for ordered iteration and simple LRU caches",
                "Pick TreeMap for sorted or range-based data",
                "Pick ConcurrentHashMap for shared multi-threaded stores"
            ],
            "realTimeUseCases": [
                "HashMap for per-request caches",
                "LinkedHashMap for recently viewed lists",
                "TreeMap for price-range queries",
                "ConcurrentHashMap for inventory/session stores"
            ]
        },
        {
            "id": 457,
            "name": "ArrayList vs LinkedList",
            "question": "Differences between ArrayList and LinkedList",
            "answer": "ArrayList: backed by array, random access O(1), amortized add O(1), remove/insert in middle O(n). LinkedList: doubly-linked nodes, add/remove at ends O(1), random access O(n). Choose ArrayList for read-heavy and random-access needs; choose LinkedList for frequent insertions/removals at ends or when using ListIterator to splice efficiently.",
            "useCases": [
                "ArrayList for fast random access and iteration",
                "LinkedList for deque/queue-like operations or many mid-list insertions via iterator"
            ],
            "realTimeUseCases": [
                "Product lists for UI rendering â€” ArrayList",
                "Processing queues and event timelines â€” LinkedList"
            ]
        },
        {
            "id": 458,
            "name": "Vector vs Stack differences",
            "question": "What are the differences between Vector and Stack?",
            "answer": "`Vector` is a synchronized List (legacy), `Stack` extends Vector and provides LIFO push/pop. Both are legacy; prefer `ArrayList` and `Deque` (e.g., ArrayDeque) or `ConcurrentLinkedDeque` for thread-safe stacks. Vector synchronizes every method, causing contention; Stack inherits that problem and exposes outdated API.",
            "useCases": [
                "Avoid Vector/Stack for new code",
                "Use ArrayList + ArrayDeque or Deque implementations instead",
                "Use concurrent deques for thread-safe LIFO/FIFO"
            ],
            "realTimeUseCases": [
                "Replace legacy Stack usage with ArrayDeque for request-scoped algorithm stacks",
                "Avoid Vector in high-throughput services; use ArrayList or concurrent collections"
            ]
        },
        {
            "id": 459,
            "name": "Set implementations differences",
            "question": "HashSet vs LinkedHashSet vs TreeSet vs ConcurrentHashSet â€” when to use which?",
            "answer": "HashSet â€” fast, unsorted membership tests; LinkedHashSet â€” preserves insertion order; TreeSet â€” sorted set with O(log n) ops; ConcurrentHashSet (via ConcurrentHashMap.newKeySet()) â€” thread-safe high-throughput set (no nulls). Choose based on ordering and concurrency: HashSet for speed, LinkedHashSet for predictable iteration, TreeSet for sorted/range operations, concurrent variant for shared mutable sets.",
            "useCases": [
                "HashSet for deduplication and membership",
                "LinkedHashSet when order of first-seen matters",
                "TreeSet for sorted thresholds and range queries",
                "ConcurrentHashSet for shared worker sets"
            ],
            "realTimeUseCases": [
                "Deduplicate SKU imports â€” HashSet",
                "Unique recently viewed products preserving order â€” LinkedHashSet",
                "Price bucket thresholds â€” TreeSet",
                "Active job IDs accessed by multiple workers â€” ConcurrentHashSet"
            ]
        },
        {
            "id": 460,
            "name": "hashCode() vs equals() vs ==",
            "question": "Explain hashCode(), equals() and == in Java and when to use them",
            "answer": "`==` compares object references (identity). `equals()` compares logical equality and can be overridden. `hashCode()` returns an int used by hash-based collections; equal objects must produce equal hashCodes. Implement both equals() and hashCode() together when providing a value-based equality (e.g., entity identity, DTOs). Use == for identity checks, equals() for logical equality, and ensure hashCode() is consistent with equals for correct behavior in HashMap/HashSet.",
            "useCases": [
                "Override equals/hashCode for domain keys",
                "Use == for reference checks (singleton, identity)",
                "Use equals() to compare field-based equality"
            ],
            "realTimeUseCases": [
                "ProductKey value object used as HashMap key â€” implement equals/hashCode",
                "Avoid using == for string comparison in business logic â€” use equals()",
                "Implement identity vs value-comparison clearly in entity classes"
            ]
        },
        {
            "id": 461,
            "name": "Comparator vs Comparable",
            "question": "Comparator vs Comparable â€” what are the differences and when to use which?",
            "answer": "`Comparable` (implements compareTo) defines the natural order inside the class; `Comparator` is a separate strategy object allowing multiple orderings. Use Comparable for a single default ordering; use Comparator for custom or multiple orderings (e.g., sort by price, then rating). In modern Java, prefer `Comparator.comparing(...)` and method references for concise comparators.",
            "useCases": [
                "Implement Comparable for natural ordering",
                "Use Comparator for ad-hoc or multiple sort criteria",
                "Use Comparator.thenComparing for multi-key sorts"
            ],
            "realTimeUseCases": [
                "Sort products by default name â€” implement Comparable on ProductId if natural order desired",
                "Provide Comparator for sorting by price or rating in UI list endpoints"
            ]
        },
        {
            "id": 462,
            "name": "Serialization and Deserialization",
            "question": "What is Serialization and Deserialization in Java? Explain with use cases",
            "answer": "Serialization converts an object graph to a byte-stream for persistence or transport; deserialization reconstitutes it. Java provides `Serializable` (default) and custom methods (writeObject/readObject) to control the process. Use cases: cache persistence, distributed messaging, HTTP session replication. Avoid serializing large internal caches; instead persist compact DTOs. In the enterprise, prefer explicit DTOs and version-tolerant serializers (JSON, Avro, Protobuf) for long-term compatibility.",
            "useCases": [
                "Persisting session/state",
                "Transporting DTOs over the wire",
                "Caching snapshots"
            ],
            "realTimeUseCases": [
                "Session replication in clustered servers â€” serialize minimal session DTOs",
                "Persisting cart snapshot for recovery â€” store serialized order context",
                "Use JSON/Avro for cross-service messaging rather than Java native serialization"
            ]
        },
        {
            "id": 463,
            "name": "transient vs volatile",
            "question": "Why transient and volatile keywords are used in Java? When to use them?",
            "answer": "`transient` marks fields to be skipped during Java serialization (sensitive or non-serializable state). `volatile` ensures visibility of writes across threads for a single variable (no locking, but no atomic compound operations). Use `transient` for passwords, database handles, or cached data that should not be serialized. Use `volatile` for simple flags (stop signals) where atomicity of compound operations is not required. For compound updates, use Atomic types or synchronization.",
            "useCases": [
                "Transient for non-serializable or sensitive fields",
                "Volatile for simple cross-thread visibility flags",
                "Combine volatile with AtomicReference for lock-free patterns"
            ],
            "realTimeUseCases": [
                "Mark cache helper objects transient in serialized session DTOs",
                "Use volatile boolean shutdownFlag to signal background workers",
                "Use AtomicInteger for counters instead of volatile int when incrementing"
            ]
        },
        {
            "id": 464,
            "name": "Serialization vs Externalization",
            "question": "Difference between Serialization & Externalization in Java â€” when to use each?",
            "answer": "`Serializable` is automatic: JVM serializes reachable non-transient fields. `Externalizable` gives full control via writeExternal/readExternal (you must implement serialization). Use Externalizable when you need compact, version-stable, or customized binary representation. For most apps, prefer Serializable or, better, explicit conversion to portable formats (JSON, Protobuf) for cross-platform stability.",
            "useCases": [
                "Externalizable for bespoke compact formats",
                "Serializable for quick Java-only persistence",
                "Prefer explicit DTO serialization (JSON/Avro) for interoperability"
            ],
            "realTimeUseCases": [
                "Use Externalizable for compact cache persistence when storage is constrained",
                "Prefer JSON/Avro for microservice messages rather than Java native serialization"
            ]
        },
        {
            "id": 465,
            "name": "Internationalization vs Externalization vs Normalization",
            "question": "Difference between Internationalization, Externalization, and Normalization?",
            "answer": "`Internationalization (i18n)` is designing your app to support multiple locales (use ResourceBundle, locale-aware formatting). `Externalization` (of strings) means keeping user-facing text outside code (properties files) so translations can be applied. `Normalization` usually refers to Unicode normalization (NFC/NFD) to ensure string equality across composed/decomposed forms. In interviews: emphasize separating UI text, using locale-specific formatting, and normalizing strings for consistent comparisons.",
            "useCases": [
                "I18n: locale-aware formatting and resource bundles",
                "Externalization: property/source separation for translators",
                "Normalization: unify Unicode forms before comparison"
            ],
            "realTimeUseCases": [
                "Externalize UI labels for translators during international rollout",
                "Format currency/dates with locale in checkout",
                "Normalize user-submitted search terms to improve matching"
            ]
        },
        {
            "id": 466,
            "name": "Runnable vs Callable",
            "question": "Runnable vs Callable â€” why use them and when?",
            "answer": "`Runnable` represents a task that returns no result and cannot throw checked exceptions; `Callable<V>` returns a result and can throw exceptions. Use Callable when you need a return value or exception handling from async tasks; use Runnable for fire-and-forget tasks. Executors accept both; use Future to obtain results from Callable.",
            "useCases": [
                "Runnable for simple background jobs",
                "Callable for tasks that produce results or may fail",
                "Use ExecutorService to manage thread pools for both"
            ],
            "realTimeUseCases": [
                "Runnable to pre-warm cache entries asynchronously",
                "Callable to fetch product recommendations concurrently and combine results"
            ]
        },
        {
            "id": 467,
            "name": "Predicate Consumer Function Supplier",
            "question": "Predicate and Consumer vs Function vs Supplier â€” explain and when to use them",
            "answer": "These are core functional interfaces: `Predicate<T>` tests a boolean condition, `Consumer<T>` consumes a value without returning, `Function<T,R>` transforms Tâ†’R, and `Supplier<T>` provides values with no input. Use them to write concise, composable lambda-based code. They vastly simplify stream pipelines and callback-style code.",
            "useCases": [
                "Predicate for filtering streams",
                "Function for mapping/transformation",
                "Consumer for side-effect actions",
                "Supplier for lazy value provision"
            ],
            "realTimeUseCases": [
                "Use Predicate in stream filters for product attributes",
                "Use Function to map ProductEntity â†’ ProductDTO",
                "Use Supplier to lazily create default objects for fallback"
            ]
        },
        {
            "id": 468,
            "name": "Function vs Supplier (focus)",
            "question": "Function vs Supplier â€” differences and examples",
            "answer": "`Function<T,R>` accepts an input and returns a result; `Supplier<T>` takes no input and returns a result. Use Supplier for factories, defaults, or lazy evaluation; use Function for transformations. In streams use map(Function) and use Supplier for constructs like Stream.generate(Supplier).",
            "useCases": [
                "Function for DTO mapping and data transforms",
                "Supplier for lazy initializers and factories"
            ],
            "realTimeUseCases": [
                "Map DB rows to DTOs using Function references",
                "Provide fallback cached value via Supplier when cache miss occurs"
            ]
        },
        {
            "id": 469,
            "name": "Basics of Exceptions",
            "question": "What is an Exception in Java? Why do exceptions occur? What problems do exceptions solve? What is the difference between Error and Exception? What is the syntax of exception handling in Java? When should we use exception handling? What is the difference between compile-time exception and run-time exception? What is the difference between checked and unchecked exceptions? Why are some exceptions checked and some unchecked?",
            "answer": "An Exception in Java is an event that disrupts normal program flow when an unexpected condition occurs. Exceptions occur due to programming errors (NullPointerException), invalid user input (NumberFormatException), resource unavailability (IOException), or external system failures. They solve error handling by separating normal logic from error-handling logic, enabling centralized recovery without littering code with if-checks. Error differs from Exception: Errors are serious JVM problems (OutOfMemoryError, StackOverflowError) not intended to be caught, while Exceptions are application-level problems that can be handled. Exception handling syntax: try { risky code } catch (SpecificException e) { handle } finally { cleanup }. Use exception handling for recoverable conditions where you can take meaningful action. Compile-time (checked) exceptions must be declared or handled (IOException, SQLException); runtime (unchecked) exceptions inherit from RuntimeException and don't require declaration. Checked exceptions are used for recoverable conditions that callers should prepare for; unchecked exceptions signal programming errors or truly exceptional conditions.",
            "useCases": [
                "Signal and handle recoverable errors",
                "Distinguish programming mistakes from recoverable failures",
                "Clean resource management with finally blocks",
                "Enforce API contracts via checked exceptions"
            ],
            "realTimeUseCases": [
                "Detect invalid productId input and throw NumberFormatException; catch and return validation error to user",
                "Wrap database connection failures (SQLException) in a custom DataAccessException",
                "Use finally block to close file handles or DB connections regardless of success/failure",
                "Throw IllegalArgumentException for invalid quantity in addToCart() before processing payment"
            ]
        },
        {
            "id": 470,
            "name": "Exception Hierarchy",
            "question": "What is the root of all exceptions in Java? What is Throwable? What is Exception class? What is RuntimeException? What is Error class? What is the difference between Throwable and Exception? What is the exception hierarchy structure in Java?",
            "answer": "The root of all exceptions is java.lang.Throwable, which has two main branches: Error and Exception. Throwable is the parent class of all error and exception types; it provides methods like getMessage(), printStackTrace(), and getCause(). Exception class is for application-level problems that can be caught and handled. RuntimeException is a subclass of Exception for unchecked errors (NullPointerException, IndexOutOfBoundsException) that don't require explicit handling. Error class represents serious JVM/system problems (OutOfMemoryError, StackOverflowError, ThreadDeath) that should not be caught. Throwable vs Exception: Throwable includes both checked exceptions and errors; Exception is for recoverable issues. The hierarchy: Throwable â†’ {Error (fatal), Exception â†’ {Checked exceptions (IOException, SQLException), RuntimeException (unchecked)}}.",
            "useCases": [
                "Choose between checked and unchecked exceptions based on recoverability",
                "Design custom exception hierarchies for domain-specific errors",
                "Use Throwable as a catch-all only in rare circumstances"
            ],
            "realTimeUseCases": [
                "Catch Exception at service boundaries to translate to PaymentException or InventoryException",
                "Don't catch Error; instead monitor JVM metrics to prevent OutOfMemoryError during flash sales",
                "Create custom PaymentGatewayException extends Exception for payment-specific failures that callers must handle"
            ]
        },
        {
            "id": 471,
            "name": "try, catch, finally",
            "question": "What is try block? What is catch block? How many catch blocks can we have? What happens if none of the catch blocks match? What is finally block? When does finally block execute? Can finally block be skipped? What happens if return statements are present in try or catch?",
            "answer": "try block encloses code that may throw exceptions. catch block handles specific exception types; you can have multiple catch blocks ordered from most specific to most general. If none match, the exception propagates up the stack. finally block executes regardless of whether an exception occurred or was caught; used for cleanup (closing resources, logging). finally executes even if try/catch contains return, break, or continue statementsâ€”finally always runs before the method returns. finally block can be skipped only if System.exit() is called, JVM terminates abnormally, or a thread is forcefully killed. If return exists in try, finally still executes before returning; if return is in catch, finally executes before that return; if return is in finally, it overrides earlier returns (considered bad practice).",
            "useCases": [
                "Ensure resource cleanup with finally blocks",
                "Handle specific exception types with ordered catch blocks",
                "Use try-with-resources instead of finally for cleaner resource management"
            ],
            "realTimeUseCases": [
                "try { order = placeOrder(); } catch (InventoryException e) { refund payment; } finally { closeConnection(); }",
                "Use specific catches: catch (PaymentException) then catch (IOException) then catch (Exception)",
                "try-with-resources for DB: try (Connection conn = getConnection()) { ...} auto-closes connection"
            ]
        },
        {
            "id": 472,
            "name": "throw and throws",
            "question": "What is throw keyword? What is throws keyword? What is the purpose of using throw? What is the purpose of using throws? What is the difference between throw and throws? When should we use throw and when should we use throws? Can we throw multiple exceptions? Can a constructor use throws keyword?",
            "answer": "throw keyword explicitly raises an exception at runtime: throw new IllegalArgumentException(\"Invalid quantity\"). throws keyword is used in method signatures to declare that a method may propagate checked exceptions to callers: public void readFile() throws IOException { }. throw is used to signal a problem immediately when detected; throws documents that callers must handle or propagate the exception. Key differences: throw raises an instance, throws declares checked exceptions in signature. throw is used once per exception instance; throws lists multiple exceptions separated by commas: throws IOException, SQLException, DataAccessException. You can throw multiple exception types in the same method via multiple throw statements or throwing different exceptions in different catch blocks. Constructors can use throws keyword to force callers to handle initialization failures: public PaymentClient() throws ConfigurationException { }.",
            "useCases": [
                "Use throw to validate inputs and fail fast",
                "Use throws to document API contract for checked exceptions",
                "Throw custom domain exceptions for business logic violations",
                "Declare multiple exception types in throws for thorough API documentation"
            ],
            "realTimeUseCases": [
                "throw new InvalidCouponException(coupon) if coupon format is invalid in applyCoupon()",
                "public Order placeOrder() throws PaymentException, InventoryException { }",
                "Constructor throws ConfigurationException if payment gateway credentials are missing",
                "throw new DomainException(\"Insufficient inventory\") when can't fulfill order"
            ]
        },
        {
            "id": 473,
            "name": "Custom Exceptions",
            "question": "What is a custom exception? How to create a custom exception? When should we use custom exceptions? What are the advantages of custom exceptions? What is the difference between extending Exception and extending RuntimeException?",
            "answer": "A custom exception is an application-specific exception class that extends Exception or RuntimeException to express domain-specific errors. Create by: public class PaymentFailedException extends Exception { public PaymentFailedException(String msg) { super(msg); } public PaymentFailedException(String msg, Throwable cause) { super(msg, cause); } }. Use custom exceptions to represent domain errors (PaymentFailedException, InvalidInventoryException, OrderCancellationException) and improve code clarity. Advantages: clearer error semantics, ability to attach domain-specific data (transactionId, gatewayCode), easier error handling at service boundaries, better logging/monitoring. Extending Exception creates a checked exceptionâ€”callers must explicitly handle or declare it (good for truly recoverable conditions like payment retries). Extending RuntimeException creates an unchecked exceptionâ€”no explicit handling required (good for programming errors or when forcing handling is undesirable).",
            "useCases": [
                "Create exception classes for business domain errors",
                "Attach metadata (orderId, userId, errorCode) to exceptions for debugging",
                "Use checked custom exceptions for expected failures requiring caller action",
                "Use unchecked custom exceptions for programming errors or validation failures"
            ],
            "realTimeUseCases": [
                "class PaymentGatewayException extends Exception { int gatewayCode; boolean isRetryable; } ",
                "throw new InvalidInventoryStateException(productId, requiredQty, availableQty)",
                "class InsufficientFundsException extends RuntimeException for wallet balance checks"
            ]
        },
        {
            "id": 474,
            "name": "Common Exception Types",
            "question": "What is NullPointerException? What is ArrayIndexOutOfBoundsException? What is NumberFormatException? What is ClassCastException? What is ArithmeticException? What is IllegalArgumentException? What is IllegalStateException? What is IOException? What is SQLException? What is FileNotFoundException?",
            "answer": "NullPointerException (unchecked): thrown when dereferencing null reference (e.g., null.method()). ArrayIndexOutOfBoundsException (unchecked): accessing invalid array index. NumberFormatException (unchecked): parsing invalid numeric strings (Integer.parseInt(\"abc\")). ClassCastException (unchecked): invalid type cast ((String)intObject). ArithmeticException (unchecked): math errors like divide by zero. IllegalArgumentException (unchecked): method received invalid argument (e.g., negative quantity). IllegalStateException (unchecked): object in invalid state for operation (e.g., checkout before login). IOException (checked): I/O failure (file not found, network error, stream closed). SQLException (checked): database error (connection failed, invalid SQL, constraint violation). FileNotFoundException (checked): file doesn't exist; subclass of IOException.",
            "useCases": [
                "Prevent NullPointerException with null checks or Optional",
                "Validate array bounds before access",
                "Validate input format and values to prevent NumberFormatException",
                "Check object state before operations to avoid IllegalStateException",
                "Handle checked exceptions (IOException, SQLException) with try-catch or throws"
            ],
            "realTimeUseCases": [
                "Catch NumberFormatException when parsing user input price and return 400 error",
                "Handle SQLException when DB connection fails; wrap in DataAccessException with retry logic",
                "Throw IllegalArgumentException if quantity <= 0 in addToCart()",
                "Use Optional to prevent NullPointerException when accessing user.getCart()",
                "Catch FileNotFoundException when reading product CSV during batch import"
            ]
        },
        {
            "id": 475,
            "name": "Nested & Multiple Exceptions",
            "question": "What are nested try-catch blocks? When should we use nested try blocks? What is multi-catch block? What is the importance of catch block order?",
            "answer": "Nested try-catch blocks allow inner try-catch to handle specific operations before outer scopes handle broader exceptions. Use nested try blocks when different code sections may throw different exceptions requiring different handling strategies. Multi-catch block (Java 7+) combines handling for related exception types: catch (IOException | SQLException e) { handle similar way } using pipe separator. Catch block order is critical: must go from most specific to most general; placing a superclass catch before subclasses causes compiler error because subclass never matches. Example: catch FileNotFoundException before IOException; catch PaymentException before Exception.",
            "useCases": [
                "Granular error handling at appropriate scope levels",
                "Combine handlers for exceptions with identical handling logic",
                "Avoid swallowing exceptions with overly broad catch blocks",
                "Order catches: specific â†’ general (FileNotFoundException â†’ IOException â†’ Exception)"
            ],
            "realTimeUseCases": [
                "Outer try for transaction; inner try for each operation (read config, validate, persist)",
                "catch (PaymentException | InventoryException e) { log and retry } catch (IOException e) { circuit-breaker }",
                "Catch order: catch (FileNotFoundException) then catch (IOException) then catch (Exception)",
                "Nested: read product file, process each line with inner try-catch for parse errors, outer catch for file access"
            ]
        },
        {
            "id": 476,
            "name": "Exception Propagation",
            "question": "What is exception propagation? How does exception propagation work in Java? Which exceptions support propagation? What is the difference between propagation and rethrowing?",
            "answer": "Exception propagation is the mechanism where an unhandled exception bubbles up the call stack until caught or until it reaches the JVM (which terminates the thread). Propagation works: method A calls B calls C; if C throws and B doesn't catch, exception propagates to A; if A doesn't catch, it propagates further up. Both checked and unchecked exceptions propagate. Checked exceptions must be declared in intermediate methods or caught. Propagation lets higher-level code decide recovery strategy (e.g., API layer catches service exception and returns HTTP error). Propagation vs rethrowing: propagation is automatic (exception bubbles up untouched); rethrowing is explicitly catching and throwing the same or a new exception (possibly adding context). Propagation preserves original stack trace; rethrowing may add new cause/suppression context.",
            "useCases": [
                "Let high-level layers handle recovery (API â†’ Service â†’ Repository)",
                "Translate low-level exceptions into domain exceptions at boundaries",
                "Preserve stack traces for debugging by propagating or chaining exceptions"
            ],
            "realTimeUseCases": [
                "Repository throws IOException â†’ Service catches and throws DataAccessException â†’ Controller catches and returns 503",
                "Propagate PaymentException up to OrderService which decides retry or refund logic",
                "Let authentication failure propagate from UserService to SecurityFilter which returns 401"
            ]
        },
        {
            "id": 477,
            "name": "Rethrowing Exceptions",
            "question": "What is rethrowing an exception? When should we rethrow an exception? What is the purpose of wrapping exceptions? What is exception translation?",
            "answer": "Rethrowing means catching an exception and throwing it again (possibly after logging or adding context): catch (IOException e) { log.error(...); throw e; } or throw new Exception(..., e). Rethrow when current scope can't recover but needs to add context (logging, adding orderId), or when a more general handler should handle it. Wrapping exceptions means converting a low-level exception into a higher-level domain exception to hide implementation details and provide a consistent API: catch (SQLException e) { throw new DataAccessException(..., e); }. Exception translation (or exception wrapping) improves API clarity by exposing domain exceptions instead of technical ones, makes clients unaware of implementation (SQL, HTTP, file I/O), and allows attaching business context (orderId, userId, errorCode). Preserve the original cause using constructor: new DomainException(message, originalException) to retain full stack trace for debugging.",
            "useCases": [
                "Add context (logging, IDs) before rethrowing",
                "Translate technical exceptions to domain-meaningful exceptions at service boundaries",
                "Preserve original cause for complete debugging information",
                "Hide implementation details from callers"
            ],
            "realTimeUseCases": [
                "Catch SQLException in OrderRepository; wrap in OrderPersistenceException(\"Failed to save order \"+orderId, sqlEx)",
                "Log payment failure with correlationId, then rethrow to service layer: throw new PaymentException(msg, paymentEx)",
                "Translate FileNotFoundException to ConfigurationException in SettingsLoader with meaningful context"
            ]
        },
        {
            "id": 478,
            "name": "try-with-resources",
            "question": "What is try-with-resources? Why was try-with-resources introduced? What interfaces must a resource implement? How does try-with-resources handle closing streams? What happens if both try and close generate exceptions?",
            "answer": "try-with-resources (Java 7+) is a language feature that automatically closes resources implementing AutoCloseable: try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) { use conn and stmt } finally close happens automatically. Introduced to eliminate boilerplate finally blocks, prevent resource leaks, and handle multiple resources elegantly. Resources must implement java.lang.AutoCloseable interface (or Closeable which extends AutoCloseable). When try block completes (normally or exceptionally), the close() method is called on each resource in reverse declaration order. If both try and close() throw exceptions: the try block exception is primary, close() exceptions become suppressed and are accessible via Throwable.getSuppressed(); this ensures no exception is lost. Prefer try-with-resources over manual finally-based closing.",
            "useCases": [
                "Automatic resource management for Connections, Statements, Streams",
                "Eliminate null-check boilerplate in finally blocks",
                "Proper exception suppression when multiple exceptions occur"
            ],
            "realTimeUseCases": [
                "try (Connection conn = ds.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) { execute query; } auto-closes both",
                "try (BufferedReader br = new BufferedReader(new FileReader(file))) { read lines; } auto-closes reader",
                "try (InputStream is = Files.newInputStream(path)) { process bytes; } ensures stream closes even if exception occurs"
            ]
        },
        {
            "id": 479,
            "name": "Finally vs System.exit() vs return",
            "question": "Does finally execute when System.exit() is called? What happens when return is inside try? What happens when return is inside catch? What if return exists in finally?",
            "answer": "finally blocks execute in normal execution even with return statements; however System.exit() initiates JVM termination and finally may NOT execute (depends on shutdown hooks and JVM state). A return inside try block will execute finally before returning; the return value is preserved but finally runs first for cleanup. A return inside catch block similarly executes finally before returning. A return inside finally block overrides any earlier returns (this is dangerous and should be avoided): if try returns 1 and finally returns 2, caller gets 2. Don't use finally for critical actions that MUST run on System.exit(); use Runtime.getRuntime().addShutdownHook() instead.",
            "useCases": [
                "Use finally for local resource cleanup, not JVM-level actions",
                "Avoid return in finally to prevent unexpected return values",
                "Use shutdown hooks for critical cleanup when System.exit() may be called"
            ],
            "realTimeUseCases": [
                "finally { connection.close(); } ensures DB connection closes before method returns",
                "Use shutdown hooks to flush logs/metrics if application calls System.exit() during graceful shutdown",
                "Avoid: if (condition) return; in finally as it overrides try/catch returns"
            ]
        },
        {
            "id": 480,
            "name": "Performance & Best Practices",
            "question": "Why should we avoid using exceptions for normal flow? How to design exception handling in large applications? What is the impact of exceptions on performance? Why should we use meaningful messages in exceptions? When should we log exceptions?",
            "answer": "Avoid exceptions for normal flow because throwing and catching exceptions is expensive (stack capture, object allocation). Use validation checks for expected conditions: if (quantity <= 0) throw ... instead of try-catch for each add-to-cart. Impact on performance: exception creation is ~1000x slower than normal return; stack traces are expensive; excessive exceptions in tight loops degrade performance significantly. Design exception handling: fail-fast with validation, translate infrastructure exceptions to domain exceptions at service boundaries, centralize error handling in middleware/controllers, avoid swallowing exceptions. Meaningful messages improve debugging: include context (userId, orderId, transactionId), describe what went wrong and expected recovery. Log exceptions at appropriate levels: INFO for expected failures (invalid login attempt), WARN for unexpected but recoverable (retry-able payment failure), ERROR for unexpected failures requiring attention (DB connection lost). Include correlation IDs and structured logging for distributed tracing.",
            "useCases": [
                "Validate inputs early to fail-fast without exceptions",
                "Centralize exception translation and logging at boundaries",
                "Use meaningful exception messages with context data",
                "Log with appropriate severity and correlation IDs"
            ],
            "realTimeUseCases": [
                "Validate quantity > 0 before transaction instead of catching exception in loop",
                "Log payment failure: error(correlationId={}, orderId={}, reason={}, retryable={}; userId={}; gatewayCode={})",
                "Catch Exception at Controller boundary, log once with context, return standardized API error response"
            ]
        },
        {
            "id": 481,
            "name": "Exceptions in Constructors",
            "question": "Can constructors throw exceptions? What happens if exception is thrown inside a constructor? Can we handle constructor-level exceptions with try-catch? What happens to the object if constructor throws an exception?",
            "answer": "Constructors can throw both checked and unchecked exceptions. If a constructor throws an exception, object construction fails and the object is NOT created; partially-initialized state must be cleaned up inside the constructor or delegated to try-finally. Callers must catch or declare checked exceptions thrown by constructors. If constructor throws, the object reference is never assigned; the exception propagates to the caller who can try-catch it. You CAN handle constructor exceptions with try-catch in caller: try { obj = new PaymentClient(config); } catch (ConfigurationException e) { use default config; }. Prefer factory methods or builder patterns for complex initialization where failures are common: public static PaymentClient create(Config) returns Optional or throws checked exception. If constructor throws, ALL initialization code before the throw has executed, but resources allocated in constructor must be manually cleaned up if exception occurs.",
            "useCases": [
                "Force callers to handle initialization failures via checked exceptions",
                "Use factory methods for complex initialization with optional return types",
                "Clean up partially-initialized resources in constructor finally blocks"
            ],
            "realTimeUseCases": [
                "Constructor throws ConfigurationException if payment gateway credentials invalid",
                "OrderBuilder.build() throws InvalidOrderException if items empty or total <= 0",
                "Use factory: PaymentClient client = PaymentClient.create(config) instead of relying on constructor exception handling"
            ]
        },
        {
            "id": 482,
            "name": "Exceptions in Method Overriding",
            "question": "Can child class override a method and throw fewer or narrower exceptions? Can child class throw broader exceptions during overriding? What if parent method throws no exception â€” can child throw exceptions?",
            "answer": "Child class overriding method can throw FEWER or NARROWER checked exceptions than parent signature (good for Liskov substitutability). Child class CANNOT throw BROADER checked exceptions than parent declares; attempting to throw a superclass exception will cause compiler error. Example: if parent declares throws IOException, child can declare throws FileNotFoundException (narrower) or nothing, but NOT throws Exception or IOException | SQLException. If parent method throws NO checked exceptions, child override CANNOT add any checked exceptions. This ensures callers using parent type reference don't encounter unexpected checked exceptions. Child can throw ANY unchecked exceptions regardless of parent (RuntimeException subclasses are not constrained). Violating these rules breaks contract-based polymorphism and causes compilation failure.",
            "useCases": [
                "Design APIs with compatible exception contracts across inheritance",
                "Ensure Liskov substitutability in exception declarations",
                "Avoid adding unexpected checked exceptions in overrides"
            ],
            "realTimeUseCases": [
                "Service interface throws DataAccessException; implementation throws specific SQLException wrapped into DataAccessException",
                "PaymentProcessor.process() parent throws PaymentException; child CreditCardProcessor.process() throws CreditCardException (narrower) or nothing"
            ]
        },
        {
            "id": 483,
            "name": "Errors",
            "question": "What is OutOfMemoryError? What is StackOverflowError? Can we handle errors in Java? Why we should not handle errors using try-catch?",
            "answer": "OutOfMemoryError occurs when JVM cannot allocate requested memory (heap exhausted). StackOverflowError occurs when call stack exceeds limit (infinite recursion, huge stack frames). You CAN technically catch Errors with try-catch, but it's unsafe and discouraged. Don't handle errors because: JVM state is likely inconsistent after an Error, recovery is unreliable, continuing execution after OutOfMemoryError means unpredictable behavior, attempting cleanup may trigger secondary errors. Instead: focus on PREVENTION (memory tuning, recursion guards, monitoring), set alerts for memory thresholds, use graceful degradation (refuse requests instead of crashing), rely on monitoring/observability (JVM metrics, heap analysis). Let errors propagate and terminate the thread/application; use shutdown hooks for critical cleanup if needed.",
            "useCases": [
                "Monitor heap usage and set alerts for OOM prevention",
                "Guard against deep recursion with max-depth checks",
                "Use -Xmx JVM flag to prevent uncontrolled OOM scenarios",
                "Implement circuit breakers to prevent cascading resource exhaustion"
            ],
            "realTimeUseCases": [
                "During flash sales: monitor heap spikes; refuse new orders if memory > 80% instead of OOM crash",
                "Guard CSV import: check recursion depth before processing nested structures, fail fast if exceeds 100 levels",
                "Monitor product-count spikes; if approaching heap limit, return 503 Service Unavailable to shed load"
            ]
        },
        {
            "id": 484,
            "name": "Real-Time eCommerce Exceptions Use Cases",
            "question": "Where did you use exception handling in your NMG eCommerce project? How did you handle invalid login attempts using exceptions? How did you handle payment gateway failures using custom exceptions? How did you handle invalid product or inventory states using exceptions? How did you use exceptions in order placement and cancellation flows? How did exception handling improve debugging/logging in your system?",
            "answer": "In NMG eCommerce we used exceptions throughout a layered architecture: Repository/DAO threw checked exceptions; Service layer caught and translated to domain exceptions; Controller caught domain exceptions and returned appropriate HTTP responses. Invalid login: validated input format, checked against DB, threw AuthenticationException on failure; incremented failed-attempt counter and locked account after threshold (3 attempts). Implemented lockout timer to prevent brute force. Payment gateway failures: wrapped gateway API exceptions into PaymentGatewayException carrying gatewayCode (for root-cause analysis), isRetryable flag (for circuit-breaker logic), and original cause. Implemented idempotent payment retry with exponential backoff for transient failures; non-retryable failures triggered refund workflow. Invalid product/inventory states: threw InvalidInventoryStateException when requested quantity exceeded available stock; this prevented overselling. Enqueued compensating transaction (refund payment, release reserved stock) when exception occurred during order placement. Order placement: orchestrated multiple services (Inventory, Payment, Notification) with exception boundaries; payment failure rolled back inventory reservation via compensating transaction. Order cancellation: threw OrderCancellationException for invalid states (already shipped, already cancelled); drove compensating workflow to refund payment and restore inventory. Exception handling improved debugging: attached correlationId to all exceptions for distributed tracing across services; logged userId, orderId, productId, and transactionId context; exported exceptions to centralized telemetry (Sentry/ELK) with full stack traces and suppressed exceptions; provided meaningful error messages for user-facing errors and technical details for engineers.",
            "useCases": [
                "Layer-wise exception translation: Repository â†’ Service â†’ Controller",
                "Attach business context (userId, orderId, correlationId) to exceptions",
                "Implement compensating transactions triggered by exceptions",
                "Use circuit breakers for transient failures (IOException, timeout exceptions)",
                "Export exceptions to centralized monitoring (Sentry, ELK, DataDog)"
            ],
            "realTimeUseCases": [
                "Login: throw AuthenticationException; increment failed-attempt; lock account; log with userId, timestamp, IP address",
                "Payment: catch GatewayException; if retryable, queue retry job with correlationId; if fatal, trigger refund compensating transaction",
                "Inventory: throw InvalidInventoryStateException(productId, requiredQty, availableQty); prevent oversell; enqueue stock-restoration workflow",
                "Order: validate all steps in try blocks; on any failure, rethrow as OrderProcessingException with orderId context; controller logs and returns 422 Unprocessable Entity",
                "Debugging: LoggingFilter wraps correlationId; all exceptions logged with userId, orderId, exception type, message, and stack trace; exported to ELK with aggregation queries"
            ]
        },
        {
            "id": 485,
            "name": "Basics of Multithreading",
            "question": "What is a thread in Java? What is multithreading? Why does Java support multithreading? What are the advantages of multithreading? What are the disadvantages or challenges of multithreading? What is the difference between process and thread? How many ways can we create a thread in Java? What is the syntax of creating a thread by extending Thread class? What is the syntax of creating a thread by implementing Runnable? Why Runnable is preferred over Thread class? Can we create a thread without extending Thread class?",
            "answer": "A thread is the smallest unit of execution within a process; a lightweight subprocess with its own stack, program counter, and execution context. Multithreading is running multiple threads concurrently within the same process, sharing memory and resources but executing independently. Java supports multithreading to enable concurrent task execution, improve responsiveness, and better utilize multi-core processors. Advantages: better resource utilization (keep CPU busy while waiting for I/O), responsive UI (separate I/O from UI thread), improved throughput (execute multiple tasks in parallel), leverages multi-core processors. Disadvantages: complexity (race conditions, deadlocks, synchronization bugs), harder to debug, increased memory overhead (each thread has its own stack), context switching overhead. Process vs Thread: process is a complete execution environment with its own memory, resources, and file descriptors; thread is a lightweight entity sharing process memory and resources with other threads. Two ways to create threads: (1) extend Thread class: public class MyThread extends Thread { public void run() { } } then new MyThread().start(); (2) implement Runnable: public class MyRunnable implements Runnable { public void run() { } } then new Thread(new MyRunnable()).start(). Runnable is preferred because Java doesn't support multiple inheritance; implementing Runnable allows extending another class. You can create a thread without extending Thread class by implementing Runnable, allowing the class to extend any other class.",
            "useCases": [
                "Execute I/O operations asynchronously to keep main thread responsive",
                "Handle multiple concurrent requests in server applications",
                "Leverage multi-core processors for CPU-bound calculations",
                "Separate UI updates from long-running operations"
            ],
            "realTimeUseCases": [
                "Implement order processing: main thread accepts HTTP requests; worker threads process orders concurrently",
                "Payment processing thread pool: multiple threads handle payment requests independently",
                "Background notification thread: send order confirmations without blocking user response",
                "Cache warming thread: pre-load product data while serving customer requests"
            ]
        },
        {
            "id": 486,
            "name": "Thread Lifecycle",
            "question": "What are the states of a thread in Java? What is the NEW state? What is RUNNABLE state? What is BLOCKED state? What is WAITING state? What is TIMED_WAITING state? What is TERMINATED state? What happens internally when thread.start() is called?",
            "answer": "Thread lifecycle has 6 states: NEW (created but not started), RUNNABLE (eligible to run, scheduled or executing), BLOCKED (blocked on monitor lock during synchronized access), WAITING (waiting indefinitely for another thread, via wait()), TIMED_WAITING (waiting with timeout, via sleep(long), wait(long), join(long)), TERMINATED (execution completed or stopped). NEW: thread object created, start() not yet called. RUNNABLE: thread.start() called; thread eligible for execution by scheduler. BLOCKED: thread waiting to acquire intrinsic lock (synchronized block/method competitor holds lock). WAITING: thread called wait() without timeout; waiting for notify()/notifyAll(). TIMED_WAITING: thread called sleep(ms), wait(ms), or join(ms); automatically returns after timeout. TERMINATED: thread execution completed (run() returned) or exception thrown. When thread.start() is called: JVM creates native thread, allocates stack memory, sets thread to RUNNABLE state, scheduler assigns CPU time. Calling run() directly executes method in current thread, not creating new thread.",
            "useCases": [
                "Monitor thread states for debugging and performance analysis",
                "Use thread state awareness for synchronization logic",
                "Understand transitions for lock acquisition and release patterns"
            ],
            "realTimeUseCases": [
                "Order processing thread: NEW â†’ RUNNABLE (queue task) â†’ BLOCKED (waiting for DB) â†’ RUNNABLE (DB response) â†’ TERMINATED",
                "Payment verification thread: RUNNABLE â†’ WAITING (wait for notification from gateway) â†’ RUNNABLE (gateway response) â†’ TERMINATED",
                "Cache update thread: RUNNABLE â†’ TIMED_WAITING (sleep 60s) â†’ RUNNABLE (refresh cache) â†’ loop"
            ]
        },
        {
            "id": 487,
            "name": "Thread Methods",
            "question": "What is start() method? What is run() method? What is the difference between start() and run()? What is sleep()? What is join()? What is yield()? What is interrupt()? What happens when thread is interrupted? What is setPriority()? How thread priorities work internally?",
            "answer": "start() method creates a new thread and calls run() in that thread context; run() is the actual work method executed in the new thread. Difference: start() creates new thread (asynchronous), run() executes in current thread (synchronous, no new thread). sleep(long ms) pauses current thread for specified milliseconds; throws InterruptedException if interrupted; doesn't release locks. join() causes calling thread to wait until target thread terminates: thread1.join() makes current thread wait for thread1 completion. yield() suggests scheduler to give other threads CPU time; not guaranteed, low-level hint only. interrupt() sets thread's interrupt flag; doesn't immediately stop thread; InterruptedException thrown in sleep/wait/join. Interrupted thread checking: Thread.currentThread().isInterrupted() returns flag status. setPriority(int) sets thread priority (1-10, default 5); higher priority threads get more CPU time. Priorities work: scheduler favors higher-priority threads; still thread-dependent on OS. Example: thread.setPriority(Thread.MAX_PRIORITY) or Thread.MIN_PRIORITY (1) or Thread.NORM_PRIORITY (5).",
            "useCases": [
                "Use sleep() for polling, backoff, or scheduled tasks",
                "Use join() to wait for completion of spawned tasks",
                "Use interrupt() for graceful thread termination",
                "Use setPriority() for critical vs background tasks"
            ],
            "realTimeUseCases": [
                "Payment retry: sleep(1000) then retry on timeout",
                "Order processing: main thread spawns workers, calls join() to wait for all orders processed",
                "Shutdown gracefully: interrupt() background threads, catch InterruptedException",
                "High-priority thread for order acceptance, low-priority for batch reporting"
            ]
        },
        {
            "id": 488,
            "name": "Thread Safety & Synchronization",
            "question": "What is thread safety? What is race condition? What causes race conditions in Java? What is synchronization in Java? What is the synchronized keyword? What is a synchronized method? What is a synchronized block? What is intrinsic lock (monitor lock)? What happens internally when a thread acquires a lock? What is reentrant lock? What is deadlock? What is livelock? What is starvation? How to prevent deadlocks?",
            "answer": "Thread safety means a class/method produces correct results even with concurrent access from multiple threads. Race condition is when multiple threads access shared data and at least one modifies it, causing unpredictable results. Caused by: unsynchronized access to mutable shared state, non-atomic compound operations (read-modify-write not atomic). Synchronization prevents race conditions by enforcing mutual exclusion (only one thread in critical section at a time). synchronized keyword makes method/block thread-safe: synchronized method locks entire object; synchronized block locks specific object monitor. Intrinsic lock (monitor lock) is implicit lock on every Java object; acquired when entering synchronized block/method, released on exit. When thread acquires lock: blocked if another thread holds lock, waits on queue, acquires when released. Reentrant lock (or reentrant monitor): same thread can re-acquire lock multiple times (e.g., synchronized method calling another synchronized method on same object); lock count incremented. Deadlock: two threads waiting for locks held by each other; threads blocked forever. Livelock: threads respond to each other's actions, making no progress (e.g., two threads keep yielding to each other). Starvation: low-priority thread never gets CPU time due to high-priority threads. Prevent deadlocks: acquire locks in consistent order, use timeout (tryLock with timeout), avoid nested locks, use ReentrantReadWriteLock, use atomic operations.",
            "useCases": [
                "Protect shared mutable state with synchronized methods/blocks",
                "Use volatile for visibility without synchronization overhead",
                "Minimize critical section size for better concurrency",
                "Design lock acquisition order to prevent deadlock"
            ],
            "realTimeUseCases": [
                "Inventory updates: synchronized void decreaseStock(productId, qty) prevents oversell race condition",
                "Cart concurrent access: synchronized Map<userId, Cart> ensures thread-safe add/remove/get operations",
                "Order counter: synchronized int incrementOrderCount() ensures accurate order numbering",
                "Transaction ledger: use ReentrantReadWriteLock for many readers, few writers (inventory balance queries vs updates)"
            ]
        },
        {
            "id": 489,
            "name": "Inter-Thread Communication",
            "question": "What is inter-thread communication? What are wait(), notify(), and notifyAll()? Why wait(), notify(), notifyAll() must be used inside synchronized block? What happens if wait() is called without holding lock? What happens when wait() is called without holding lock? When should we use notify() and when notifyAll()? What is producerâ€“consumer problem?",
            "answer": "Inter-thread communication is coordination between threads to achieve synchronization; enabling one thread to signal another about state changes. wait() causes thread to release lock and wait until notified; notify() wakes one waiting thread; notifyAll() wakes all waiting threads. Must be called inside synchronized block because: wait() releases lock while waiting (require lock to enter synchronized); notify() needs lock to prevent race condition with wait(). If wait() called without holding lock, IllegalMonitorStateException thrown at runtime. notify() wakes one arbitrary waiting thread (used when only one thread needs waking); notifyAll() wakes all waiting threads (safer, ensures correct thread gets notification). Producer-consumer: producer thread generates data, consumer processes data; producer and consumer must coordinate to avoid data loss or consuming stale data. Solution: use queue, producer waits if queue full, consumer waits if queue empty, use notify to signal state changes.",
            "useCases": [
                "Implement producer-consumer with BlockingQueue or wait/notify",
                "Coordinate multiple threads waiting on a condition",
                "Signal completion of background tasks to main thread"
            ],
            "realTimeUseCases": [
                "Order queue: producer (payment thread) adds orders, consumer (fulfillment thread) processes; use notifyAll() to wake consumer on new order",
                "Inventory sync: inventory update thread notifies cache invalidation threads using notifyAll()",
                "Batch processing: collector thread waits for batch to reach threshold, processor thread notifies when threshold met"
            ]
        },
        {
            "id": 490,
            "name": "Volatile Keyword & Memory Visibility",
            "question": "What is the volatile keyword? What problem does volatile solve? What is memory visibility in multithreading? How volatile prevents caching issues? What is the difference between volatile and synchronized? When should volatile be used? Why volatile does NOT guarantee atomicity?",
            "answer": "volatile keyword ensures visibility of variable changes across threads; a volatile variable is never cached in thread-local memory. Solves memory visibility problem: without volatile, thread may cache variable value and not see updates from other threads. Memory visibility: each thread has its own working memory (cache) of shared variables; volatile ensures all threads see latest value from main memory. Prevents caching: volatile reads/writes bypass thread cache and go directly to main memory; ensures freshness. volatile vs synchronized: volatile is lightweight (no lock), only for visibility; synchronized provides visibility + atomicity (mutual exclusion). volatile does NOT provide atomicity; individual read/write is atomic but compound operations (i++ = read-modify-write) are not atomic. When to use volatile: simple flags (shutdown flag), status updates, performance-critical code where synchronization overhead is unacceptable. Example: volatile boolean shutdownFlag = false; // threads check this flag without lock.",
            "useCases": [
                "Signal flags (shutdown, pause, resume) without synchronization overhead",
                "Status indicators in high-frequency scenarios",
                "Simple value updates that don't require atomicity"
            ],
            "realTimeUseCases": [
                "volatile boolean orderProcessing = true; // all worker threads check without lock overhead",
                "volatile int activeConnections; // multiple request threads update connection count",
                "volatile long lastInventoryRefresh; // cache validity check without synchronization"
            ]
        },
        {
            "id": 491,
            "name": "Thread Pools & Executors",
            "question": "What is Executor framework? Why should we avoid creating threads manually? What is ThreadPoolExecutor? What is a fixed thread pool? What is a cached thread pool? What is ScheduledExecutorService? What is Future? What is Callable interface? What is the difference between Callable and Runnable?",
            "answer": "Executor framework (java.util.concurrent) provides abstraction for thread creation and management; execute(Runnable) instead of new Thread().start(). Avoid manual thread creation: threads are expensive (memory, context switching); creating thousands of threads causes resource exhaustion. ThreadPoolExecutor manages pool of reusable threads; reuses threads instead of creating new ones. Fixed thread pool (Executors.newFixedThreadPool(n)): maintains exactly n threads; queues excess tasks; used when you know thread count needed. Cached thread pool (Executors.newCachedThreadPool()): creates threads as needed, reuses idle threads; terminates idle threads after 60s timeout; good for variable load. ScheduledExecutorService: schedules tasks for future execution or periodic execution; schedule(task, delay, unit) or scheduleAtFixedRate(). Future represents result of asynchronous computation; get() blocks until result available; cancel() cancels task. Callable<V> is like Runnable but returns result and can throw checked exceptions: V call() throws Exception. Difference: Runnable returns void, cannot throw checked exceptions; Callable<V> returns V, throws exceptions.",
            "useCases": [
                "Use thread pools for server request handling",
                "Schedule periodic tasks (cache refresh, metrics collection)",
                "Execute async operations and get results via Future"
            ],
            "realTimeUseCases": [
                "Order processing: ExecutorService executor = Executors.newFixedThreadPool(10); submit order tasks to executor",
                "Payment verification: ScheduledExecutorService scheduleAtFixedRate(paymentCheck, initialDelay=0, period=5, SECONDS)",
                "Async API call: Future<PaymentResponse> future = executor.submit(new Callable<PaymentResponse>() { return paymentGateway.verify(); }); response = future.get(timeout);"
            ]
        },
        {
            "id": 492,
            "name": "Concurrent Collections (Multithreading Context Only)",
            "question": "What is ConcurrentHashMap? How is ConcurrentHashMap different from HashMap? What is CopyOnWriteArrayList? When to use concurrent collections?",
            "answer": "ConcurrentHashMap is a thread-safe Map using fine-grained locking (segment-level or node-level); multiple threads can access different segments concurrently without full-map lock. Different from HashMap: HashMap is not thread-safe; concurrent modifications cause undefined behavior; ConcurrentHashMap allows concurrent reads and writes with minimal contention. CopyOnWriteArrayList is thread-safe List that copies entire array on modification (write expensive, read cheap); good for read-heavy scenarios with infrequent updates. Use concurrent collections when: shared mutable state accessed by multiple threads, need thread-safety without synchronized keyword overhead, read-heavy (CopyOnWriteArrayList) or general concurrent access (ConcurrentHashMap).",
            "useCases": [
                "Shared caches and counters (ConcurrentHashMap)",
                "Event listener lists (CopyOnWriteArrayList)",
                "Concurrent inventory/session stores",
                "Thread-safe collections without explicit synchronization"
            ],
            "realTimeUseCases": [
                "Inventory cache: ConcurrentHashMap<productId, Stock> allows concurrent product lookups and updates during flash sales",
                "Active user sessions: ConcurrentHashMap<sessionToken, UserSession> enables high-concurrency user access",
                "Event listeners: CopyOnWriteArrayList<OrderListener> for registering listeners with rare adds, frequent iterations"
            ]
        },
        {
            "id": 493,
            "name": "Locks & Advanced Synchronizers",
            "question": "What is Lock interface? What is ReentrantLock? What is ReentrantReadWriteLock? What is Condition interface? What is Semaphore in Java? What is CountDownLatch? What is CyclicBarrier? What is Phaser?",
            "answer": "Lock interface (java.util.concurrent.locks) provides explicit locking: lock(), unlock(), tryLock(). More control than synchronized; allows fairness, try-acquire with timeout, interruptible locking. ReentrantLock: explicit reentrant lock (same thread acquires multiple times); must call unlock() for each lock() call; supports fairness (fair queuing). ReentrantReadWriteLock: allows multiple concurrent readers or single exclusive writer; improves throughput for read-heavy scenarios. Condition interface: await() (like wait()), signal() (like notify()), signalAll() (like notifyAll()); used with Lock. Semaphore: controls access to N resources; acquire() decrements count, release() increments; permits concurrent access to N threads. CountDownLatch: allows threads to wait until N events occur; countDown() decrements, await() waits until counter reaches 0; one-time use. CyclicBarrier: allows N threads to wait until all reach barrier; then all proceed together; reusable (resets after all pass). Phaser: more flexible version of CyclicBarrier; flexible number of parties, multiple phases, dynamic registration.",
            "useCases": [
                "Use Lock for timeout-based lock acquisition",
                "Use ReadWriteLock for read-heavy data structures",
                "Use Semaphore for resource pool management",
                "Use CountDownLatch for one-time synchronization point",
                "Use CyclicBarrier for repeated synchronization"
            ],
            "realTimeUseCases": [
                "Payment verification: Semaphore(maxConcurrentPayments=50) limits simultaneous payment API calls",
                "Order completion: CountDownLatch(3) waits for payment, inventory, notification threads; all must finish",
                "Cache refresh: CyclicBarrier(4) synchronizes 4 worker threads to simultaneously refresh cache sections",
                "Checkout process: ReentrantReadWriteLock for product price updates (write lock) and read-heavy lookups (read lock)"
            ]
        },
        {
            "id": 494,
            "name": "Daemon Threads",
            "question": "What is a daemon thread? What is the difference between user thread and daemon thread? When should we use daemon threads? Why daemon threads cannot be used for critical operations?",
            "answer": "Daemon thread is a low-priority background thread; JVM exits when only daemon threads remain (doesn't wait for daemon completion). User thread (non-daemon) is a regular thread; JVM doesn't exit until all user threads complete. Difference: daemon threads are automatically terminated when JVM shuts down, user threads block JVM shutdown. When to use daemon threads: background tasks not critical to application (garbage collection, cache cleanup, monitoring), tasks that can be interrupted without data loss. Cannot use for critical operations because: JVM may terminate abruptly, no guarantee task completes, data loss risk (file writes, transactions not flushed). Example: Thread t = new Thread(...); t.setDaemon(true); t.start();",
            "useCases": [
                "Background monitoring and housekeeping tasks",
                "Periodic cache cleanup and maintenance",
                "Non-critical logging and metric collection"
            ],
            "realTimeUseCases": [
                "Daemon thread for cache eviction: every 10 minutes, remove expired entries",
                "Background monitoring thread: daemon thread logs system metrics (non-critical)",
                "Session cleanup daemon: periodically invalidate expired sessions"
            ]
        },
        {
            "id": 495,
            "name": "ThreadGroup",
            "question": "What is ThreadGroup in Java? Why ThreadGroup is rarely used today? How to get the active thread count in a ThreadGroup?",
            "answer": "ThreadGroup is a container for grouping related threads; allows managing threads collectively (interrupt all, get count). Rarely used today because: modern applications use Executor/ThreadPool frameworks which manage threads better, ThreadGroup doesn't provide enough control for complex scenarios, thread-local storage and other mechanisms are more flexible. Get active thread count: ThreadGroup tg = thread.getThreadGroup(); int count = tg.activeCount(); This is approximate (may include newly created threads or recently-finished threads) and deprecated in newer Java versions.",
            "useCases": [
                "Legacy code that uses ThreadGroup for organization",
                "Simple multi-threaded applications requiring basic grouping"
            ],
            "realTimeUseCases": [
                "Legacy monitoring: ThreadGroup admin = new ThreadGroup(\"admin\"); threads assigned to group",
                "Modern replacement: use ExecutorService for better thread management in eCommerce services"
            ]
        },
        {
            "id": 496,
            "name": "Multithreading Performance",
            "question": "How does multithreading improve performance? When multithreading can reduce performance? How context switching affects performance? What is false sharing in multithreading? How to optimize CPU-bound vs IO-bound threads?",
            "answer": "Improves performance: I/O-bound threads (wait for I/O while others execute), leverages multi-core processors (CPU-bound parallelism), responsive UI (separate I/O from UI thread). Reduces performance: excessive threads (context switching overhead, memory), fine-grained locking (contention and lock waits), thread creation/destruction overhead. Context switching: OS scheduler switches CPU from one thread to another; saves/restores thread state (registers, memory); overhead increases with thread count. False sharing: multiple threads on different cores access variables in same cache line; cache coherency traffic invalidates cache, reducing performance (padding variables to different cache lines helps). CPU-bound optimization: limit threads to CPU core count (avoid oversubription), minimize lock contention, use lock-free data structures. I/O-bound optimization: use more threads than cores (hide I/O latency), async I/O, thread pools sized for throughput.",
            "useCases": [
                "Size thread pools appropriately for CPU vs I/O bound work",
                "Monitor context switching rates for performance tuning",
                "Avoid false sharing by padding data structures",
                "Use lock-free data structures for high-contention scenarios"
            ],
            "realTimeUseCases": [
                "Order processing (I/O-bound): use 100+ threads for DB/API calls",
                "Payment calculation (CPU-bound): use thread pool size = number of cores",
                "Monitor context switch rate during flash sales; if high, reduce thread count",
                "Cache-aligned Order objects to prevent false sharing in multi-threaded order processing"
            ]
        },
        {
            "id": 497,
            "name": "Exception Handling in Threads",
            "question": "How to handle exceptions in threads? What happens if run() throws an exception? What is UncaughtExceptionHandler?",
            "answer": "Handle exceptions in threads: catch inside run() method (exception doesn't propagate to caller), use UncaughtExceptionHandler to catch uncaught exceptions. If run() throws uncaught exception: thread terminates, exception propagates to UncaughtExceptionHandler (if set) or prints to stderr. UncaughtExceptionHandler is a callback invoked when thread terminates with uncaught exception; set via thread.setUncaughtExceptionHandler(handler) or Thread.setDefaultUncaughtExceptionHandler() for all threads. Example: thread.setUncaughtExceptionHandler((t, e) -> { log.error(\"Thread \" + t.getName() + \" crashed\", e); }).",
            "useCases": [
                "Centralized exception logging for all background threads",
                "Alert on thread crashes",
                "Recover from thread failures gracefully"
            ],
            "realTimeUseCases": [
                "Order processor threads: setUncaughtExceptionHandler to log crashes and alert ops team",
                "Payment service thread: catch PaymentException, log with correlationId, notify user of failure",
                "Background cache refresh: UncaughtExceptionHandler logs error, triggers cache staleness alert"
            ]
        },
        {
            "id": 498,
            "name": "Real-Time eCommerce Multithreading Use Cases",
            "question": "Where did you use multithreading in your NMG eCommerce project? How did multithreading improve performance in order processing? How did you use executor services for background tasks? How did you use multithreading for inventory updates? How did you handle concurrent cart updates? How did multithreading help in payment processing or notifications? How did you use multi-threaded logging/report generation?",
            "answer": "In NMG eCommerce multithreading was central to performance and concurrency. Order processing: main thread accepted HTTP requests; OrderProcessingExecutor (fixed thread pool of 50) processed orders concurrently; each order thread accessed inventory, payment, and notification services sequentially. Performance improved: throughput increased 50x (single-threaded = 20 orders/sec, multi-threaded = 1000 orders/sec during peak). Executor services for background: ScheduledExecutorService ran cache warming every 5 minutes, notification delivery every 2 seconds, inventory sync every 10 seconds. Inventory updates: ConcurrentHashMap<productId, Stock> prevented race conditions on concurrent stock decrements; Semaphore(maxConcurrentUpdates=20) limited simultaneous DB writes to prevent connection pool exhaustion. Concurrent cart updates: synchronized void addItem() in CartService, or used ReentrantLock for better performance; atomic operations for item count. Payment processing: separate PaymentProcessorPool (thread pool size=30) handled payment verification, retries, and refunds concurrently; used CountDownLatch to wait for all payment threads before order confirmation. Notifications: NotificationExecutor queued email/SMS/push tasks; CopyOnWriteArrayList<NotificationListener> maintained listeners (few updates, many reads). Logging/reporting: LoggingExecutor queued log writes (non-blocking), ReportScheduler generated reports nightly (low-priority daemon threads). Exception handling: UncaughtExceptionHandler on all executor threads logged thread crashes with full context.",
            "useCases": [
                "Concurrent order processing with thread pools",
                "Async background task execution with ScheduledExecutorService",
                "Thread-safe inventory updates with ConcurrentHashMap + Semaphore",
                "Concurrent cart/checkout operations",
                "Parallel payment verification and notification delivery",
                "Non-blocking logging and batch reporting"
            ],
            "realTimeUseCases": [
                "Order endpoint: ExecutorService.submit(order) â†’ orderThread does inventory check, payment, shipping â†’ returns immediately, client polls status",
                "Payment verification: 30 concurrent payment gateway calls using PaymentProcessorPool; CountDownLatch waits for all responses",
                "Inventory update: ConcurrentHashMap stock decremented by multiple order threads; Semaphore limits DB connection usage",
                "Cart concurrent updates: user adds item â†’ synchronized addItem() â†’ thread-safe increment quantity + add to cart list",
                "Notification delivery: NotificationExecutor queues email/SMS; multiple NotificationWorkerThreads drain queue async",
                "Scheduled tasks: ScheduledExecutorService.scheduleAtFixedRate(cacheWarmer, 0, 5, MINUTES) warmups cache nightly",
                "Exception handling: UncaughtExceptionHandler on all worker threads logs crashes to ELK with correlationId, orderId, userId"
            ]
        }
    ],
    "Java8-Features": [
        {
            "id": 1,
            "name": "Lambda Expressions",
            "question": "What is a Lambda Expression in Java 8? What is its syntax? What are its inputs and return type rules? Why do we use it? What problems does it solve (before Java 8)? What are the real-time use cases of Lambda? In which scenarios do we use Lambda Expressions? Where did you use Lambda Expressions in your real-time NMG eCommerce Project?",
            "answer": "A Lambda Expression is an anonymous function (function without name) introduced in Java 8 to enable functional programming. Syntax: (parameters) -> expression or (parameters) -> { statements; }. Inputs can be zero or more parameters (with optional type inference); return type is inferred from context. Inputs and return types are determined by the functional interface method signature. Used for writing concise code, enabling functional programming style, and passing behavior to methods. Before Java 8, required verbose anonymous inner classes: new Runnable() { public void run() { } } instead of () -> {}. Real-time use cases: event handling, stream operations, callbacks, parallel processing. Lambda is used when implementing functional interfaces, event listeners, thread creation, collection operations. In NMG eCommerce: used Lambda in stream filters (filter(order -> order.total() > 1000)), map operations (map(product -> product.getPrice())), forEach iteration (orders.forEach(order -> processOrder(order))), Comparator sorting (products.sort((p1, p2) -> p1.rating() - p2.rating())), event listeners (button.setOnClickListener(event -> handleCheckout())), thread creation (new Thread(() -> refreshCache())).start()), and payment processing callbacks (paymentGateway.verify(transaction, response -> handlePaymentResult(response))).",
            "useCases": [
                "Event handling and listeners",
                "Stream operations and filtering",
                "Comparators for sorting",
                "Thread creation and async tasks",
                "Callback handling"
            ],
            "realTimeUseCases": [
                "Product filtering: products.stream().filter(p -> p.price() <= budget).collect(Collectors.toList())",
                "Order processing: orders.forEach(order -> saveToDb(order))",
                "Sorting users by registration date: users.sort((u1, u2) -> u1.registeredDate().compareTo(u2.registeredDate()))",
                "Payment retry: new Thread(() -> retryPayment(orderId)).start()",
                "Button click: checkoutButton.setOnAction(e -> processCheckout())"
            ]
        },
        {
            "id": 2,
            "name": "Functional Interfaces",
            "question": "What is a Functional Interface in Java 8? What is its structure? How many abstract methods can a functional interface contain? Why was it introduced? What problem does it solve? What are the real use cases? Where did you use a Functional Interface in your NMG project?",
            "answer": "A Functional Interface is an interface with exactly ONE abstract method. Structure: interface FunctionalInterface { void someMethod(); }. Contains only ONE abstract method (can have multiple default or static methods). Introduced to enable functional programming in Java; provides target type for Lambda Expressions and Method References. Solves the problem of verbose anonymous inner class syntax by allowing Lambdas to implement a single method concisely. Real use cases: Predicate (testing conditions), Function (transforming data), Consumer (side effects), Supplier (providing values), Runnable (thread execution). In NMG: used Functional Interfaces like Predicate for filtering products (Predicate<Product> isPremium = p -> p.isPremium()), Function for mapping orders to DTOs (Function<Order, OrderDTO> mapper = order -> new OrderDTO(order)), Consumer for processing notifications (Consumer<Notification> sender = notif -> emailService.send(notif)), Supplier for lazy loading product details (Supplier<List<Product>> productLoader = () -> database.loadProducts()), custom functional interfaces for payment validators (interface PaymentValidator { boolean validate(Payment p); }).",
            "useCases": [
                "Predicate for filtering and condition testing",
                "Function for data transformation",
                "Consumer for side-effect operations",
                "Supplier for lazy initialization",
                "Custom functional interfaces for domain logic"
            ],
            "realTimeUseCases": [
                "Filter premium customers: Predicate<Customer> isPremium = c -> c.getStatus().equals(\"PREMIUM\")",
                "Convert Order to DTO: Function<Order, OrderDTO> mapper = order -> new OrderDTO(order.getId(), order.getTotal())",
                "Send notifications: Consumer<Order> notifier = order -> notificationService.notify(order)",
                "Load products on demand: Supplier<List<Product>> loader = () -> productCache.getOrLoad()",
                "Validate payment: PaymentValidator validator = payment -> payment.amount() > 0 && payment.card() != null"
            ]
        },
        {
            "id": 3,
            "name": "Types of Functional Interfaces",
            "question": "What are the Types of Functional Interfaces available in Java 8? For each one (Predicate, Function, Consumer, Supplier, BiPredicate, BiFunction, BiConsumer): What is the method name? What is the method syntax? What are the input parameters? What is the return type? What problems does it solve? What are the real-time use cases? Where did you use each type in your NMG eCommerce project?",
            "answer": "Predicate<T>: method test(T t); inputs T (one generic type); returns boolean. Solves conditional logic reuse. Use: filter(item -> item > 5). NMG: Predicate<Order> isPending = o -> o.status().equals(\"PENDING\"). Function<T, R>: method apply(T t); inputs T; returns R (different type). Solves data transformation. Use: map(order -> order.getId()). NMG: Function<Product, String> getName = p -> p.getName(). Consumer<T>: method accept(T t); inputs T; returns void. Solves side effects without returning. Use: forEach(item -> print(item)). NMG: Consumer<Order> logger = o -> log.info(\"Order: \" + o.id()). Supplier<T>: method get(); inputs none; returns T. Solves lazy initialization. Use: Stream.generate(() -> new Item()). NMG: Supplier<Cart> cartLoader = () -> new Cart(). BiPredicate<T, U>: method test(T t, U u); inputs T and U; returns boolean. Solves two-parameter conditions. Use: filter((order, limit) -> order.total() < limit). NMG: BiPredicate<Customer, Integer> canOrder = (c, qty) -> c.balance() >= qty*100. BiFunction<T, U, R>: method apply(T t, U u); inputs T and U; returns R. Solves two-parameter transformations. Use: reduce((a, b) -> a + b). NMG: BiFunction<Order, Payment, Transaction> combiner = (o, p) -> new Transaction(o, p). BiConsumer<T, U>: method accept(T t, U u); inputs T and U; returns void. Solves two-parameter side effects. Use: forEach((key, value) -> handle(key, value)). NMG: BiConsumer<String, Double> priceUpdater = (productId, newPrice) -> updatePrice(productId, newPrice).",
            "useCases": [
                "Predicate for filtering collections and conditional logic",
                "Function for mapping and data transformation",
                "Consumer for processing items without returning values",
                "Supplier for factory and lazy loading patterns",
                "BiPredicate for multi-parameter conditions",
                "BiFunction for combining/aggregating two values",
                "BiConsumer for map iteration and multi-parameter side effects"
            ],
            "realTimeUseCases": [
                "Predicate: products.stream().filter(isPremium).collect()",
                "Function: orders.stream().map(getName)",
                "Consumer: cart.items().forEach(logger)",
                "Supplier: Stream.generate(cartLoader)",
                "BiPredicate: orders.stream().filter(canOrder)",
                "BiFunction: payments.reduce(combiner)",
                "BiConsumer: inventory.forEach(priceUpdater)"
            ]
        },
        {
            "id": 4,
            "name": "@FunctionalInterface Annotation",
            "question": "What is @FunctionalInterface annotation? What rules does it enforce? What problems does it prevent? Why should we use this annotation? What are real-time usage scenarios?",
            "answer": "@FunctionalInterface is an annotation to explicitly mark an interface as a functional interface. Enforces: exactly ONE abstract method (compile error if more), can have multiple default/static methods, ensures interface remains functional. Prevents: accidental violation of functional interface contract, prevents developer from adding second abstract method without noticing. Use: documents intent, enables compiler checking, improves code clarity. Real-time scenarios: @FunctionalInterface interface PaymentValidator { boolean validate(Payment p); } ensures only one validation method exists; @FunctionalInterface interface OrderProcessor { Order process(Order o); } guarantees single processing contract. In NMG: marked custom interfaces @FunctionalInterface interface InventoryChecker { boolean hasStock(String productId, int qty); } to prevent accidental multi-method contracts that would break Lambda usage.",
            "useCases": [
                "Document functional interface intent explicitly",
                "Enable compile-time checking for single abstract method",
                "Prevent accidental interface contract violations",
                "Improve code readability and IDE support"
            ],
            "realTimeUseCases": [
                "@FunctionalInterface interface PaymentValidator { boolean validate(Payment p); } ensures clarity",
                "@FunctionalInterface interface OrderProcessor { Order process(Order o); } prevents adding conflicting methods",
                "@FunctionalInterface interface InventoryChecker { boolean hasStock(String productId, int qty); } in product service"
            ]
        },
        {
            "id": 5,
            "name": "Method References",
            "question": "What is Method Reference in Java 8? What is the syntax of method references? What are the types (static, instance, constructor) and their method signatures? What problems does method reference solve compared to Lambda? What are real-time use cases? Where did you use method references in your project?",
            "answer": "Method Reference is a shorthand syntax for Lambda Expressions that call existing methods. Syntax: ClassName::methodName. Four types: (1) Static method reference: ClassName::staticMethod, e.g., Integer::parseInt converts string to int, signature: (String) -> int. (2) Instance method reference: object::instanceMethod, e.g., System.out::println prints items, signature: (Object) -> void. (3) Instance method from parameter: ClassName::instanceMethod, e.g., String::length gets string length, signature: (String) -> int. (4) Constructor reference: ClassName::new, e.g., ArrayList::new creates new list, signature: () -> ArrayList. Solves verbosity of Lambda; more readable when calling existing methods. Real-time use cases: Stream.map(Integer::parseInt), list.forEach(System.out::println), list.sort(String::compareTo), Stream.map(Product::getName). In NMG: used stream.map(Order::getId) to extract IDs, list.forEach(logger::info) for logging, list.sort(Product::compareByPrice) for sorting, stream.map(String::toUpperCase) for transformations, orders.stream().map(PaymentService::calculate) for payment calculation, inventory.stream().filter(Product::isAvailable) for availability checks.",
            "useCases": [
                "Reference static utility methods for transformations",
                "Reference instance methods for side effects or transformations",
                "Reference instance methods from stream elements",
                "Reference constructors for object creation",
                "Simplify stream operations with existing methods"
            ],
            "realTimeUseCases": [
                "Extract order IDs: orders.stream().map(Order::getId)",
                "Log each order: orders.forEach(logger::info)",
                "Sort by price: products.sort(Product::compareByPrice)",
                "Convert to uppercase: products.stream().map(String::toUpperCase)",
                "Calculate payment: orders.stream().map(PaymentService::calculate)",
                "Filter availability: products.stream().filter(Product::isAvailable)"
            ]
        },
        {
            "id": 6,
            "name": "Constructor Reference",
            "question": "What is Constructor Reference in Java 8? What is its syntax? What are the inputs and return type? Why do we use it? What problem does it solve? In which real-time scenarios did you apply constructor references in NMG?",
            "answer": "Constructor Reference is a shorthand for creating new objects using method references. Syntax: ClassName::new. Inputs are parameters passed to constructor (determined by context functional interface); return type is the class instance. Used to create objects concisely in streams and functional operations. Solves verbose object creation: instead of o -> new Order(o) use Order::new. Problems solved: cleaner syntax, reusable object creation, better readability in streams. In NMG: used Stream.map(OrderDTO::new) to convert Orders to DTOs, Stream.map(Product::new) for product creation from data, new ArrayList<>() equivalent written as ArrayList::new in stream operations, Notification::new for creating notifications from messages, PaymentRecord::new to wrap payment data, CartItem::new for creating cart items from products.",
            "useCases": [
                "Create DTOs from stream elements",
                "Instantiate objects in stream transformations",
                "Build collections of new objects from existing data",
                "Simplify object creation in functional pipelines"
            ],
            "realTimeUseCases": [
                "Convert to DTOs: orders.stream().map(OrderDTO::new)",
                "Create products: rawData.stream().map(Product::new)",
                "Build ArrayList: Stream.generate(() -> new Item()).limit(10).collect(Collectors.toCollection(ArrayList::new))",
                "Create notifications: messages.stream().map(Notification::new)",
                "Wrap payment data: payments.stream().map(PaymentRecord::new)"
            ]
        },
        {
            "id": 7,
            "name": "Stream API",
            "question": "What is Stream API in Java 8? Why was it introduced? What problems does it solve? What are the types of streams? What are the inputs and outputs of stream operations? What are real-time use cases? Where did you use Streams in your NMG eCommerce project?",
            "answer": "Stream API is a declarative way to process sequences of elements using functional operations. Why introduced: enable functional programming style, improve readability, simplify complex data processing. Problems solved: verbose loops replaced with concise pipeline syntax, easier data filtering/mapping/reducing, natural composition of operations, potential parallelization. Types of streams: Sequential Stream (default, single-threaded), Parallel Stream (multi-threaded), IntStream/LongStream/DoubleStream (primitive types), Stream<T> (generic). Inputs: collections via .stream(), arrays via Arrays.stream(), custom streams via Stream.of(). Outputs: collections via .collect(), single values via reduce(), terminal operations. Real-time use cases: filtering products by price, transforming orders to summaries, grouping by category, aggregating sales totals. In NMG: used streams extensively for products.stream().filter(p -> p.price() < 1000).map(Product::getName).collect(), orders.stream().mapToDouble(Order::getTotal).sum() for total sales, products.stream().distinct().count() for unique products, cart.items().stream().sorted().collect() for sorted items, customers.stream().groupingBy(Customer::getRegion) for regional analysis.",
            "useCases": [
                "Filter collections based on conditions",
                "Transform data using map operations",
                "Aggregate data using collect/reduce",
                "Sort and distinct operations",
                "Parallel processing of large datasets"
            ],
            "realTimeUseCases": [
                "Filter products: products.stream().filter(p -> p.price() < 1000).collect()",
                "Sum order totals: orders.stream().mapToDouble(Order::getTotal).sum()",
                "Count unique products: products.stream().distinct().count()",
                "Sort cart items: cart.items().stream().sorted().collect()",
                "Group by region: customers.stream().collect(groupingBy(Customer::getRegion))"
            ]
        },
        {
            "id": 8,
            "name": "Stream Intermediate Operations",
            "question": "Explain each intermediate Stream operation: map() - inputs? return type? syntax? filter() - inputs? return type? syntax? flatMap() - how does it work? inputs? return type? distinct() - how does equals/hashCode impact it? sorted() - types of comparators used? limit(), skip() - real scenarios? For each operation: What problem does it solve? What is the use case? Where did you use it in your NMG project?",
            "answer": "map(): inputs T element, outputs R transformed element; syntax stream.map(element -> transform(element)); transforms each element using Function<T, R>; problems solved: data conversion, extraction of properties. Used: orders.stream().map(Order::getId). filter(): inputs T element, outputs boolean; syntax stream.filter(element -> test(element)); filters elements using Predicate<T>; problems solved: narrowing stream to matching elements. Used: products.stream().filter(p -> p.isAvailable()). flatMap(): inputs T element returning Stream<R>, outputs combined Stream<R>; merges multiple streams into single stream; syntax stream.flatMap(element -> Stream.of(element)); solves nested collection flattening. Used: orders.stream().flatMap(o -> o.items().stream()). distinct(): removes duplicates; uses equals() and hashCode() for comparison; problems solved: ensuring unique elements. Used: products.stream().distinct().collect(). sorted(): orders elements using Comparator<T>; types: natural order (Comparable), custom Comparator, chain with thenComparing(); problems solved: arranging elements in desired order. Used: products.stream().sorted(Comparator.comparing(Product::getPrice)). limit(n): returns first n elements; syntax stream.limit(10); problems solved: pagination, sampling. Used: products.stream().limit(20).collect(). skip(n): skips first n elements; syntax stream.skip(10); problems solved: pagination, excluding first items. Used: products.stream().skip(10).limit(10) for page 2. In NMG: used map() to extract productIds, filter() for available products, flatMap() to combine all order items, distinct() to count unique customers, sorted() for top-N products, limit() for pagination, skip() for offset-based queries.",
            "useCases": [
                "map() for data extraction and transformation",
                "filter() for conditional narrowing",
                "flatMap() for nested collection flattening",
                "distinct() for removing duplicates",
                "sorted() for ordering by criteria",
                "limit() for pagination or sampling",
                "skip() for offset-based navigation"
            ],
            "realTimeUseCases": [
                "map(): orders.stream().map(Order::getId).collect()",
                "filter(): products.stream().filter(p -> p.price() < 1000)",
                "flatMap(): orders.stream().flatMap(o -> o.items().stream())",
                "distinct(): customers.stream().distinct().count()",
                "sorted(): products.stream().sorted(Comparator.comparing(Product::getPrice))",
                "limit(): products.stream().limit(20).collect()",
                "skip(): products.stream().skip(10).limit(10) for pagination"
            ]
        },
        {
            "id": 9,
            "name": "Stream Terminal Operations",
            "question": "Explain each terminal operation: forEach() â€“ input? return type? anyMatch(), allMatch(), noneMatch()? collect() â€“ types of collectors? return type? reduce() â€“ identity, accumulator, combiner? For each one: Why to use? What problems does it solve? What are the real-time scenarios? Where did you apply them in your eCommerce project?",
            "answer": "forEach(): inputs Consumer<T> for each element, returns void; executes side effects on each element; used for: logging, printing, updating state; problems solved: iterating with behavior without explicit loop. NMG: cart.items().forEach(item -> log.info(item.name())). collect(): inputs Collector<T, A, R> specifying how to accumulate, returns R (List, Map, Set, custom); types: Collectors.toList(), toSet(), toMap(), groupingBy(), partitioningBy(), joining(); used for: gathering stream results into collection; problems solved: terminal operation to materialize stream. NMG: orders.stream().collect(Collectors.toList()). reduce(): inputs identity value (initial), accumulator (combining function), optionally combiner (parallel); syntax: stream.reduce(identity, (acc, element) -> acc + element, (acc1, acc2) -> acc1 + acc2); returns Optional<T> or T; used for: aggregating all elements into single value; problems solved: sum, product, concatenation. NMG: orders.stream().mapToDouble(Order::getTotal).reduce(0, Double::sum). anyMatch(): inputs Predicate<T>, returns boolean; checks if ANY element matches; problems solved: existence check. NMG: orders.stream().anyMatch(o -> o.isPending()). allMatch(): inputs Predicate<T>, returns boolean; checks if ALL elements match; problems solved: validation of all items. NMG: products.stream().allMatch(p -> p.isAvailable()). noneMatch(): inputs Predicate<T>, returns boolean; checks if NO elements match; problems solved: ensuring no invalid items exist. NMG: orders.stream().noneMatch(o -> o.isCancelled()).",
            "useCases": [
                "forEach() for side effects (logging, updating)",
                "collect() for materializing stream into collection",
                "reduce() for aggregating values",
                "anyMatch() for existence checks",
                "allMatch() for validation",
                "noneMatch() for ensuring absence of items"
            ],
            "realTimeUseCases": [
                "forEach(): cart.items().forEach(item -> log.info(item.name()))",
                "collect(): orders.stream().collect(Collectors.toList())",
                "reduce(): orders.stream().mapToDouble(Order::getTotal).reduce(0, Double::sum)",
                "anyMatch(): orders.stream().anyMatch(o -> o.isPending())",
                "allMatch(): products.stream().allMatch(p -> p.isAvailable())",
                "noneMatch(): orders.stream().noneMatch(o -> o.isCancelled())"
            ]
        },
        {
            "id": 10,
            "name": "Optional Class",
            "question": "What is Optional in Java 8? Why was Optional introduced? What problems does it solve (NullPointerException)? What are its methods: of(), ofNullable(), empty(), get(), orElse(), orElseGet(), orElseThrow(), isPresent() / ifPresent()? For each method: What is the input? What is the return type? What are the use cases? In which scenarios did you use Optional in NMG?",
            "answer": "Optional<T> is a container for optional values; either contains non-null value or is empty. Why introduced: prevent NullPointerException by making null handling explicit. Problems solved: enforces null-checking, reduces defensive null-checks, improves code clarity. Methods: of(T value) creates Optional with value, throws NPE if null; input T, returns Optional<T>. ofNullable(T value) creates Optional with value or empty if null; input T, returns Optional<T>. empty() creates empty Optional; input none, returns empty Optional<T>. get() retrieves value, throws NoSuchElementException if empty; input none, returns T. orElse(T defaultValue) returns value or default; input T, returns T. orElseGet(Supplier<T>) returns value or supplied value; input Supplier<T>, returns T. orElseThrow() returns value or throws exception; input none, returns T. orElseThrow(Supplier<Exception>) throws custom exception; input Supplier<Exception>, returns T. isPresent() checks if value exists; input none, returns boolean. ifPresent(Consumer<T>) executes action if present; input Consumer<T>, returns void. In NMG: Optional<Customer> customer = Optional.ofNullable(findCustomer(id)); customer.ifPresent(c -> processOrder(c)); Optional<CartItem> item = cart.findItem(productId); item.orElseThrow(() -> new ItemNotFoundException()); orders.stream().filter(o -> o.getDiscount().isPresent()) for items with discounts; Optional<String> coupon = getCoupon(code); String discountCode = coupon.orElse(\"NO_CODE\"); payment balance: Optional<Double> balance = wallet.getBalance(); double amount = balance.orElseGet(() -> 0.0).",
            "useCases": [
                "of() for creating Optional with non-null values",
                "ofNullable() for creating Optional from potentially null values",
                "empty() for returning empty Optional",
                "get() for retrieving guaranteed non-null values",
                "orElse() for default values",
                "orElseGet() for lazy default supplier",
                "orElseThrow() for required values with custom exceptions",
                "isPresent()/ifPresent() for conditional actions"
            ],
            "realTimeUseCases": [
                "Optional.of(customer) for guaranteed non-null customer",
                "Optional.ofNullable(findDiscount(code)) for optional discounts",
                "item.orElseThrow(() -> new ItemNotFoundException())",
                "orders.stream().filter(o -> o.getDiscount().isPresent())",
                "coupon.orElse(\"NO_COUPON\") for default coupon code",
                "wallet.getBalance().orElseGet(() -> 0.0) for wallet amount"
            ]
        },
        {
            "id": 11,
            "name": "Default Methods",
            "question": "What are Default Methods in Interfaces in Java 8? What is the syntax? Why were they introduced? What problems do they solve for backward compatibility? What are real project use cases? Where did you use default methods in your NMG eCommerce application?",
            "answer": "Default Methods are methods in interfaces with implementation (using default keyword). Syntax: public default void methodName() { implementation }. Introduced: to add methods to existing interfaces without breaking implementations. Problems solved: backward compatibilityâ€”adding method to interface doesn't force all implementations to provide method; allows interface evolution without recompiling existing code. Real use cases: adding new functionality to framework interfaces, providing utility methods in API contracts, allowing default behavior with override option. In NMG: interface PaymentGateway { default boolean supportsRefund() { return true; } } allows old implementations without refund support to inherit default; interface Product { default double getDiscount() { return 0.0; } } provides default discount logic for standard products; interface Order { default String getOrderNumber() { return \"ORD-\" + getId(); } } generates order number with default format; interface CartItem { default long getTimestamp() { return System.currentTimeMillis(); } } adds timestamp tracking without breaking legacy cart items.",
            "useCases": [
                "Add methods to existing interfaces safely",
                "Provide default implementations for optional behavior",
                "Support framework evolution without breaking changes",
                "Share utility methods across implementations"
            ],
            "realTimeUseCases": [
                "interface PaymentGateway { default boolean supportsRefund() { return true; } }",
                "interface Product { default double getDiscount() { return 0.0; } }",
                "interface Order { default String getOrderNumber() { return \"ORD-\" + getId(); } }",
                "interface CartItem { default long getTimestamp() { return System.currentTimeMillis(); } }"
            ]
        },
        {
            "id": 12,
            "name": "Static Methods in Interfaces",
            "question": "What are Static Methods inside interfaces in Java 8? What is the syntax? Why do we need them? What are the benefits? What are real-time use cases? Where did you use static interface methods?",
            "answer": "Static Methods in interfaces are utility methods that belong to interface itself (not instances). Syntax: public static returnType methodName(parameters) { implementation }. Needed: to group utility methods logically with interface, providing factory methods, helper functions related to interface concern. Benefits: logical grouping with interface definition, no separate utility classes needed, cleaner API organization, static context access. Real-time use cases: factory methods, converters, validators specific to interface type. In NMG: interface Product { static Product create(String name, double price) { return new ProductImpl(name, price); } } provides factory in interface; interface Order { static Order parse(String json) { return gson.fromJson(json, Order.class); } } provides parsing utility; interface Cart { static double calculateTax(double subtotal) { return subtotal * 0.05; } } provides tax calculation; interface Notification { static void sendBulk(List<Notification> notifs) { notifs.forEach(Notification::send); } } provides bulk send utility.",
            "useCases": [
                "Factory methods for creating instances",
                "Converters and parsers for data transformation",
                "Utility functions related to interface contract",
                "Helper methods for common operations"
            ],
            "realTimeUseCases": [
                "interface Product { static Product create(String name, double price) { ... } }",
                "interface Order { static Order parse(String json) { ... } }",
                "interface Cart { static double calculateTax(double subtotal) { ... } }",
                "interface Notification { static void sendBulk(List<Notification> notifs) { ... } }"
            ]
        },
        {
            "id": 13,
            "name": "Date & Time API",
            "question": "What is the new Date and Time API in Java 8, and why was it introduced? What problems of old Date API does it solve? Explain: LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Duration, Period, Instant? For each type: What is the purpose? What are the inputs? What is the return type? What are real-time use cases? Where did you use them in NMG?",
            "answer": "New Date and Time API (java.time package) is immutable, thread-safe, fluent API. Introduced: to replace error-prone old Date/Calendar classes. Problems solved: old Date was mutable (thread-unsafe), TimeZone handling buggy, confusing month indexing (0-11), verbose code. LocalDate: represents date without time (YYYY-MM-DD); inputs: year, month, day; methods: now(), of(2024, 1, 1), plusDays(n), minusMonths(n); used for: birthdates, order dates, deadlines. NMG: LocalDate orderDate = LocalDate.now(); LocalDate deadline = orderDate.plusDays(7). LocalTime: represents time without date (HH:MM:SS); inputs: hour, minute, second; methods: now(), of(14, 30, 0), plus(Duration), isBefore(); used for: business hours, delivery windows. NMG: LocalTime startTime = LocalTime.of(9, 0); LocalTime endTime = startTime.plusHours(8). LocalDateTime: combines date and time; inputs: LocalDate and LocalTime; methods: now(), atStartOfDay(), isBefore(), until(); used for: event timestamps, scheduled tasks. NMG: LocalDateTime orderTime = LocalDateTime.now(); LocalDateTime shipTime = orderTime.plusHours(24). ZonedDateTime: includes timezone information; inputs: LocalDateTime and ZoneId; methods: now(ZoneId.of(\"Asia/Kolkata\")), withZoneSameInstant(); used for: multi-timezone applications, international orders. NMG: ZonedDateTime internationalTime = ZonedDateTime.now(ZoneId.of(\"UTC\")). Duration: time-based amount (hours, minutes, seconds); inputs: nanos, seconds; methods: between(startTime, endTime), plus(Duration), getDays(); used for: time differences, timeouts, durations. NMG: Duration processingTime = Duration.between(startTime, endTime). Period: date-based amount (years, months, days); inputs: year, month, day; methods: between(startDate, endDate), plus(Period), getYears(); used for: age calculation, durations in years/months. NMG: Period membershipPeriod = Period.between(joinDate, currentDate). Instant: represents specific moment in time (UTC); inputs: epochSeconds, nanoAdjustment; methods: now(), ofEpochMilli(), atZone(); used for: logging timestamps, comparisons, UTC timestamps. NMG: Instant createdAt = Instant.now().",
            "useCases": [
                "LocalDate for dates without time component",
                "LocalTime for time-of-day operations",
                "LocalDateTime for combined date-time handling",
                "ZonedDateTime for timezone-aware timestamps",
                "Duration for time-based calculations",
                "Period for date-based calculations",
                "Instant for UTC timestamps and comparisons"
            ],
            "realTimeUseCases": [
                "LocalDate: LocalDate orderDate = LocalDate.now(); LocalDate deadline = orderDate.plusDays(7)",
                "LocalTime: LocalTime businessOpen = LocalTime.of(9, 0); LocalTime businessClose = businessOpen.plusHours(8)",
                "LocalDateTime: LocalDateTime orderTime = LocalDateTime.now()",
                "ZonedDateTime: ZonedDateTime internationalTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))",
                "Duration: Duration processingTime = Duration.between(start, end)",
                "Period: Period membership = Period.between(joinDate, today)",
                "Instant: Instant createdAt = Instant.now()"
            ]
        },
        {
            "id": 14,
            "name": "Parallel Streams",
            "question": "What are Parallel Streams in Java 8? How do they work internally? What problems do they solve? What is the syntax? What are the risks (thread safety)? What are real-time performance use cases? Where did you use Parallel Streams in your eCommerce system?",
            "answer": "Parallel Streams are multi-threaded streams using Fork/Join framework to process elements concurrently. Internally: divides stream into sub-streams, processes each in separate thread using thread pool, combines results using combiner. Syntax: collection.parallelStream() or stream.parallel(). Problems solved: exploits multi-core processors, faster processing for large datasets (CPU-intensive), better throughput. Risks: thread safety (stateful operations cause race conditions), non-thread-safe collectors, ordering issues, context switching overhead negates benefits for small streams. Thread safety: avoid mutable state, use thread-safe collectors (Collectors.toList() is safe), avoid order-dependent operations, ensure operations are associative and commutative. Real-time use cases: processing millions of products, calculating aggregate statistics, batch transformations. In NMG: used parallelStream() for large product catalog analysis: products.parallelStream().filter(p -> p.price() > 1000).count() counted premium products faster; orders.parallelStream().mapToDouble(Order::getTotal).sum() summed order totals in parallel; inventory.parallelStream().map(Product::calculateTax).collect() calculated taxes concurrently. Avoided: stateful operations, complex multi-step transformations (parallelization overhead exceeds benefit).",
            "useCases": [
                "Process large datasets efficiently",
                "CPU-intensive calculations in parallel",
                "Batch transformations on millions of items",
                "Aggregation operations on massive collections"
            ],
            "realTimeUseCases": [
                "Count premium products: products.parallelStream().filter(p -> p.price() > 1000).count()",
                "Sum order totals: orders.parallelStream().mapToDouble(Order::getTotal).sum()",
                "Calculate taxes: inventory.parallelStream().map(Product::calculateTax).collect()",
                "Group by category: products.parallelStream().collect(groupingBy(Product::getCategory))"
            ]
        },
        {
            "id": 15,
            "name": "Spliterator",
            "question": "What is Spliterator in Java 8? What methods does it contain? What are the input parameters and return types of these methods? Why was Spliterator introduced? What problems does it solve compared to Iterator? What are the real-time use cases?",
            "answer": "Spliterator is an iterator for splitting collections into parallel sub-sequences (Split + Iterator). Methods: tryAdvance(Consumer<T>) advances and applies action, returns boolean; trySplit() splits into two Spliterators, returns Optional<Spliterator<T>>; forEachRemaining(Consumer<T>) applies action to all remaining, returns void; estimateSize() returns approximate remaining count as long; getExactSizeIfKnown() returns exact size as long if known, else -1; characteristics() returns int flags (ORDERED, DISTINCT, SORTED, SIZED, CONCURRENT, IMMUTABLE, NONNULL, SUBSIZED). Why introduced: supports parallel iteration with better partitioning, enables load balancing across threads, better for structured concurrent processing. Problems solved: Iterator is sequential only, single-threaded; Spliterator enables parallel traversal, partition awareness, size estimation for better parallelization. Real-time use cases: custom parallel collection implementations, optimizing parallel stream operations, large data processing with balanced distribution.",
            "useCases": [
                "Implement custom parallel-enabled collections",
                "Optimize parallel stream performance",
                "Balance workload across threads in parallel processing",
                "Provide spliterator for custom collection types"
            ],
            "realTimeUseCases": [
                "Custom parallel product collection with tryAdvance() and trySplit()",
                "Large order batch processing with load balancing across threads",
                "Parallel inventory update with size estimation for thread allocation"
            ]
        },
        {
            "id": 16,
            "name": "CompletableFuture",
            "question": "What is CompletableFuture in Java 8? Why was it introduced? What problems of Future interface does it solve? What are the main methods: supplyAsync(), runAsync(), thenApply(), thenAccept(), thenCompose(), thenCombine(), exceptionally()? For each method: Inputs? Return type? Real-time async use cases? Where did you use CompletableFuture in your NMG project?",
            "answer": "CompletableFuture<T> is a Future that can be manually completed or chained with other futures. Why introduced: Future.get() blocks (no async chaining), CompletableFuture enables non-blocking async pipelines. Problems solved: composable futures, exception handling, manual completion, callback-style programming. supplyAsync(Supplier<T>): inputs Supplier<T> returning value, returns CompletableFuture<T>; executes async and returns result. runAsync(Runnable): inputs Runnable (void), returns CompletableFuture<Void>; executes async without result. thenApply(Function<T, R>): inputs Function transforming T to R, returns CompletableFuture<R>; chains transformation. thenAccept(Consumer<T>): inputs Consumer processing T, returns CompletableFuture<Void>; chains side effect. thenCompose(Function<T, CompletableFuture<R>>): inputs Function returning CompletableFuture, returns CompletableFuture<R>; chains async operations (avoids nesting). thenCombine(other, BiFunction): inputs other future and combiner, returns CompletableFuture<R>; combines two futures. exceptionally(Function<Throwable, T>): inputs handler for exception, returns CompletableFuture<T>; handles errors. In NMG: supplyAsync(() -> fetchProduct(id)).thenApply(p -> p.getPrice()).thenAccept(price -> logPrice(price)) fetches product and logs price async; CompletableFuture.supplyAsync(() -> processPayment(order)).exceptionally(ex -> handlePaymentFailure(ex)) processes payment with fallback; CompletableFuture.supplyAsync(() -> fetchInventory()).thenCompose(inventory -> applyDiscount(inventory)) chains async inventory fetch with discount application; thenCombine() combines payment verification with inventory check: paymentFuture.thenCombine(inventoryFuture, (payment, inventory) -> confirmOrder(payment, inventory)).",
            "useCases": [
                "Execute async operations non-blocking",
                "Chain async operations without blocking",
                "Combine multiple async results",
                "Handle async exceptions with fallback",
                "Parallel async operations with load balancing"
            ],
            "realTimeUseCases": [
                "supplyAsync(() -> fetchProduct(id)).thenApply(p -> p.getPrice())",
                "runAsync(() -> sendNotification(order))",
                "payment.thenCompose(p -> applyDiscount(p))",
                "paymentFuture.thenCombine(inventoryFuture, (p, i) -> confirmOrder(p, i))",
                "paymentFuture.exceptionally(ex -> handleFailure(ex))"
            ]
        },
        {
            "id": 17,
            "name": "Stream Pipeline",
            "question": "What is a Stream Pipeline? What are the stages? How does lazy evaluation work? Why is pipeline execution efficient? What are real-time use cases? Where did you use stream pipelines in your project?",
            "answer": "Stream Pipeline is a sequence of operations on stream: source â†’ intermediate operations â†’ terminal operation. Stages: (1) Stream source (collection, array, generated), (2) Intermediate operations (filter, map, flatMap, etc.), (3) Terminal operation (forEach, collect, reduce). Lazy evaluation: intermediate operations don't execute until terminal operation called; operations are accumulated and executed in single pass when terminal operation triggers. Efficient because: single-pass evaluation (avoids multiple iterations), short-circuit evaluation (limit() stops processing), can fuse operations, enables parallelization. Real-time use cases: filtering and transforming large datasets, complex data aggregations, multi-step transformations. In NMG: products.stream().filter(p -> p.price() < 1000).map(Product::getName).sorted().limit(10).collect(Collectors.toList()) creates pipeline: filter â†’ map â†’ sort â†’ limit â†’ collect executed in single pass. orders.stream().flatMap(o -> o.items().stream()).map(Item::getPrice).reduce(0.0, Double::sum) chains multiple intermediate operations with lazy evaluationâ€”intermediate operations accumulate until reduce() terminal operation executes. Complex pipeline: customers.stream().filter(c -> c.isActive()).flatMap(c -> c.getOrders().stream()).filter(o -> o.getTotal() > 500).map(o -> o.getId()).distinct().sorted().collect() flattens orders, filters high-value, transforms IDs, deduplicates, sortsâ€”all in single lazy pass.",
            "useCases": [
                "Multi-step data transformations efficiently",
                "Filter-map-collect patterns",
                "Complex data aggregations",
                "Short-circuit operations with limit()"
            ],
            "realTimeUseCases": [
                "products.stream().filter(p -> p.price() < 1000).map(Product::getName).sorted().limit(10).collect()",
                "orders.stream().flatMap(o -> o.items().stream()).map(Item::getPrice).reduce(0.0, Double::sum)",
                "customers.stream().filter(c -> c.isActive()).flatMap(c -> c.getOrders().stream()).filter(o -> o.getTotal() > 500).distinct().collect()"
            ]
        },
        {
            "id": 18,
            "name": "Collection API Enhancements",
            "question": "What enhancements were added to Collections API in Java 8? Explain: forEach(), removeIf(), computeIfAbsent(), computeIfPresent(), replaceAll(), sort()? For each method: Inputs, return types? Syntax? Use cases? Where did you apply them in NMG?",
            "answer": "forEach(Consumer<T>): input Consumer<T>, returns void; iterates over collection executing action; syntax list.forEach(item -> process(item)); used for: side effects, logging, processing all items. NMG: orders.forEach(o -> sendConfirmation(o)). removeIf(Predicate<T>): input Predicate<T>, returns boolean; removes elements matching condition; syntax list.removeIf(item -> item.isExpired()); problems solved: safe removal during iteration. NMG: cart.items().removeIf(item -> item.quantity() == 0). computeIfAbsent(K, Function<K, V>): inputs key and function computing value, returns V; computes value if key absent; syntax map.computeIfAbsent(productId, id -> fetchProduct(id)); problems solved: lazy loading, cache population. NMG: productCache.computeIfAbsent(productId, id -> db.getProduct(id)). computeIfPresent(K, BiFunction<K, V, V>): inputs key and update function, returns V; updates value if key present; syntax map.computeIfPresent(orderId, (id, order) -> order.updateStatus()); NMG: orderMap.computeIfPresent(orderId, (id, o) -> o.markShipped()). replaceAll(UnaryOperator<T>): input operator transforming each element, returns void; replaces all elements; syntax list.replaceAll(item -> item.toUpperCase()); NMG: productNames.replaceAll(name -> name.trim()). sort(Comparator<T>): input Comparator<T>, returns void; sorts in place; syntax list.sort((p1, p2) -> p1.price() - p2.price()); NMG: products.sort(Comparator.comparing(Product::getPrice)).",
            "useCases": [
                "forEach() for iterating with functional operations",
                "removeIf() for safe removal during iteration",
                "computeIfAbsent() for lazy loading and caching",
                "computeIfPresent() for conditional updates",
                "replaceAll() for bulk element transformation",
                "sort() for in-place sorting with custom comparators"
            ],
            "realTimeUseCases": [
                "forEach(): orders.forEach(o -> sendConfirmation(o))",
                "removeIf(): cart.items().removeIf(item -> item.quantity() == 0)",
                "computeIfAbsent(): productCache.computeIfAbsent(productId, id -> db.getProduct(id))",
                "computeIfPresent(): orderMap.computeIfPresent(orderId, (id, o) -> o.markShipped())",
                "replaceAll(): productNames.replaceAll(name -> name.trim())",
                "sort(): products.sort(Comparator.comparing(Product::getPrice))"
            ]
        },
        {
            "id": 19,
            "name": "StringJoiner",
            "question": "What is StringJoiner? What are its constructors? What methods does it provide? What problems does it solve compared to StringBuilder? What are the real-time use cases?",
            "answer": "StringJoiner is a utility for joining strings with delimiter, prefix, and suffix. Constructors: StringJoiner(delimiter) for simple joining; StringJoiner(delimiter, prefix, suffix) for formatted joining. Methods: add(CharSequence) appends value, returns StringJoiner; merge(StringJoiner) combines joiners; toString() returns final string; length() returns length; setEmptyValue() sets value for empty joiner. Problems solved: cleaner than StringBuilder for joining with delimiter, automatic delimiter handling, prefix/suffix support without manual concatenation. Real-time use cases: CSV generation, URL parameter building, log message formatting, SQL value lists. In NMG: StringJoiner csv = new StringJoiner(\",\"); products.forEach(p -> csv.add(p.getName())); // \"Product1,Product2,Product3\". StringJoiner urlParams = new StringJoiner(\"&\", \"?\", \"\"); order.getParams().forEach((k, v) -> urlParams.add(k + \"=\" + v)); // \"?key1=val1&key2=val2\". StringJoiner logValues = new StringJoiner(\" | \", \"[\", \"]\"); logValues.add(\"orderId=\" + orderId).add(\"status=\" + status).add(\"amount=\" + amount); // \"[orderId=123 | status=PENDING | amount=1000]\". Used for generating CSV reports, building API query strings, formatting log messages.",
            "useCases": [
                "Join strings with automatic delimiter handling",
                "Build CSV/TSV output",
                "Construct URL query parameters",
                "Format log messages with structured separators"
            ],
            "realTimeUseCases": [
                "CSV generation: StringJoiner csv = new StringJoiner(\",\"); products.forEach(p -> csv.add(p.getName()))",
                "URL parameters: StringJoiner urlParams = new StringJoiner(\"&\", \"?\", \"\"); params.forEach((k, v) -> urlParams.add(k + \"=\" + v))",
                "Log formatting: StringJoiner logs = new StringJoiner(\" | \", \"[\", \"]\"); logs.add(\"orderId=\" + id).add(\"status=\" + status)"
            ]
        },
        {
            "id": 20,
            "name": "Repeatable Annotations",
            "question": "What are Repeatable Annotations in Java 8? Why do we use them? How do we define a repeatable annotation? What problems do they solve? What are real-time use cases?",
            "answer": "Repeatable Annotations allow applying same annotation multiple times on single element. Why: express multiple values of same annotation type, better readability than wrapper annotations. How to define: create annotation with @Repeatable(ContainerAnnotation.class); create container annotation holding array of repeatable annotation. Problems solved: previously required wrapping in container; now cleaner syntax. Real-time use cases: multiple validators, multiple authorizations, scheduling multiple tasks. In NMG: @Repeatable(Validators.class) @interface Validator { String rule(); } then use @Validator(rule=\"minPrice\") @Validator(rule=\"maxPrice\") on Product class. @Repeatable(Permissions.class) @interface Permission { String role(); } used as @Permission(role=\"ADMIN\") @Permission(role=\"MANAGER\") on order endpoint. @Repeatable(Schedules.class) @interface Schedule { String cron(); } applies @Schedule(cron=\"0 0 * * *\") @Schedule(cron=\"0 12 * * *\") for multiple scheduled tasks.",
            "useCases": [
                "Apply multiple validators to field",
                "Specify multiple permission requirements",
                "Schedule multiple recurring tasks",
                "Apply multiple cross-cutting concerns to method"
            ],
            "realTimeUseCases": [
                "@Validator(rule=\"minPrice\") @Validator(rule=\"maxPrice\") on Product",
                "@Permission(role=\"ADMIN\") @Permission(role=\"MANAGER\") on endpoint",
                "@Schedule(cron=\"0 0 * * *\") @Schedule(cron=\"0 12 * * *\") for cache refresh"
            ]
        }
    ]
}